<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.useso.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="ov智商捉急" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta name="description" content="你猜?">
<meta property="og:type" content="website">
<meta property="og:title" content="ov智商捉急">
<meta property="og:url" content="http://ovjaywang.github.io/index.html">
<meta property="og:site_name" content="ov智商捉急">
<meta property="og:description" content="你猜?">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ov智商捉急">
<meta name="twitter:description" content="你猜?">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> ov智商捉急 </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container one-collumn sidebar-position-left page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta custom-logo">
  
    <div class="site-meta-headline">
      <a>
        <img class="custom-logo-image" src="/images/touxiang.jpg" alt="ov智商捉急">
      </a>
    </div>
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">ov智商捉急</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/me" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sth">
          <a href="/sth" rel="section">
            
              <i class="menu-item-icon fa fa-child fa-fw"></i> <br>
            
            有料
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input">
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'ZtWPUvzBjdXDQ7iNrTbW','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/27/effective java 笔记--创建对象的几个tips/" itemprop="url">
                  effective java 笔记--创建对象的几个tips
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-27T11:50:01+08:00" content="2016-04-27">
              2016-04-27
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/27/effective java 笔记--创建对象的几个tips/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/27/effective java 笔记--创建对象的几个tips/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="不希望被实例化-又不想抽象化"><a href="#不希望被实例化-又不想抽象化" class="headerlink" title="不希望被实例化 又不想抽象化"></a>不希望被实例化 又不想抽象化</h1><p>某些类不希望被实例化出毫无意义的对象 但不编写显示构造器类会自定义一个隐式无参的构造器 因此可以用一下方式，编写不能实例化的类：</p>
<pre><code class="java">
    public class UtilityClass{
        private UtilityClass(){
            throw new AssertionError();//直接抛出assert验证异常 好坏
        }
    }
</code></pre>
<p>该构造器是私有的。其他类不能过访问（即使同包）。</p>
<h1 id="不要创建没必要的对象"><a href="#不要创建没必要的对象" class="headerlink" title="不要创建没必要的对象"></a>不要创建没必要的对象</h1><p>不可变的对象一定要重用（singleton）；重用绝逼不会变的对象（例如计时初始时间、例如物种的属性）。例如，实例化Person对象的时候判断是不是计划生育年代出生的，即判断出生年份是否在1983-2015年。</p>
<pre><code>
class Person{
   private final Date birthDate;
   private static final Date BIRTH_START;
   //这俩参数都是不变的 为了对比出生时间 
   //没必要每次都创建一个日期对象，只在初始化时调用。
   private static final Date BIRTH_END; 

//静态块的方法 第一次声明Person对象时构建（不用实例化）
// 后面占用一块内存 不用再次创建
   static{
        Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;));
        gmtCal.set(1983,Calendar.JANUARY,1,0,0,0);
        //这里对日期做了时区判断 
        //保证都是从某一客观时间点出生的
        BIRTH_START = gmtCal.getTime();
        gmtCal.set(2016,Calendar.JANUARY,1,0,0,0);
        //截止2015年年底 所以取2016年年初
        BIRTH_END = gmtCal.getTime();
   }

    public boolean isJiHuaShengYu(){
        return birthDate.compareTo(BIRTH_START) &gt;=0 &amp;&amp;
            birthDate.compareTo(BIRTH_END) &lt;=0;
    }
}
</code></pre><p>如果isJiHuaShengYu方法<font color="red">从未调用</font>，这个方法就显得不合时宜了，这块静态块的内存就一直占着，因此，可以采用延时初始化的方式，在第一次调用该方法时调用。</p>
<p>adapter适配器模式可以提供一个后备对象，使实例化次数减少（包括类适配器和对象适配器）；autoboxing自动装箱模式能够自动创建多余对象，所以尽量少用，而使用基本数据类型。</p>
<h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><blockquote>
<p>adapter工作场景</p>
</blockquote>
<p>适配器模式工作场景是：给定的一个接口不满足需求，需要其一些功能与其他的接口或类配合使用.正如已经给了电压和充电插座，但是插座电压与设备工作电压，这是时候就需要一个转换接头。</p>
<blockquote>
<p>autoboxing方式</p>
</blockquote>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/27/hexo多客户端写作/" itemprop="url">
                  Hexo多客户端写作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-27T11:50:01+08:00" content="2016-04-27">
              2016-04-27
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/27/hexo多客户端写作/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/27/hexo多客户端写作/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>Hexo是很棒的静态博客，简单的安装配置即可专注写作。<br>但是强迫症就是很爱折腾。倘若：</p>
<ul>
<li>主机烧了数据备份怎么破？</li>
<li>换了系统想继续之前的写作怎么破?</li>
<li>纯粹就是想多客户端写作怎么破？</li>
</ul>
</blockquote>
<p>我就纯属蛋疼的。喜欢在办公和休息的地方都写作；或者我一win本<br>一mac 都想写文章。但Hexo的静态部署的原则不像WordPress一样，能关联博客地址，利用数据库进行博客更新。好了，这里就来解决这个问题。┑(￣Д ￣)┍</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/04/27/hexo多客户端写作/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/22/effective java--builer构造器/" itemprop="url">
                  effective java--builer构造器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-22T17:10:48+08:00" content="2016-04-22">
              2016-04-22
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/代码狗/" itemprop="url" rel="index">
                    <span itemprop="name">代码狗</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/代码狗/学习log/" itemprop="url" rel="index">
                    <span itemprop="name">学习log</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/22/effective java--builer构造器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/22/effective java--builer构造器/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>一个实体类往往有不同的属性 属性有的用于构造器 视为构造时的必需参数 而有的可有可无 类似json和xml一般，有多少个属性，每个属性有多少个赋值都不确定 。e.g.动物 名称string name和是否有尾巴istail是必须的，是否吃草iseatgrass 多重weight 交配手段sexmethod 科目等为非必须字段。解决这一构造问题一般有三种方式。<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/04/22/effective java--builer构造器/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </p></div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/22/what-the-hell-of-sdf/" itemprop="url">
                  删除sdf文件导致转到定义失效
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-22T16:38:11+08:00" content="2016-04-22">
              2016-04-22
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/什么都学一下/" itemprop="url" rel="index">
                    <span itemprop="name">什么都学一下</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/什么都学一下/学习log/" itemprop="url" rel="index">
                    <span itemprop="name">学习log</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/22/what-the-hell-of-sdf/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/22/what-the-hell-of-sdf/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>cmomit的时候发现一个<strong>.sdf</strong>的文件特别大，项目才不到2m，一个sdf就30多m了。能不能删？<br>谷歌了一下，提示sdf文件和iph文件是存放预编译头和Intellisense的。<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/04/22/what-the-hell-of-sdf/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </p></div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/13/effective java--静态工厂/" itemprop="url">
                  effective java笔记--静态工厂和Builder模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-13T15:15:14+08:00" content="2016-04-13">
              2016-04-13
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/代码狗/" itemprop="url" rel="index">
                    <span itemprop="name">代码狗</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/代码狗/学习log/" itemprop="url" rel="index">
                    <span itemprop="name">学习log</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/13/effective java--静态工厂/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/13/effective java--静态工厂/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h1><pre><code class="java">    public static Boolean valueOf (boolean b){
        return b?Boolean.True:Boolean.False;
    }
</code></pre>
<p>静态工厂以其名字显见，以[类名.方法名]的方式调用，其静态函数主要返回其类的对象，一般是引用值。返回什么东西，由参数决定，这个工厂给你产出来。其在API开发中使用广泛。<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/04/13/effective java--静态工厂/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </p></div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/10/Hello-Hexo/" itemprop="url">
                  Hexo双备份Github和Coding&域名绑定
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-10T22:51:49+08:00" content="2016-04-10">
              2016-04-10
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/槽/" itemprop="url" rel="index">
                    <span itemprop="name">槽</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/10/Hello-Hexo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/10/Hello-Hexo/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>感谢<a href="http://zipperary.com/2013/05/28/hexo-guide-2/">这个教程</a><br>还有<a href="http://ibruce.info/2013/11/22/hexo-your-blog/?utm_source=tuicool">这个</a><br>解决了好多bugs的<a href="http://www.jianshu.com/p/35e197cb1273">这个</a><br>优化cdn图床缓冲的<a href="http://lukang.me/2015/optimization-of-hexo-2.html">这个</a><br><a href="http://www.dute.me/">这个</a>让我找到了便宜的狗爹优惠码</p>
<pre><code>从一开始的阵地wp搬到这里来了。后会有期了dooby.me 再见了WordPress  
默默的是有些不舍。虽然push很慢虽然被墙了大半  
4年光阴不复返啊。从一个逗比成长为大逗比了。
</code></pre>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/04/10/Hello-Hexo/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/01/记静态ip的坑/" itemprop="url">
                  记静态ip的坑
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-01T16:06:32+08:00" content="2016-04-01">
              2016-04-01
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/什么都学一下/" itemprop="url" rel="index">
                    <span itemprop="name">什么都学一下</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/什么都学一下/学习log/" itemprop="url" rel="index">
                    <span itemprop="name">学习log</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/01/记静态ip的坑/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/01/记静态ip的坑/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>明明在hadoop配置静态IP的时候被坑过一次，却完全想不起来怎么解决的。尤其是在ssh登录的时候需要记下host和ip的对应，才能直接输出主机名来访问局域网内的其他主机。<br>现在记下来。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/04/01/记静态ip的坑/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/08/最近demo 模块 算法总结/" itemprop="url">
                  最近demo 模块 算法总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-08T17:43:56+08:00" content="2016-03-08">
              2016-03-08
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/代码狗/" itemprop="url" rel="index">
                    <span itemprop="name">代码狗</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/代码狗/学习log/" itemprop="url" rel="index">
                    <span itemprop="name">学习log</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/08/最近demo 模块 算法总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/08/最近demo 模块 算法总结/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><a href="http://ju.outofmemory.cn/entry/106397" title="http://ju.outofmemory.cn/entry/106397">http://ju.outofmemory.cn/entry/106397</a> 【坑妹填完】</p>
<p>最近各种乱整。。文章妹时间管光顾着折腾手头派下来的事情了。再加上每天固定的复习提高一下。小论文完全没有头绪。<br>最近get到的实用方法还是很多阿。<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/03/08/最近demo 模块 算法总结/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </p></div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/25/opencv-findhomography-findfundanmentalmat/" itemprop="url">
                  由opencv中findFundamentalMat和findHomography区别的引申
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-01-25T00:54:26+08:00" content="2016-01-25">
              2016-01-25
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/什么都学一下/" itemprop="url" rel="index">
                    <span itemprop="name">什么都学一下</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/什么都学一下/学习log/" itemprop="url" rel="index">
                    <span itemprop="name">学习log</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/25/opencv-findhomography-findfundanmentalmat/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/25/opencv-findhomography-findfundanmentalmat/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>opencv 中，进行<strong>图像拼接(全景拼接 航摄拼接 三维重建 街景地图)</strong>，大致流程如下。</p>
<ol>
<li>利用opencv提供的各类型特征点检测方法（Fast Start SIFT SURF ORB SimpleBlobPyramidAdapter DynamicAdapter 等）在图像中将感兴趣的有独特标识的点找出来,其中orb 是最近提出效率较高的检测和描述算法，金字塔算法则是更高的提高效率的算法；</li>
<li>利用不同的描述方式（SIFT SURF），对特征点的信息（周围的梯度、灰度相关性 二进制编码等）进行描述； </li>
<li>利用不同原则的匹配方式（BF Flann-based等），对这些描述子（一般是多维矩阵）进行匹配（匹配中数据的输入参数的筛选Ransac方法），对匹配结果反向计算进一步的筛查，选择更健壮更有代表性的数据（knn Ransac），</li>
<li>最后利用findhomography找到映射矩阵，再利用affine将该坐标映射关系对其中一幅图贴到其中一幅图中。 完成拼接。拼接区域涉及融合平滑。</li>
</ol>
<p>这其中，<strong>findfundamentalmat()</strong>和<strong>findhomography()</strong>都是用来查找两组匹配坐标点的映射关系的（两组坐标几何 数目相同 同一<strong>数组位</strong>为同一对匹配点）试着运行了一下homography生成的矩阵拼接效果良好。而findfundamentalmat就不太6.找了一些相关资料，其实这是两个相似但不相同的函数。so开始之前科普几个概念：</p>
<hr>
<p><strong>核点（极点）</strong>：摄影中心连线（基线）ss’延长线，与左右影像的交点，分为左右核点（极点）。（注：下图两影像接近平行，则ss’连线与影像无交点，而在下下图中，el er分别为左右核点【极点】）亦可理解为左右摄影中心分别在对方像片的像点</p>
<p><strong>核面（极面）</strong> ：过摄影基线与物方任意一点组成的平面。（所以缩，物方点不同，核面一般也不同 任意一个下图的PO1O2都是核面）</p>
<p><strong>核线（极线）：立体像对中，同名光线与摄影基线所组成核面与左右像片的交线。</strong> （不同同名点极线不同，因而有很多很多条） </p>
<p><strong>极线约束</strong> ：同一个点在两幅图像上的映射，已知左图映射点p1，那么右图映射点p2一定在p1的外极线上，这样可以减少匹配点数量。</p>
<center><img src="http://ooo.0o0.ooo/2016/02/24/56ce7786da1fa.png" alt=""></center>

<p>上图中，红线即为极线，物方点P（X,Y,Z）分别在左右两图留下了同名点（xl，yl）、（xr,yr）。Tx即为基线长。但上图为两个平面接近平行且z方向接近0，但一般情况下，两像平面以任意角度成像同时内参数并不相同，因此上图中的极线呈现出共线的情况，更多的情况是下面这个图，两图像成任意角度。</p>
<center><img src="http://ooo.0o0.ooo/2016/02/24/56ce782a3235f.png" alt=""></center>

<p>下图中，O1O2连线与左右像平面交点el和er即为左右极点(极点亦可理解为左右摄影中心在另一像平面的像)，而极线则为plel和prer。可以看到，这两条线显然就不平行了。 </p>
<center><img src="http://ooo.0o0.ooo/2016/02/24/56ce77b362343.png" alt=""></center>

<p><strong>基线</strong> ：相邻两摄站点（摄影中心 一般标为s）之间的连线。</p>
<p><strong>主核面</strong> ：左右像主点分别与基线构成的平面，分别称为左主核面和右主核面。</p>
<p><strong>灭点vanishing </strong> point：平行线在二维图像中汇聚的地方，空间中每一组平行线都有自己的灭点。</p>
<p><strong>灭线vanishing line（消隐线 ）</strong> ：不同的灭线连线，即灭线。如果两组不同的平行线，都平行于大地，则他们的连线就是地平线（horizon line）</p>
<hr>
<h1 id="1-第一个矩阵Essential本质矩阵"><a href="#1-第一个矩阵Essential本质矩阵" class="headerlink" title="1. 第一个矩阵Essential本质矩阵"></a>1. 第一个矩阵Essential本质矩阵</h1><p>由于拍摄物体时，摄影中并不能被反映在图像中。如果让第二个观察者同时拍摄下某摄影中心和它所拍的照片呢?</p>
<center><img src="http://ooo.0o0.ooo/2016/02/25/56cfbd34f3c9e.png" alt=""></center>

<p>反映在第二个观察者的照片，摄影中心和物体分别投影在像片上，任意第一个摄影中心和它所拍摄物体的连线都可视为第二个摄影中心的极线。直观的理解，即为下图的erpr。</p>
<center><img src="http://ooo.0o0.ooo/2016/02/25/56cfc06a0ddc5.png" alt=""></center>

<p><strong>极线约束的理论就是左侧的物体成像在右侧的同名点一定在erpr上。</strong>反映左右极线关系的就是表达向量和右向量之间的约束关系的——<strong>本质矩阵**</strong>Eseential Matrix<strong>**。</strong>但大多数情况下，别的摄影中心并不一定会被成像，即极点不在相片中。如下图</p>
<center><img src="http://ooo.0o0.ooo/2016/02/25/56cfc2d883aab.png" alt=""></center>

<p>具体的矩阵运算参考<strong>  </strong><a href="http://www.cnblogs.com/gemstone/archive/2011/12/20/2294551.html" target="_blank" rel="external"><strong>计算机视觉基础4——对极几何(Epipolar Geometry)</strong></a> ，原理为三线同面（下图蓝色区域三边）  </p>
<center><img src="http://ooo.0o0.ooo/2016/02/24/56ce77dc874bc.png" alt=""> </center>

<p><strong>其中，E是本质矩阵（Essential Matrix），R是像平面旋转矩阵，T是摄影中心平移矩阵，Pl和Pr分别为左右摄影中心指向同名点P的向量。S由矩阵T决定，具体形式为</strong></p>
<center><img src="http://ooo.0o0.ooo/2016/02/24/56ce77fc78812.png" alt=""></center>

<p><strong>本质矩阵</strong> 采用的是相机的外部参数，也就是说采用相机坐标(The essential matrix uses CAMERA coordinates)，不涉及相机内参数，如果要分析数字图像，则要考虑坐标(u,v)，此时需要用到内部参数(To use image coordinates we must consider the INTRINSIC camera parameters)</p>
<p><strong> 谨记1：Essential Matrix是连结两个摄影中心指向同名点的向量的矩阵，秩为2。</strong></p>
<p><strong> 左向量·E·右向量=0！！！</strong></p>
<p><strong> E由两部分组成！E=R·S  E仅由外方位元素决定！一张图记住E!!!</strong></p>
<p><strong><center><img src="http://ooo.0o0.ooo/2016/02/25/56cfcab0b492e.png" alt=""></center></strong></p>
<p>由向量引申而出的，是同名点的像素坐标，原理是共线方程。</p>
<p><strong>二维同名点</strong></p>
<center><img src="http://ooo.0o0.ooo/2016/02/26/56d00bc787259.png" alt=""></center>

<p>上图中推导出对极几何中相当重要的公式，E矩阵作为连接同名点像素坐标而出现，这就意味着，已知求取E的外方位参数，就能求取出左右同名点的对应关系。然而，其中隐含的条件是在共线方程的化简中，默认忽略了镜头畸变。然而这已足够重要，在镜头畸变在拼接中影响不大时，该公式在仅仅知道外方位元素的情况就能解算corresponding point</p>
<p><strong>极线方程</strong></p>
<p>同理，由于极点、同名点都位于极线上，因此亦可通过E求得极线的方程（采用相机坐标系）。</p>
<p>设极线方程为 au + bv + c = 0</p>
<p>使用齐次坐标，矩阵表示为：</p>
<center><img src="http://ooo.0o0.ooo/2016/02/26/56d01aa83d7d6.png" alt=""></center>

<p>其中，$\widetilde{p}$是像片任意同名点相机坐标，$\widetilde{l}$是方程系数。又依据同名点公式，$$Ep<em>{l} =\widetilde{l</em>{r}}$$，所以！对应外极线的方程系数可以直接由E矩阵和本侧同名点求出。其中，$\widetilde{l_{l}}$是左极点对应外极线方程。</p>
<p>当已知左侧点，其右侧对应点在直线</p>
<center><img src="http://ooo.0o0.ooo/2016/02/26/56d08c864e4a7.png" alt=""></center><br>当已知右侧点，其左侧对应点在极线<br><center><img src="http://ooo.0o0.ooo/2016/02/26/56d01c07d68ed.png" alt=""></center><br><strong>极点</strong><br><br>别忘了。极点也是在极线上，所以有<br><center><img src="http://ooo.0o0.ooo/2016/02/26/56d0673df0710.png" alt=""></center><br>且，极点属于所有极线，因而<br><center><img src="http://ooo.0o0.ooo/2016/02/26/56d0678f1ddfc.png" alt=""></center><br>上式可用来定位极点的坐标<br><br><em> </em> <em><br><br># <strong> 2.第2个矩阵 Fundamental基础矩阵</strong><br><br>另一个需要提到的概念是基础矩阵。<br><br>Essential矩阵使用CameraCoords相机坐标系。尽管其中可计算像素坐标，但仍然以摄影中心为原点，像平面所有点z值都是f。当考虑相机内参数时，这就是FundamentalMatrix基础矩阵<br><center><img src="http://ooo.0o0.ooo/2016/01/22/56a2556c54d1d.png" alt=""></center><br>该图显示了fundamentalmatrix（基础矩阵）的基本内涵。p q分别为同名点。计算基础矩阵需要考虑到内参数的仿射变换。M为内参数的矩阵，包含6个参数的3</em>3矩阵。<br><center><img src="http://ooo.0o0.ooo/2016/02/26/56d069db39519.png" alt=""></center><br>将上式中的Camera坐标提到一边，带入基本矩阵解求对极同名点的方程，即可得到F的表达式.<br><center><img src="http://ooo.0o0.ooo/2016/02/24/56ce7854f3d64.jpg" alt=""></center><br>上式即为基础矩阵方程。其中，F是基础矩阵，x’x分别为同名点。而左右两个平面的两条极线为，显而易见，F由E和两个内参数矩阵决定。<br><center><img src="http://ooo.0o0.ooo/2016/02/26/56d06ae01c63d.png" alt=""></center><br>类似的，F与E一样都能指同名点坐标在对应极线的关系。下图分别是已知左右点其对应极线的关系。<br><center><img src="http://ooo.0o0.ooo/2016/02/24/56ce78b202e41.jpg" alt=""></center><br>一个简单的例子，如果从某种方式计算出基础矩阵，则在对应图中即可表示出像素点对应的极线。<br><center><img src="http://ooo.0o0.ooo/2016/02/28/56d3bee0758a5.png" alt=""></center><br>计算出矩阵即为l的三个参数。一般的，调整比例 将前两项的平方和定为1.<br><center><img src="http://ooo.0o0.ooo/2016/02/28/56d3bf4cbf895.png" alt=""></center>

<p>findfundamentalmat()本意为基础矩阵，是假设两幅图像在同一三维场景中的不同视角。例如立体摄像机，从不同的角度拍摄同一个目标，它解算的是，两幅图像其中一个同名点，与其在外极线同名点的转换关系。它的映射基于三维场景，因此使用这个函数的时候，在不同的视角之间，应该有一个明显的基线。默认使用7点算法拟合数据。基础矩阵把左边图像的一个点的图像坐标与它右边图像中的对应点的图像联系起来，他是一个3x3的退化矩阵，描述了两个立体图像对的外极限几何关系，其计算依赖于在两个图像中相对应的一组点。</p>
<p>与Homography矩阵（下文提到）不同，它在每组对应点有两组约束：x、y同时作为x’y’的自变量，估算一组对应点只有一行的约束，因为极线约束是标量等式。因此至少需要8个点。所以一般使用8点算法计算F矩阵(8点算法)。</p>
<p>$$\begin{bmatrix} x^{‘}_i &amp; y^{‘}<em>i &amp; 1 \end{bmatrix} \begin{bmatrix} f</em>{11} &amp; f<em>{12} &amp; f</em>{13} \\ f<em>{21} &amp; f</em>{22} &amp; f<em>{23} \\  f</em>{31} &amp; f<em>{32}  &amp; f</em>{33}  \end{bmatrix} \begin{bmatrix} x_i \\ y_i \\ 1 \end{bmatrix}=0$$</p>
<p>可推到出方程：</p>
<p>$$ x_i x^{‘}_i {f_11} + x_i y^{‘}_i f_21 + x_i f_31 + y_i x^{‘}_i f_12 + y_i y^{‘}_i f_22 + y_i f_32 + {x_i}^{‘} f_13 + y^{‘}_i f_23 + f_33 =0$$</p>
<center><img src="https://ooo.0o0.ooo/2016/02/29/56d3ed9679e76.png" alt=""></center>

<p>最终目标是找到ATA的一个特征向量使得它的特征值最小。常用的解法是构造m*9的矩阵A（m是点对数），求解A的奇异值分解，即A=UDVT，</p>
<blockquote>
<p>U是m*m正交矩阵，其列为AAT特征向量</p>
<p>V是m*n正交阵，其列为ATA的特征向量</p>
<p>D是m*n对角阵，对角元素为奇异值，平方值为AAT和ATA的特征值。</p>
</blockquote>
<p>然而F是由7个自由度构成的3*3矩阵，其秩为2，因此，讲道理，9个表达式由7个参数构成，因此只用7对对应点理应也能解算出F矩阵（7点算法）。使用此方法计算F矩阵时，需要加上秩为2的限制，以保证计算结果唯一。该方法亦叫做奇异约束。该约束限制假设以F’替代F矩阵，计算时以<a href="https://zh.wikipedia.org/wiki/%E7%9F%A9%E9%99%A3%E7%AF%84%E6%95%B8#.E5.BC.97.E7.BD.97.E8.B4.9D.E5.B0.BC.E4.B9.8C.E6.96.AF.E7.AF.84.E6.95.B0" target="_blank" rel="external">F范式</a>作为标准。</p>
<center><img src="http://ooo.0o0.ooo/2016/03/29/56fb45459399e.png" alt=""></center><br>其中，$\sigma$是M矩阵的奇异值（A*·A的n个特征值的非负平方根叫作A的奇异值），M=F-F’,可以通过SVD分解解出该奇异值。<br><br><center><img src="http://ooo.0o0.ooo/2016/03/29/56fb506cb6765.png" alt=""></center>

<p>F由于秩为2的限制可以以以下形式表示：</p>
<p>F=αF1+(1-α)F2.其中，F1和F2分别Fx=0的两个解。</p>
<p>由于秩=2，因此det(F=αF1+(1-α)F2)=0,通过该式即可求出α的值。</p>
<p>更多内容可以看计算机视觉Trifocal tensor三角点张量的部分。</p>
<p>Caution!</p>
<p>对图像进行匹配的一个重要步骤就是把两幅图像的极线平行于基线，使得极点处在正无穷，这样的拼接结果效果才能更好。这一重要步骤即为重投影。如下图将黑线投影为蓝线。</p>
<center><img src="https://ooo.0o0.ooo/2016/02/29/56d3f1e8a7005.png" alt=""></center>

<p>对图像进行矫正。需要一个单映矩阵，作两步旋转。其第一步是将极点旋转到无穷远，第二部是将极线平行。其中，左右图像均需要应用该单映聚阵R将极点无穷远化；而右图像需要应用旋转矩阵（E=RS中的R）。最后比例一致化。</p>
<p>上文中需要构造的矫正矩阵形式为：</p>
<center><img src="https://ooo.0o0.ooo/2016/02/29/56d3f5a8ace5f.png" alt=""></center>

<p>T是单位矩阵，代表左图的极点，可由E计算。其余的参数：</p>
<center><img src="https://ooo.0o0.ooo/2016/02/29/56d3f66d34abd.png" alt=""></center>

<p>整理一下步骤即为：</p>
<center><img src="http://ooo.0o0.ooo/2016/02/29/56d3f7afcf9ce.png" alt=""></center>

<p>下图即为矫正的例子（两幅图的变化很小，但是从边缘还是可以看到细微的变化），最后把图像的极点都化为无穷远，两幅图基于基线平行。</p>
<center><img src="http://ooo.0o0.ooo/2016/02/29/56d3f7745f920.png" alt=""></center>

<hr>
<h1 id="3-第二个矩阵-Homography（单映）矩阵"><a href="#3-第二个矩阵-Homography（单映）矩阵" class="headerlink" title=" 3. 第二个矩阵 Homography（单映）矩阵"></a><strong> 3. 第二个矩阵 Homography（单映）矩阵</strong></h1><p>findhomography的前提是2D的转换，本意为单映（包含平移、仿射、尺度三种变换），试图找到一个3*3的投影矩阵，能够把1图中所有的点，通过某种形变，匹配到2图中去。当基线很小的时候(视差变化小，扭曲形变也少)，这个方法能够计算出精度极高的解。<br>当然可以首先参考opencv的<a href="http://docs.opencv.org/2.4/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html?highlight=findhomography" target="_blank" rel="external">文档</a> 这里首先介绍二维映射的单映（homography）矩阵</p>
<center><img src="https://ooo.0o0.ooo/2016/01/23/56a3baf462830.png" alt=""></center>

<p>该式反应了像点齐次坐标的单映变换的方程。（u v）(u’ v’)分别是左右图像的同名像点坐标。通过一个8个自由度的矩阵P来解算两者之间的关系。p02 p12与平移相关，p00,p01,p10,p11与旋转 尺度和仿射（平行变换）变换有关，p20,p21与拉伸扭曲有关。</p>
<p>一般的，单映矩阵的计算由以下几个参数构成</p>
<center><img src="https://ooo.0o0.ooo/2016/01/23/56a3bf63f1be0.png" alt=""></center>

<p>其中，K是相机的内矩阵，由焦距决定；R是主光轴朝向，一般由3个方向余弦决定；C是摄影中心的物方位置。当在原地旋转时，C1-C2为0，因此方程可简化为</p>
<center><img src="https://ooo.0o0.ooo/2016/01/23/56a3c1dd3035a.png" alt=""></center>

<p>由相机纯粹旋转而形成的单映，自由度3-5（根据是否已知焦距决定）。</p>
<p>Caution！应该注意到的是，上式中的H3*3矩阵的最后一个元素为1。这里使用到的是计算H矩阵最常用的一种方法，4点算法，即使用4个点即可解算一组H中的8个未知数。在ransac验证外点的过程中，也采用随机4点为一组构建8个方程解算H。</p>
<p>尽管homography是处理二维点集之间的关系，但倘若三维物体中某些点都处于一个平面，即可设该面的z方向值为0，以三维物方xy值作为像素值与所成像片进行homography的变换。</p>
<center><img src="http://ooo.0o0.ooo/2016/02/24/56ce6ba16113c.png" alt=""></center>

<p>上图是几种坐标系之间的关系，Mext是外参数矩阵，包含旋转和平移；Mproj是投影矩阵，主要由焦距决定，原理是共线方程；Maff是内参数仿射变换矩阵，由内参数决定。普通的homography是两幅图像像素坐标间或相片坐标间的变换，但上文提到，当三维物体某些点处于一个平面，亦可在World坐标和Film坐标之间进行homography矩阵变换。</p>
<center><img src="http://ooo.0o0.ooo/2016/02/24/56ce6cd71fc88.png" alt=""></center>

<p>上图可以看到，将三维坐标点z值设为0，[p,q,0,1]即为三维齐次坐标。</p>
<p>$$ \begin{bmatrix} x \\ y \\ 1<br>\end{bmatrix} \sim \begin{bmatrix} f &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; f &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix} \begin{bmatrix} r_11 &amp; r_12 &amp; r_13 &amp; t_x \\ r_21 &amp; r_22 &amp; r_23 &amp; t_y \\ r_31 &amp; r_32&amp; r_33 &amp; t_z \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} p \\ q \\ 0 \\ 1 \end{bmatrix} \sim \begin{bmatrix} fr_11 &amp; fr_12 &amp; ft_x \\ fr_21 &amp; fr_22 &amp; ft_y \\ r_31 &amp; r_32 &amp; t_z \end{bmatrix} \begin{bmatrix} p \\ q \\ 1 \end{bmatrix}<br>$$$$\sim \begin{bmatrix} h_11 &amp; h_12&amp;h_13 \\ h_21 &amp; h_22 &amp; h_23 \\ h_31 &amp; h_32 &amp; h_33 \end{bmatrix} \begin{bmatrix} p \\ q \\ 1 \end{bmatrix}$$<br>最终推到出，3D转2D的投影变换成为2D转2D的变换，该变化可逆！其特例是，当采用的物方坐标系z轴与主光轴平行，即正射影像，则上式R矩阵为</p>
<center><img src="http://ooo.0o0.ooo/2016/02/24/56ce7aab1b305.png" alt=""></center>

<p>则上式变形为：</p>
<center><img src="http://ooo.0o0.ooo/2016/02/24/56ce7b0376427.png" alt=""></center>

<p>该式与相似变换的形式一样，只有4个自由度（tz可化为1），因而正射影像不会产生拉伸形变。（前提是拍摄物体几乎没有深度，几乎处在一个平面）。下图是依照三维中某平面进行拼接，会造成除平面部分其余图像的虚影。</p>
<center><img src="http://ooo.0o0.ooo/2016/02/25/56cf114fc872a.png" alt=""></center>

<center><img src="http://ooo.0o0.ooo/2016/02/25/56cf117891dbb.png" alt=""></center>

<p>上文中一直讨论的是从物方坐标系到像片坐标系的转换，倘若再加上内方位参数的内矩阵，则可直接导出从物方坐标到像素坐标的公式，如下图示意。内方位参数为仿射变换（Affine 6自由度 保持平行结构的变换）</p>
<center><img src="http://ooo.0o0.ooo/2016/02/25/56ceb1181fa03.png" alt=""></center>

<p>将world-&gt;film-&gt;pixel结合起来，对于同一个物体，在某位置某台相机拍摄的照片就可以认为是一个单映H。当然，不同的位置拍摄的像片，各自对应物体的单映是不同的。但由于单映是可逆的，拍摄同一物体的两幅图像，也可以用使用$$H=H<em>{1}H</em>{2}^{-1}$$</p>
<center><img src="http://ooo.0o0.ooo/2016/02/25/56ceb83e89a7b.png" alt=""><img src="http://ooo.0o0.ooo/2016/02/25/56cebcef9abd7.png" alt=""></center>

<hr>
<h1 id="4-Homography（单映）矩阵的求取"><a href="#4-Homography（单映）矩阵的求取" class="headerlink" title=" 4. Homography（单映）矩阵的求取"></a><strong> 4. Homography（单映）矩阵的求取</strong></h1><p>参考<a href="http://www.robots.ox.ac.uk/~vgg/presentations/bmvc97/criminispaper/node3.html" target="_blank" rel="external">这里</a>  只要大于4个匹配点，都认为是冗余测量，必须融合数据。文章里提到了三种解求二维面到面的单应矩阵的球法。</p>
<ul>
<li>非线性的解决办法，使用伪逆进行分解。当所解求值为0时会有bug。</li>
<li>线性最小二乘解法，通常使用SVD分解，V矩阵就对应了最小奇异值。<a href="http://blog.chinaunix.net/uid-20761674-id-4040274.html" target="_blank" rel="external">这个SVD的文章</a>相当好的解释了SVD分解的意义。八个未知数对应八个特征向量，也对应八个线性方程的解。SVD能直接解求出这八个向量，即V中的特征向量。</li>
<li>非线性几何解法，使对应点和映射点差值欧几里得距离（或平方和）最小。</li>
</ul>
<p>Homograhy的计算：计算该矩阵当然不会上式f θ等值直接解算。由于是二维图像之间的关系，一般都已知二维对应点集，直接采用最小二乘的方式使用LM进行计算。在一般情况下的H矩阵可表示为</p>
<p>$$ \begin{bmatrix} x^{‘} \\ y^{‘} \\ 1 \end{bmatrix} \sim \begin{bmatrix} h_11 &amp; h_12 &amp; h_13 \\ h_21 &amp; h_22 &amp; h_23 \\ h_31 &amp; h_32 &amp; h_33 \end{bmatrix} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}$$</p>
<p>其中，$h_31 h_32 h_33$是为了配置相似比例，化简为</p>
<p>$$x^{‘}=\frac{h_11 x + h_12 y + h_13 }{ h_31 x + h_32 y + h_33 }$$</p>
<p>$$y^{‘}=\frac{h_21 \cdot x + h_22 y + h_23 }{ h_31 x + h_32 y + h_33 }$$</p>
<p>但可以看到，h所有元素同乘k 等式依旧成立。因而强制设为8自由度有两种方式，</p>
<p>①$$ h_{33} = 1 $$</p>
<p>②$ h<em>{11}\^{2} + h</em>{12}\^{2} = 1 $<br>采用第一种方式较为常见。<br>当采用最小二乘解求H矩阵时，一般先用Ransac筛选最大集，然后利用下方程。</p>
<center><img src="http://ooo.0o0.ooo/2016/02/25/56cf041a7c664.png" alt=""></center>

<p>以x y x’y’为A b矩阵参数，迭代解求H。由于是线性方程，因而可以直接使用$$h=(A^{T}A)^{-1}(A^{T}b)$$求取每次的残差。</p>
<center><img src="http://ooo.0o0.ooo/2016/02/25/56cf051be79bc.png" alt=""></center>

<p>&lt;font color=”#ff0000”&gt;Caution！应该注意到的是，该方法对噪声极其敏感，即使没有外点（outliers）,因而，在计算前对数据里筛选就非常重要。为更好的得到结果，Ransac时可以将该组数据质心重置到原点；然后缩放比例使得各点到原点的平均距离是根号二。如下图，H的表达式。T、S分别为平移和缩放的矩阵。</p>
<center><img src="http://ooo.0o0.ooo/2016/02/25/56cf08c613352.png" alt=""></center>

<p>如何判断这两幅图像确实匹配呢？记该区域的特征点总数为nf，而符合H的特征点（内点）数量为nj，如果两者比例足够大，说明两幅图像确实匹配。但一般拼接时都确认两幅图像有重叠面积才计算H。变换模型H计算时的误差可表述为Huber模型：</p>
<center><img src="http://ooo.0o0.ooo/2016/02/25/56cf0b53675d9.png" alt=""></center>

<p>同时，由于矩阵具有可逆性，因此图像12之间的H1和图像23之间的H2可以直接推导出图像13之间的H3。但大量的单映队列并不推荐，这样会造成误差成倍扩大。</p>
<center><img src="http://ooo.0o0.ooo/2016/02/25/56cf0eb50a41b.png" alt=""></center>

<p><strong> 谨记二 </strong>：homography处理的是纯粹的二维与二维之间的变换。即便特例是3D也是视为在2D的单映和相似变换。在旋转相机和正射拼接可以得到良好的二维拼接效果，在具有深度的三维物体，拼接会造成虚影！</p>
<hr>
<p>这两个函数都是基于特征点的变换模型求解，既然特征点已找出且筛查得到更正确的点，因此对图像外观的变化具有鲁棒性（尺度、光照、旋转等）。选择哪种函数基于图像间的关系，即立体场的观测使用fundamentalmatrix（视角矫正 三维全景 街景视角）,而相对平面化的则使用findhomography（全景拼接  航摄图像拼接 ）</p>
<p>解求这个变换模型一般基于线性最小二乘的方式，与平差原理类似，利用冗余的数据（大量同名点）来解算参数。一般的，先通过Ransac筛查数据比较靠谱。</p>
<h1 id="谨记三："><a href="#谨记三：" class="headerlink" title="** 谨记三："></a>** 谨记三：</h1><p>homography 单映处理二维坐标系与二维坐标系关系，特例情况下是三维物体某平面可视为二维平面。更特例的是正射影像（相似变换）和旋转摄影全景拼接（C1-C2=0）（处理对应点集与点集的关系）矩阵可逆，具有结合性。</p>
<p>fundamental针对的是点和极线的关系（处理点集与极线集的关系），可用来在寻找匹配点的时候快速查找对应点。（以像素为坐标系）</p>
<p>essential 本质是连结同名点向量的矩阵（以像空系为标准）</p>
<p>参考。</p>
<p><a href="http://blog.csdn.net/u010141025/article/details/16920567" target="_blank" rel="external">【opencv】特征点检测方法–GFTT，SIFT，FAST，SURF</a> </p>
<p><a href="http://www.cse.psu.edu/~rtc12/CSE486/" title="http://www.cse.psu.edu/~rtc12/CSE486/" target="_blank" rel="external">http://www.cse.psu.edu/~rtc12/CSE486/</a> 宾州州立大学计算机视觉</p>
<p><a href="http://opencv-users.1802565.n2.nabble.com/Difference-between-homography-and-fundamental-matrix-td6359087.html" title="http://opencv-users.1802565.n2.nabble.com/Difference-between-homography-and-fundamental-matrix-td6359087.html" target="_blank" rel="external">http://opencv-users.1802565.n2.nabble.com/Difference-between-homography-and-fundamental-matrix-td6359087.html</a> homography and fundamental matrix的讨论</p>
<p><a href="http://homepages.inf.ed.ac.uk/rbf/CVonline/" title="http://homepages.inf.ed.ac.uk/rbf/CVonline/" target="_blank" rel="external">http://homepages.inf.ed.ac.uk/rbf/CVonline/</a> 爱丁堡大学计算机视觉在线课件</p>
<p><a href="https://www.robots.ox.ac.uk/~vgg/hzbook/hzbook2/HZepipolar.pdf" title="https://www.robots.ox.ac.uk/~vgg/hzbook/hzbook2/HZepipolar.pdf" target="_blank" rel="external">https://www.robots.ox.ac.uk/~vgg/hzbook/hzbook2/HZepipolar.pdf</a> 牛津大学计算机视觉中的多视几何</p>
<p><a href="http://120.52.72.36/www.umiacs.umd.edu/c3pr90ntcsf0/~ramani/cmsc828d/lecture27.pdf" title="http://120.52.72.36/www.umiacs.umd.edu/c3pr90ntcsf0/~ramani/cmsc828d/lecture27.pdf" target="_blank" rel="external">http://120.52.72.36/www.umiacs.umd.edu/c3pr90ntcsf0/~ramani/cmsc828d/lecture27.pdf</a></p>
<p>马里兰大学高级计算机研究</p>
<p><a href="http://www.cnblogs.com/gemstone/articles/2294551.html" title="http://www.cnblogs.com/gemstone/articles/2294551.html" target="_blank" rel="external">http://www.cnblogs.com/gemstone/articles/2294551.html</a></p>
<p><a href="http://imagine.enpc.fr/~monasse/Stereo/4Fundamental.pdf" title="http://imagine.enpc.fr/~monasse/Stereo/4Fundamental.pdf" target="_blank" rel="external">http://imagine.enpc.fr/~monasse/Stereo/4Fundamental.pdf</a> 法国国立桥梁与公路学校Ecole Nationale des Ponts et Chaesses计算机视觉和图像</p>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/18/社交app的2015/" itemprop="url">
                  社交app的2015
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-01-18T11:45:06+08:00" content="2016-01-18">
              2016-01-18
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/槽/" itemprop="url" rel="index">
                    <span itemprop="name">槽</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/18/社交app的2015/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/18/社交app的2015/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>手机和网络重度使用患者也该是总结自己的时候了。庆幸的是各大app都热推了自己的2015数据流。把去年的数据库做个直白的excel统计。好吧。。我除了听歌看电影买买买也没别的(性)生活了。</p>
<p><img src="http://ooo.0o0.ooo/2016/01/17/569b74dab78e7.png" alt=""></p>
<p>进入微信还算比较早的。和我的两个基友都是300w内。但是潜水了快3年才在快毕业的时候旅行发了一条盆友圈。曾一度抗拒盆友圈这个类似空间的东西。当然大学的社交网络还是集中在“找人人上同学”的人人网。。毕竟各大校园通知新闻、文娱八卦、技术贴以及各种曾在校园见过又不知道是谁的人终于知道叫什么名字了。。还曾一度影响了各类插件的发展、影响了谁来看过我我被多少人看过的各类访问人数的截图。。现在看来。。大家当年都是一个水平的嘛</p>
<p><img src="http://ooo.0o0.ooo/2016/01/17/569b765a8c8ed.png" alt=""></p>
<p>快一年也没旅游了。说是没时间不如说是没人陪。。只有寒假去东三省和海南度假算是正经的轻松了一回。不过上海的cj也是满满的收获。。红包多是借钱还钱。。。才没有人给我发红包呢。</p>
<p><img src="http://ooo.0o0.ooo/2016/01/17/569b76c34f72d.png" alt=""></p>
<p>惨淡的人际网并不像急于拓展。收货了太多的信息来源反倒不如维护好几个重要的人。。还未曾到需要攀龙附凤的阶段。充实自己吧。用了一段时间的手环终究是没有逃过不出一年就坏掉的命运。。所以微信运动总是几百米的步数。</p>
<p><img src="http://ooo.0o0.ooo/2016/01/17/569b8cd37fbf6.png" alt=""></p>
<p>其实点口碑外卖并不多。。不知道它计算了别的外卖支付没有。。。想想也就吃了下半年则么会这么多。。或许是把优惠支付也算进去了。</p>
<p><img src="http://ooo.0o0.ooo/2016/01/17/569b8d469df74.png" alt=""></p>
<p>除了一个月试了试微信的信用卡还款基本都在支付宝还款了。。后面几个月已经扒不到网易邮箱的信用卡账单了。。每次都要手动输金额也是好烦。。生产力还没达到一定程度消费就花了这么多了。。手机充值的方式越来越多样化。总之和外卖 电影一样 谁便宜去谁家。</p>
<p><img src="http://ooo.0o0.ooo/2016/01/17/569b8dfc35999.png" alt=""></p>
<p>大部分能用华北的地方都没主动用。。第一推荐的基本没人会主动换掉。。港真。芝麻信用分还是挺有用的。</p>
<p><img src="http://ooo.0o0.ooo/2016/01/17/569b92b0b7ced.png" alt=""></p>
<p>常年有1w余额。。这年利率越来越低了</p>
<p><img src="http://ooo.0o0.ooo/2016/01/17/569b9351c9783.png" alt=""></p>
<p>大多数买买买都是电子产品。。两个手机。两个耳机。。单反。。品质的一年。旅游真的变少了。</p>
<p><img src="http://ooo.0o0.ooo/2016/01/17/569b99e34fd85.png" alt=""></p>
<p>比格这么高的音乐软件入碗了入碗了！！毕竟还是个网易最早用户呢</p>
<p><img src="http://ooo.0o0.ooo/2016/01/17/569b9a1dc8bf6.png" alt=""></p>
<p>上班听歌狗。。。没歌没效率的最佳代言人。</p>
<p><img src="http://ooo.0o0.ooo/2016/01/17/569b9a48e60dc.png" alt=""></p>
<p>真是李荣浩狗。。陈粒狗。。李志狗。。还是国语歌听的比较顺耳</p>
<p><img src="http://ooo.0o0.ooo/2016/01/17/569b9a7cebaa4.png" alt=""></p>
<p>喂喂喂！！要你管啦！</p>
<p><img src="http://ooo.0o0.ooo/2016/01/17/569b9a99a92ea.png" alt=""></p>
<p>是的！都怪你拉！</p>
<p>&nbsp;</p>
<p><img src="https://ooo.0o0.ooo/2016/01/17/569c588aa63d8.png" alt=""></p>
<p>也是由于从村里搬到了城里。本以为8.8的电影算是捡了大便宜。妹想到4块钱看了个星战。闲来无事，也只能有看电影能消遣了。</p>
<p><img src="http://ooo.0o0.ooo/2016/01/17/569c5ae2d384a.png" alt=""></p>
<p>也是被自己的频率吓到。。毕竟前半个年基本没有机会看到电影院。。。或许是回忆标记的电影略多。</p>
<p><img src="https://ooo.0o0.ooo/2016/01/17/569c587a5e523.png" alt=""></p>
<p>电影院基本四星以下。唯独记得的几部看的相当爽的只有【师傅】【暗杀】【心迷宫】其他的五星基本在补电影。</p>
<p><img src="https://ooo.0o0.ooo/2016/01/17/569c58890e21e.png" alt=""></p>
<p>毕竟是互联网社交的先驱。极客的事业之道</p>
<p><img src="https://ooo.0o0.ooo/2016/01/17/569c588ab1ec6.png" alt=""></p>
<p>港真。自尊心在受到歧视的人群更显得珍重。民族歧视、种族歧视、地域歧视，如果解决不好，就不是花钱能够应付的了</p>
<p><img src="https://ooo.0o0.ooo/2016/01/17/569c588c1f10b.png" alt=""></p>
<p>第一次对动画电影这么赞叹，不愧是日本的高分动画。不愧是宫崎骏老师的配乐</p>
<p><img src="https://ooo.0o0.ooo/2016/01/17/569c5897d8f92.png" alt=""></p>
<p>好吧。。容我矫情一回好了</p>
<p><img src="https://ooo.0o0.ooo/2016/01/17/569c588d50b2d.png" alt=""></p>
<p>也不知道寒假怎么了。应该是约约约才对的阿。三月四月完全没有流量下电影。。也无心恋战。沉迷健身、跑步、羽毛球、课设、、、</p>
<p><img src="http://ooo.0o0.ooo/2016/01/17/569c5c4cdd158.png" alt=""></p>
<p>豆瓣电影和豆瓣app相当混淆。。不知道应该取舍哪一个</p>
<p><img src="http://ooo.0o0.ooo/2016/01/17/569c5c7918c03.png" alt=""></p>
<pre><code>       &amp;lt;p&amp;gt;果然是2月挖坟了过往的很多电影。。毕竟也是太闲了这样算下来和前一年看的就差不多了&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;&amp;lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569c5cba269c4.png&quot;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;&amp;lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569c5cf85db53.png&quot;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;虽然口味较重。但类型没有特别偏颇的。反倒是对美帝的电影相当喜爱。&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;&amp;lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569c5d1f44a7d.png&quot;&amp;gt;&amp;lt;/p&amp;gt;    &amp;lt;p&amp;gt;虽然很爱大咪咪。但演的渣还是不能同情的。。虽然艾玛斯通对你国态度相当恶劣。但演得好还是要乖乖献出5分。&amp;lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569c5d7f7dbe0.png&quot;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;第一部是欠的电影票。。第二部是第一次看到了电影院娇嗔的妹子。。第三部是18.8看了个imax。。我是奇葩恩恩我承认好了&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;&amp;lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569c5dc6997cf.png&quot;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;港真。。特工学院这剧情和特效能看？还有那操蛋的英伦腔。
</code></pre>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/04/[汇总][2015.1.3]电脑端与Android iOS传输文件/" itemprop="url">
                  [汇总]pc Android iOS传输文件
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-01-04T00:35:49+08:00" content="2016-01-04">
              2016-01-04
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/软件测评/" itemprop="url" rel="index">
                    <span itemprop="name">软件测评</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/软件测评/软文/" itemprop="url" rel="index">
                    <span itemprop="name">软文</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/04/[汇总][2015.1.3]电脑端与Android iOS传输文件/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/04/[汇总][2015.1.3]电脑端与Android iOS传输文件/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>曾写过一个这个<a href="http://www.dooby.me/?p=473" target="_blank" rel="external">http://www.dooby.me/?p=473</a></p>
<p>然而时过境迁很多出彩的软件已经出来了。。本篇主要提<font color="#FF0000">多客户端的文件无线传输</font>，忽略笔记类和书签类。</p>
<p>1.Airdroid3.1.6 <a href="http://coolapk.com/apk/com.sand.airdroid" target="_blank" rel="external">http://coolapk.com/apk/com.sand.airdroid</a></p>
<p><img src="http://ww1.sinaimg.cn/large/68eb7c93jw1ezmt5t987jj20u01hcn0w.jpg" alt=""><img src="http://ww3.sinaimg.cn/large/68eb7c93jw1ezmt66mv43j20u01hctby.jpg" alt=""><img src="http://ww3.sinaimg.cn/large/68eb7c93jw1ezmt76fl5dj20u01hc77z.jpg" alt=""><img src="http://ww3.sinaimg.cn/large/68eb7c93jw1ezmt7qh365j20u01hctc6.jpg" alt=""></p>
<p>tips：只能在安卓与电脑、安卓之间传输，需要注册登录账号</p>
<p><img src="http://ww3.sinaimg.cn/large/68eb7c93jw1ezms9x6npaj20f403s0th.jpg" alt=""></p>
<p>鹅妹子赢：除了强大的win客户端（网页端）无线文件（夹）传输外，还有照片音频视频管理、手机通知<font color="#FF0000">桌面提示（低头党福音）</font>、通讯录短信管理、截屏、<font color="#FF0000">apk卸载及下载</font>，收发短信！电话接打！<font color="#FF0000">寻找手机</font>！！（黑科技啊）。连接过的设备支持<font color="#FF0000">直接唤醒连接</font>（只要都在联网状态下，无论同wifi、异wifi甚至是移动数据网络）。还支持<font color="#FF0000">桌面鼠标直接操控手机</font>的airmirror！！简洁干净，效果拔群，关键<font color="#FF0000">美美美</font>！！！</p>
<p><img src="http://ww1.sinaimg.cn/large/68eb7c93gw1ezom8kr3ksj21he0q2q8x.jpg" alt=""></p>
<p>web平台远程唤醒</p>
<p><img src="http://ww2.sinaimg.cn/large/68eb7c93gw1ezomaz9flsj21h90qrgw9.jpg" alt=""></p>
<p>web平台主界面。</p>
<p><img src="http://ww4.sinaimg.cn/large/68eb7c93gw1ezomc357sjj21h10qt1d1.jpg" alt=""></p>
<p>bug级别的手机查找</p>
<p><img src="http://ww3.sinaimg.cn/large/68eb7c93gw1ezoniqrfh4j20x90o1jw0.jpg" alt=""></p>
<p>Airmirror直接用鼠标代替手势</p>
<p><img src="http://ww3.sinaimg.cn/large/68eb7c93gw1ezonwxogcxj20ci03yt8x.jpg" alt=""></p>
<p>同样是bug级别的桌面通知提示。还可直接回复短信</p>
<p>网络条件：</p>
<p>电脑可在win客户端或web网页操作 手机需安装客户端。（win↔Android；Android↔Android）</p>
<p>近距离传输 可在同wlan网络下，或手机自建热点，或无网络状况通过USB管理手机连接，通过FTP+端口的形式传输；远距离直接通过账号共享传输</p>
<p>文件格式：Android客户端可发送筛选过的有图片、直接拍照、视频、音频、已接受文件及所有SD卡下内容；Win下可直接拖动文件夹（需premium）、任意文件发送</p>
<p><font color="#FF0000">注：</font>Android间不可互传apk，分享出去是play的链接。只能在win下载apk</p>
<p>测速：</p>
<p>1G的视频 web端&nbsp; 在2G的wifi下达到3MB/s 用时 5分13秒。</p>
<p><img src="http://ww1.sinaimg.cn/large/68eb7c93jw1ezmszm05i9j20lz047gmo.jpg" alt=""></p>
<p>&nbsp;</p>
<p>2.快牙3.6（国际版）<a href="http://coolapk.com/apk/com.dewmobile.kuaiya.play" target="_blank" rel="external">http://coolapk.com/apk/com.dewmobile.kuaiya.play</a></p>
<p>tips:强大的三平台互传 起家早 然后堕落了 加入一堆没用的游戏和功能</p>
<p>饿妹子赢：支持wifi 热点 蓝牙各种乱七八糟的方式。能互传apk！能无账号扫码传输！</p>
<p>&nbsp;</p>
<p>3.Xender</p>
<p>4.茄子助手</p>
<p>5.微信&amp;qq手机助手</p>
<p>6.百度云</p>
<p>7.闪传</p>
<p>8.SuperBeam</p>
<p>9.极助手</p>
<div class="PoweredByWebStory" style="margin-top:15px;margin-bottom:10px"><a href="http://sns.juziyue.com/webinvite.php?u=94887" target="_blank" rel="external"></a>&nbsp;今天你<a href="http://sns.juziyue.com/webinvite.php?u=94887" target="_blank" rel="external">菊子曰</a>了么？</div>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/01/Android为毛耗电[2]/" itemprop="url">
                  Android为毛耗电[2]
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-01-01T23:32:08+08:00" content="2016-01-01">
              2016-01-01
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/App强推/" itemprop="url" rel="index">
                    <span itemprop="name">App强推</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/App强推/软文/" itemprop="url" rel="index">
                    <span itemprop="name">软文</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/01/Android为毛耗电[2]/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/01/Android为毛耗电[2]/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong><font size="4" face="华文中宋">本文只讨论安卓手机软节电，不负责推荐底包、rom、调频调压方案，刷机root<font color="#ff0000">后果自负</font>。</font></strong></p>
<font size="4" face="华文中宋">本小节只讨论干货。在root及xposed框架下。同时兼顾不能肉身翻墙又想用google服务的小狗们。本人的使用情况是正常功能照开，google需要gmail和google photo及部分gcm，黑屏开启手势和解锁，正常收微信、闹钟、短信电话外熄屏一切不开，后台常开应用有snap锁屏、grenntify绿色守护、调音的audio mix、天气插件、BBS、输入法、Nova Launcher。测试的环境为Android L 5.1.1</font>

<font size="4" face="华文中宋">&nbsp;<br><br><em> </em> *<br><br><font color="#ff0000">App干货推荐</font></font>

<p>&nbsp;<a href="http://coolapk.com/apk/com.oasisfeng.greenify" target="_blank" rel="external">http://coolapk.com/apk/com.oasisfeng.greenify</a> 绿色守护（评论好多捐赠包）国内优秀开发者–唤醒对其 深度休眠hibernateservice </p>
<p><a href="http://coolapk.com/apk/com.asksven.betterbatterystats" target="_blank" rel="external">http://coolapk.com/apk/com.asksven.betterbatterystats</a>BetterBatteryStats（捐赠包只多了小插件和知识库） 国外应用（使用稳定后可删，留着也不费电）–查看耗电最多的程序 资源 频率占比 <a href="http://coolapk.com/apk/com.uzumapps.wakelockdetector" target="_blank" rel="external">http://coolapk.com/apk/com.uzumapps.wakelockdetector</a> wakelock detector（使用后可删，被注册为系统程序，留着不太费电）–查看被CPU 屏幕 时钟唤醒的程序以便将其控制 可以便利的<font color="#ff0000">结合绿色守护使用</font></p>
<p><a href="http://coolapk.com/apk/ccc71.at" target="_blank" rel="external">http://coolapk.com/apk/ccc71.at</a> 安卓调谐器:3C Toolbox（Android Tuner）–系统调节<font color="#ff0000">神器</font> 控制自启 控制软件权限 自大组件控制 cpu调节 自动内存调节</p>
<p>一张图解释大部分唤醒、杀进程软件的思路</p>
<p><img src="http://ww2.sinaimg.cn/large/68eb7c93gw1ezs65djw3nj20tx0pn0xp.jpg" alt=""></p>
<p>————————喂下面几个是一类 看清楚需求———————————</p>
<p><a href="http://coolapk.com/apk/com.linangran.nowakelock" target="_blank" rel="external">http://coolapk.com/apk/com.linangran.nowakelock</a> 禁止唤醒1.2.1 （国内开发者）–只能禁5个 暂未发现捐献包 主程序调用捐助包需要与play验证。但也不贵才十几块。 但是禁止效果良好 百度 阿里 系的随便禁一两个就发现效果超级棒 就是挺贵 </p>
<p><a href="http://coolapk.com/apk/me.piebridge.forcestopgb" target="_blank" rel="external">http://coolapk.com/apk/me.piebridge.forcestopgb</a> 阻止运行 国内开发者，免费!–阻止后台、前台、服务及可见的各种组件 不限数目 限制谷歌服务效果良好 </p>
<p><a href="http://coolapk.com/apk/com.ryansteckler.nlpunbounce" target="_blank" rel="external">http://coolapk.com/apk/com.ryansteckler.nlpunbounce</a> 唤醒控制amplify3.3.4–可以查看唤醒次数&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;</p>
<hr>
<font color="#ff0000">电量消耗结构总结</font>

<p>对于电量，总有一些是必然会消耗的，一些是可以减少的，而一些是可以避免的。那么，对于不同状态下那些成分占的比例会占比略高呢？</p>
<p>1.正常使用状态下（Screen on）：无容置疑的是屏幕的发亮，因而合适的调低亮度能更大的省电，尤其是主动发光的amoled使用深色主题会更省电。当然，大部分使用状态，需要更多的网络连接，4G&gt;3G&gt;2G&gt;wifi是显而易见的。同时使用不同类型的App也会让CPU频率相应的上升，尤其是大型3D网游和功放影音体验。</p>
<p>正常开机使用，耗电排行一般为：</p>
<ul>
<li>屏幕发亮  </li><li>高CPU占用的App ，包括某些情况下刷帖、浏览网页等长时间交互行为  </li><li>手机通信（联网、移动通话、视频通话）  </li><li>Android系统  </li><li>手机待机 ，即Android OS 之类</li>
</ul>
<p>2.正常待机状态下（Screen off）包括唤醒和睡眠、深睡眠。当然，大部分人都希望手机进入Idle正常无唤醒的状态，达到hibernate。但国产App可不会这么干。对于待机来说两大耗电来源就是alarm计时器唤醒各类监听进行后台操作、偷跑流量、不必要的消息推送；wakelock把持唤醒锁让手机无法进入深睡眠从而维持后台服务。</p>
<p>正常待机状况下，不飞行，不关闭数据网络，关闭GPS、wifi、蓝牙等，耗电排行是：</p>
<ul>
<li>手机通信 Cell Standy之类。这一块比较大，依赖数据网络的制式  </li><li>Android OS（即BBS的Kernel wakelock或partial wakelock标记为Android的）  </li><li>手机待机 （PowerManagerService 及Device Idle之类的）处理休眠状态下设备监听及唤醒锁的管理</li>
</ul>
<p>&nbsp;</p>
<hr>
<p>开启wld和bbs的实时监控，把该装的常用软件装上<font color="#ff0000">先用着那么一段时间。</font></p>
<p>1.</p>
<p>①利用这段时间 把权限都给干了 装软件给你显示了一list的权限然并卵 不同意没法装 装了也没几个需要的&nbsp; 在【应用程序权限】的设置框中把权限悉心的扫个遍 曾经启用过的权限会有提示何时使用过 例如我把美团外卖的权限全禁了 然而还是可以正常使用</p>
<p>目标是：给app只留必要的权限 像读取短信直接get验证码那些权限就不必了，重点关注权限里的【<font color="#ff0000">保持唤醒</font>】。这个权限意味着能在熄屏时候对手机进行唤醒操作，在亮屏时能够保证数据一致性。没有必要进行推送和同步的应用就应该关闭。</p>
<p>②利用小汽车autostat或者3c toolbox自带的自启动控制器 控制不需要自行启动的项目 除了launcher greentify 3c tool box类似物 等系统框架 其余全都不需要 不需要不需要</p>
<p>目标是：启动速度棒 未启动的应用不会推送任何消息 （微信 微博 GMail等可以排除）</p>
<p>③给app一点微弱的信任，试着在app的设置中，关掉消息推送、wifi下自动更新、wifi下同步等设置，稍微有点技术含量的程序猿都会在设置取消时cut掉后台进程。</p>
<p>④对于各种传感器，依据需求关闭能很好的节约电量（这一块和rom的优化很大关系）例如黑屏手势、人脸解锁、黑屏解锁、口袋检测等。</p>
<p>⑤利用系统的电量统计和后台开启程序大致了解本机运行的大消耗后台。例如本机待机时系统消耗的比例想当高。同时保持着很高的唤醒状态。。</p>
<p><strong><font color="#ff0000">系统的电量统计</font></strong></p>
<p><img src="http://ww2.sinaimg.cn/large/68eb7c93gw1ezrv30mvwcj20u01hc435.jpg" alt=""><img src="http://ww1.sinaimg.cn/large/68eb7c93gw1ezrv0fux6ej20u01hc0x7.jpg" alt=""></p>
<p>点开正在运行的后台，可以看本机Android系统和Android操作系统电量消耗高的原因是高通CPU的定位服务。经过调校后的曲线，可以看到中度使用后，待机超过了一个天。同时待机时休眠比例也超过了8成。</p>
<p><img src="http://ooo.0o0.ooo/2016/01/10/5693136395d1a.png" alt=""><img src="http://ooo.0o0.ooo/2016/01/10/569313c0b6950.png" alt=""></p>
<p>2.使用过后 开启betterbatterystats和wakelock detector</p>
<p>D1 2016/1/6</p>
<p>①<font color="#ff0000"><strong>betterbatterystats BBS</strong></font>查看耗电大户 一般来说googleservice由于不能随时翻 会造成gmail keep backup contacts 都会发送心跳包不停的连接 此外 除了显而易见的三大流氓滥用唤醒锁 相互唤醒 外 还有奇形怪状的耗电大户 如location定位 微信 </p>
<p>官方帮助指南：<a href="http://better.asksven.org/bbs-how-to/" target="_blank" rel="external">http://better.asksven.org/bbs-how-to/</a></p>
<p>应用beta版及正式版更新日志 <a href="http://forum.xda-developers.com/showthread.php?t=1179809" title="http://forum.xda-developers.com/showthread.php?t=1179809" target="_blank" rel="external">http://forum.xda-developers.com/showthread.php?t=1179809</a>&nbsp; 包含apk下载。捐助包多了知识库和小控件。</p>
<p>它承诺不在后台记录电量，只在开机、断开充电器、插上充电器、亮屏、熄屏。custom是自定义的操作记录，current是当前时间截止的电量消耗的样本。它提供了后台电量实时监控，这会消耗一定的电量；同时提供了进程监控，并对唤醒次数超过阈值的进行提示。<font color="#ff0000">右侧的圈圈一律代表该应用、该服务、该定时器在所选时间段的使用时间比例</font></p>
<p>Entries：</p>
<p><img src="http://ww4.sinaimg.cn/large/68eb7c93gw1ezp07m935cj20u012saci.jpg" alt=""></p>
<p>&nbsp;</p>
<font color="#ff0000">other</font>——睡眠、唤醒、亮屏等其他重要时间节点的电量消耗数据【深睡眠、熄屏唤醒、亮屏、通话时间、wifi开启时长、wifi连上时长、蓝牙开启时长】<br><br><em>   一般选择unplugged-current 即断电后到现在 一般熄屏情况下 要么deep sleep要么awake，所以两者相加应该是100%。  <li>（Awake）Screen off显示了熄屏时被唤醒所占比例 可以很直观的感受手机离开操作后后台运作的程度 最优的情况当然是0%，手机处于最节能的状态（之前的版本将awake&amp;screen off分开计时 需要两个数据一起对比）  </li><li>此外，还有wifi 启动、wifi运行与唤醒的关系，很明显，在晚上断开wifi会给手机更好的进入休眠<br><br><font color="#ff0000">kernel wakelocks</font>——使手机唤醒的内核操作【大量的短暂唤醒会严重影响唤醒时间导致手机消耗更多的时间返回睡眠】

</li></em>   重点关注项目-PowerManagerService wakelock和multipdp、svnet-dormancy wakelock。前者是激活大部分app的唤醒锁服务，如果它占第一位，则取partial wakelocks关注唤醒时间较多的项目；后者是网络使用量，若存在后台偷跑流量的软件，可以很明显的发现异常，到network数据栏中看一下。  <li>kernel wakelock中的alarm是所有定时器的总和 基本不耗电 但如有异常 可到alarms或amplify中查看详细的计时器项目。  </li><li><em>sync</em> <em>backup</em> <em>job</em>很明显是系统的操作 同步 备份 消息推送 如果不需要就禁了吧<br><br><font color="#ff0000">partial wakelocks</font>——是大部分app把持的唤醒锁。（PowerManagerService高的可以关注这项）<br><br><em>   根据使用频率来限制大耗电partial wakelock 如ig tw fb wb wx等。可以在后文自行设置后台计时器时间。  <li>卸载/冻结/不可用 这些做法有些极端 但实在忍无何忍下还是放弃这个app吧。钛备份下的冻结就比较好用 对google系的后文提到。  </li><li>主动手动开关GPS。使用时才打开。  </li><li>根据需要使用后退键退出还是home键退出  </li><li>wifi是个奇葩 晚上记得关（If you don’t need Wifi turn it off: in some cases Wifi is known to cause wakeups and an overhead in e.g. location services）  </li><li>一次不要改太多，一次一次改 能对手机每个app和每个设置有直观的体验和感受<br><br><font color="#ff0000">alarms</font>——由于应用及服务的定时器唤醒手机【apps设定的触发器在某个时间节点唤醒手机，某些alarms只在唤醒时执行、另一些则直接唤醒手机。通常一个alarm绑定一个intent】

</li></em>   长时间和过高次数的alarm都是不正常的。一定要及时纠出。例如微信这狗。  </li><li>更多的alarm应该在手机亮屏时启动 除了闹钟、微信等必要的消息之外 如知乎提醒、百度外卖提醒等应用，按照使用习惯，更应该是熄屏时完全关闭计时器。<br><br><font color="#ff0000">network</font>——app的网络使用率【区分3G和wifi的网络连接数据】<br><br><em>   相当多的工具都能查看网络传输的状态。系统自带的也不错。  <li>信号较弱的wifi或窝蜂数据会频繁的连接并唤醒手机<br><br><font color="#ff0000">CPU states</font>——不同CPU频率所占用的时间【包括深度睡眠时的CPU频率占用时间】<br><br><font color="#ff0000">Processes</font>——用户及系统进程消耗的CPU时间【进程CPU消耗，分为用户及系统，以不同颜色标识】<br><br>进阶功能：<br><br>【<font color="#ff0000">Watchdog</font>】——熄屏分析功能，可自定义亮屏、解锁等。对唤醒超过阈值的app和service进行提示，可在熄屏后一定时间对watchdog关闭。<br><br>【<font color="#ff0000">Active Monitoring</font>】——后台运行的一定时间间隔的数据采集，可能会造成额外耗电。<br><br>观察一下本机的耗电比例，首先看到other中，Awake(Screen Off)的比例相当高，在其他人的截图是有deep sleep的！！！我安的软件已经炸裂了。尽管开启了wifi会消耗更多的电量，但大量的唤醒让手机不能正常进入休眠。<br><br><img src="http://ww1.sinaimg.cn/large/68eb7c93gw1ezrv6kd1wgj20u01hcaep.jpg" alt=""><br><br>再观察partial wakelock ，除了gmail可能不顺利的同步导致消耗略多外，其余app都还算正常的耗电（注意关注连接时间，最多的也才3m35s，这在8h14m11s里来说是相当小的比例，同时消耗的电量也只有0.7%，还可以接受。当然是提前锁过了一部分app的后台）<br><br><img src="http://ww3.sinaimg.cn/large/68eb7c93gw1ezrv97d35sj20u01hc7ci.jpg" alt=""><br><br>注意力关注到kernel wakelock，可以看到，核心的耗电量还是比较大的（由于之前的耗电太过大已经关闭了锁屏手势和黑屏解锁）。可以明显的看到，wlan联网在熄屏时间一直连接，qpnp_fg_memaccess qpnp_fg_update_temp qpnp_fg_update_sram是内核的操作。和rom有关。<img src="http://ww3.sinaimg.cn/large/68eb7c93gw1ezrvef5tykj20u01hctff.jpg" alt=""><br><br>最后发现。。其实是rom的锅。我的other居然没有出现deep sleep。这是相当可怕的事情。经过调优和整理唤醒后，得到如下相当爽快的数据。接近70%的深睡眠还可以让人接受。毕竟还开启了微信。微博。邮件的消息推送。<br><br><img src="http://ww4.sinaimg.cn/large/006fVPCvjw1ezvcpamb0bj30u01hcgrd.jpg" alt=""><br><br><img src="http://ww3.sinaimg.cn/large/006fVPCvjw1ezvconkjs5j30u01hctfb.jpg" alt=""><img src="http://ww2.sinaimg.cn/large/006fVPCvjw1ezvcqv63zoj30u01hcah1.jpg" alt=""><br><br>②<font color="#ff0000"><strong>wakelock detector WLD</strong></font>查看流氓唤醒大户 这里要提到微信。千万不要手欠在应用内使用它的升级。最好在play或者cool市场升级。官方提供的流氓唤醒一个晚上唤醒好几千次。从未进入过休眠状态。一进入唤醒状态又有很多应用跟着启动。 微信的消息是利用同步，而CPU唤醒锁则是被滥用了的。<br><br>Test1 2016.01.06<br><br><img src="http://ww4.sinaimg.cn/large/68eb7c93gw1ezp096st0oj20u01hcwlt.jpg" alt=""><img src="http://ww4.sinaimg.cn/large/68eb7c93gw1ezp0akfqdzj20u01hcgrl.jpg" alt=""><img src="http://ww4.sinaimg.cn/large/68eb7c93gw1ezp09t72gcj20u01hcwja.jpg" alt=""><img src="http://ww3.sinaimg.cn/large/68eb7c93gw1ezp0a61g8yj20u01hcgt8.jpg" alt=""><br><br>上图分别是WLD四个视图-CPU唤醒锁时间、Kernel唤醒锁时间、屏幕唤醒锁触发次数、Alarm触发器次数.<br><br>CPU锁实际上就是用户app的持有wakelock的时间。可以看到由于需要同步相册里的图片，本次测试中google photo占用了极大部分的唤醒锁时间，其余的应用则比较正常；内核持有wakelock一般与rom的品质有关，由于po主使用的是第三方精简rom，出现了一些奇特的bug，例如第一项qcom_rx_wakelock高通的cpu在5.1的bug，在熄屏状态下仍在进行不停的wifi连接，持有唤醒锁对应用进行超负荷的运算，这也是比较不容易控制也难以改善的方面；屏幕唤醒则和用户使用的点亮次数有关，可以看到，每次启动SU超级root、微信、QQ、BBS都进行了短暂的唤醒，而视频软件如果在播放中熄屏，亮屏后也会唤醒屏幕锁（持久保有）；最后一项则是需要重点关注的，定时器启动唤醒锁，2个多小时内，google服务、微信、微博、日历、输入法都进行了大量的唤醒，导致80%的时间都难以进入deep sleep。<br><br>Test2 2016.01.08<br><br>CPU唤醒锁：本次测试google相册已经不进行同步，更多的是Gmail的同步操作。由于输入了7个邮件，不可避免的会进行更多频次的操作。除了gmail能利用谷歌框架同步外，其他邮件都应该设置比较合理的同步时间。而微信（后文提及）设置了封锁CPU锁后同步的频次也有所减少。<br><br>kernel wakelock：qcom_rx_wakelock已经减少了很多，这是关闭黑屏手势的减少唤醒次数的效果。两次测试中，PowerManagerService.WakeLocks、qcom_rx_wakelock、PowerManagerService.Broadcasts、NETLINK四个核心服务占据的时间远远超过其他的服务。这也是需要优化的部分。<br><br>屏幕唤醒锁触发：<br><br>Alarm计时器触发：可以看到QQ、微信在夜晚的唤醒次数有些多，其实在qq、微信中都可以设置免打扰时间段，主动的消除在夜间待机时的计时器唤醒推送。<br><br><img src="http://ww4.sinaimg.cn/large/68eb7c93gw1ezrvmr0wr2j20u01hcqaa.jpg" alt=""><img src="http://ww3.sinaimg.cn/large/68eb7c93gw1ezrvnilpewj20u01hc7ai.jpg" alt=""><br><br><img src="http://ww1.sinaimg.cn/large/68eb7c93gw1ezrvjeovxej20u01hcahy.jpg" alt=""><img src="http://ww3.sinaimg.cn/large/68eb7c93gw1ezrvlj75wdj20u01hcn5a.jpg" alt=""><br><br>&nbsp;<br><br>4.绿色守护、3C ToolBox、Amplify的使用。<br><br>①.<font color="#ff0000"><em>*绿色守护</em></font></li></em>

<font color="#ff0000">思路</font>：熄屏清掉所有被勾选的app的服务和缓存进程，同时阻止所有可唤醒包含服务的监听receiver&amp;释放所有包含服务的相互唤醒wakelock，达到相对休眠状态。主要运作在熄屏后不希望后台运作的程序（<font color="#ff0000">无法在前台操作切断应用间唤醒</font>）。捐助版的亮点是可以在休眠状态下使用GCM服务。<br><br>绿色守护在xda的讨论贴 开发者oisisfeng也在。<br><br><a href="http://forum.xda-developers.com/showthread.php?t=2155737" title="http://forum.xda-developers.com/showthread.php?t=2155737" target="_blank" rel="external">http://forum.xda-developers.com/showthread.php?t=2155737</a><br><br>绿守作者在知乎的问答<br><br><a href="https://www.zhihu.com/question/38311793/answer/75897889" title="https://www.zhihu.com/question/38311793/answer/75897889" target="_blank" rel="external">https://www.zhihu.com/question/38311793/answer/75897889</a><br><br>由于测试机在5.1.1,还未升级到Android M，因此没有享受到doze mode和app standby带来的福利。<br><br>一张图看到就算不是 百度阿里疼腾讯系 从某个市场出来的app也会相互唤醒。这锅到底谁来背。以后反编译源码看一看。即刻-豆瓣-虎皮体育-同花顺-航旅纵横-什么值得买是什么关系。更不用说百度及包含百度字样的app-爱奇艺-去哪儿-uber-乐视-91-多米-音悦台-穷游途牛-汽车之家&nbsp; 腾讯及包含qq字样-京东-大众-美团-饿了么-58-猎豹-搜狗-同城 阿里及UC-微博-优酷土豆-陌陌-滴滴快的-小米魅族<br><br><img src="http://ww2.sinaimg.cn/large/68eb7c93gw1ezs6frg1q4j20u01hc461.jpg" alt=""><br><br>使用方法：主界面显示正在运行的服务及已经绿色化的应用。点击上方【+】号对所有潜在威胁进行评估，勾选的应用会在熄屏数分钟后清空缓存、杀死服务、抑制app唤醒及alarm的唤醒。root及xposed模式下效果更佳。支持gcm的应用会有小图标，能在绿色化的情况下还可收发消息。<br><br>②.<font color="#ff0000"><strong>3C tool box</strong></font>

<font color="#ff0000">思路</font>：封杀选定的activity receiver service。结晶化应用（无论前台后台，需要更多的测试，容易出现应用fc 可以实现前台界面退出后直接清缓存 <font color="#ff0000">可直接在应用使用中禁止广告、介绍、推荐app的activity和service</font>）（本篇不涉及3c的调频调压 内存管理设置）<br><br>例如：杀错了谷歌的邮件提醒，即便能实时接收邮件，但系统不做出提醒通知。<br><br><img src="http://ww4.sinaimg.cn/large/68eb7c93gw1ezrulsjoalj20u01hcgt5.jpg" alt=""><br><br>又例如：杀错了QQi的消息消息提示核心，虽然在后台能看到QQ的进程，但新消息通知会出现不同步（极有可能是阻止了开机自启杀掉的，但这个receiver需要的权限相当多，网络改变、时间改变等乱七八糟的）<br><br><img src="http://ww1.sinaimg.cn/large/68eb7c93gw1ezrusb4h51j20u01hctf7.jpg" alt=""><br><br>再比如杀掉了随手记的通知权限，居然能把自己的同步服务给搞挂了。。这代码写的。此外几个应用，饿了么，大众点评，都有不同程度的易fc但后台又唤醒个不停的问题。<br><br>使用方法：对四大组件中那三个进行轮番排查，限制自启动，限制唤醒路径，冻结后台。（主要操作在应用管理里）<br><br>③<strong><font color="#ff0000">唤醒控制Amplify</font></strong>的使用<br><br>思路：对Alarm计时器的时间进行限制重设、对Service进行屏蔽、限制同步，可使用进阶的正则表达式过滤。<br><br>使用方法：对在wld找到的唤醒次数多的详细分析，对alarm中唤醒频次高的限制更长的时间，对显见的服务停用，先做完这两者再对wakelock进行限制。<br><br><img src="http://ooo.0o0.ooo/2016/01/10/569322dfc0422.png" alt=""><br><br>④<strong><font color="#ff0000">禁止唤醒</font></strong>的使用(非捐助版只能对5个app进行限制，入正也就十几块)<br><br>思路：在前台就主动把各类唤醒锁进行封闭、定时器对齐、对同步进行限制<br><br>作者曾提到了<font color="#ff0000">唤醒锁的危害</font><font color="#000000">及禁止唤醒对这些危害的防范</font>

<p><strong>CPU唤醒锁</strong>: 这是在息屏后阻止你的设备进入休眠状态的唤醒锁, 禁用它通常不会有任何问题.</p>
<p><strong>所有其它唤醒锁</strong>: 除了CPU唤醒锁之外, 还有一些唤醒锁可以阻止设备休眠, 甚至阻止设备息屏. 开启这个选项以禁用这些唤醒锁.</p>
<p><strong>同步</strong>: 同步也可以唤醒设备, 如果你不需要应用的同步功能, 使用这个选项来禁用掉它.</p>
<p><strong>对齐定时器:</strong> (&gt;= Android 4.4) AlarmManager可以使用定时器来周期性的唤醒设备, 阻止CPU进入长期休眠状态. 启用这个选项来强制对齐定时器, 让它们尽量在同一时间触发以节省电量. 请注意: 对于设计不良的应用, 启用此选项有可能会引发推送消息延迟.</p>
<p><a href="https://www.linangran.com/?p=611" target="_blank" rel="external">https://www.linangran.com/?p=611</a> 作者使用指南</p>
<p><img src="http://ooo.0o0.ooo/2016/01/10/569323251d9ce.png" alt=""></p>
<p>⑤阻止运行的使用</p>
<p><a href="https://github.com/liudongmiao/ForceStopGB" title="https://github.com/liudongmiao/ForceStopGB" target="_blank" rel="external">https://github.com/liudongmiao/ForceStopGB</a> 开源项目地址 免费</p>
<p>相当推荐的一款软件，无论前后台，通过劫持系统api，直接禁止非需求service的启动。精简版的3c tool box，保证应用只在需要时启动。添加到阻止列表的应用只在以下情况开启：</p>
<ul>
<li>启动器直接或第三方provider，如手动点button、分享、支付  </li><li>桌面小部件定时更新、但只维持30秒（这个好顶赞）  </li><li>同步开启时的定时同步，也只能维持30秒  </li><li>除谷歌服务外的系统服务、支付宝的支付服务  </li><li>其他可能的用户行为引起的启动</li>
</ul>
<p>同时，谷歌服务在阻止列表时，可以支持gcm和谷歌家族应用的使用。但当任何一个谷歌家族应用没有退出时，都不会退出谷歌服务。</p>
<p><img src="http://ooo.0o0.ooo/2016/01/10/569322a0e590e.png" alt=""></p>
<p>5.针对微信的方案</p>
<p>微信最近从良而加入gcm的推送方案，能在有谷歌框架的手机在hibernate休眠状况下直接推送消息！既不用随时拿着唤醒锁又不唤醒其他乱七八糟的应用！但原先保留的wakelock模式依旧存在，握着各种随机数的锁禁都不知道禁哪些。但大神出现了。 </p>
<p><a href="https://www.zhihu.com/question/31136645" target="_blank" rel="external">https://www.zhihu.com/question/31136645</a> 知乎高票的正则表达式杀wakerlock方案</p>
<p><a href="http://bbs.gfan.com/android-7963258-1-1.html" target="_blank" rel="external">http://bbs.gfan.com/android-7963258-1-1.html</a> gfan精华帖</p>
<p>上面是一种方案，但微信更改了wakelock的命名方式就会得不偿失错杀唤醒锁了。最近发现单独使用【 禁止唤醒】中的CPU唤醒锁，也能阻止微信胡乱的唤醒，同时不影响推送；但相同的情况下使用绿色守护对微信绿色化却不能及时收到消息。</p>
<p>6.针对gms的方案 考虑到gms 的复杂性 提一下它涉及到google账户的同步<em>sync</em> 备份 keep photo gmail(分为对被墙的不被墙的) 三个文档&nbsp; play软件升级等等 google service包含了N个心跳包的alarm 各种硬件CPU唤醒锁</p>
<p>①完全禁掉是一个办法（当然这需要框架 service play一起禁 不然各种报错）这种方式最省电 但是又想使用google收国内账户 或者时不时FQ看看FB TW IG使用其中一些</p>
<p>②不停更换host文件。这个方式能保证随时上墙又不会因为vpn挂着长期费电。测试几天发现耗电稳定，gmail是不是抽风但效果拔群。（推荐神站load.cn）</p>
<p>③长时间挂载稳定vpn。该方式同样能随时保证上墙接收同步和推送。同时配合now能享受到肉身翻墙的欢喜效果。但vpn的开发良莠不齐，耗电状况不一。</p>
<p>④不需要google家族的直接装无gms版的精简rom或国内大部分融都会删掉——————这个方法纯天然摒除了谷歌的抽风状况，但，滚粗。</p>
<p>⑤久不久上墙。gms耗电的问题就是连接不上google而大量地进行重连接。所以希望使用google服务又不想随时耗电使用vpn的一个便捷方案就是每天保证登录一次，并在amplify对google框架进行限制时间，每隔一天敲醒alarm一次，但不能阻止cpu唤醒锁对gms想要获取推送的影响。</p>
<p>参考：</p>
<p>【2013.04.14】绿守作者 微信收费事件背后被广泛忽略的技术细节</p>
<p><a href="http://blog.oasisfeng.com/2013/04/14/dirty-secret-behind-weixin-charge-gate/" title="http://blog.oasisfeng.com/2013/04/14/dirty-secret-behind-weixin-charge-gate/" target="_blank" rel="external">http://blog.oasisfeng.com/2013/04/14/dirty-secret-behind-weixin-charge-gate/</a></p>
<p>【2013.06.19】PC Online 的省电优化方案介绍</p>
<p><a href="http://pcedu.pconline.com.cn/334/3345895_all.html" title="http://pcedu.pconline.com.cn/334/3345895_all.html" target="_blank" rel="external">http://pcedu.pconline.com.cn/334/3345895_all.html</a></p>
<p>【2014.02.16】唤醒锁: 检测 Android* 应用中的 No-Sleep（无法进入睡眠）问题</p>
<p><a href="https://software.intel.com/zh-cn/android/articles/wakelocks-detect-no-sleep-issues-in-android-applications?language=es" title="https://software.intel.com/zh-cn/android/articles/wakelocks-detect-no-sleep-issues-in-android-applications?language=es" target="_blank" rel="external">https://software.intel.com/zh-cn/android/articles/wakelocks-detect-no-sleep-issues-in-android-applications?language=es</a></p>
<p>【2014.06.05】wakelock alarm wifi 详细数据测评 唤醒锁: 检测 Android* 应用中的 No-Sleep（无法进入睡眠）问题<a href="http://www.oneplusbbs.com/forum.php?mod=viewthread&amp;tid=366390" target="_blank" rel="external">http://www.oneplusbbs.com/forum.php?mod=viewthread&amp;tid=366390</a></p>
<p>【2014.07.22】Android Standby 对于绿色守护唤醒对其 进入深睡眠的一些思考</p>
<p><a href="http://lockekk.github.io/jekyll-bootstrap/2014/07/22/Android-Standby/" title="http://lockekk.github.io/jekyll-bootstrap/2014/07/22/Android-Standby/" target="_blank" rel="external">http://lockekk.github.io/jekyll-bootstrap/2014/07/22/Android-Standby/</a></p>
<p>&nbsp;</p>
<p>android论坛关于ba保持屏幕唤醒和cpu唤醒</p>
<p><a href="http://developer.android.com/training/scheduling/wakelock.html" title="http://developer.android.com/training/scheduling/wakelock.html" target="_blank" rel="external">http://developer.android.com/training/scheduling/wakelock.html</a></p>
<p>此外 几个app的酷市场下评论都很精彩。</p>
<p>例如Amplify的评论 <a href="http://coolapk.com/feed/1201169" title="http://coolapk.com/feed/1201169" target="_blank" rel="external">http://coolapk.com/feed/1201169</a></p>
<p>例如Google Play Service 的评论 <a href="http://coolapk.com/feed/1196656" title="http://coolapk.com/feed/1196656" target="_blank" rel="external">http://coolapk.com/feed/1196656</a></p></li>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/28/Android为毛耗电[1]/" itemprop="url">
                  Android为毛耗电[1]
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-28T23:34:25+08:00" content="2015-12-28">
              2015-12-28
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/App强推/" itemprop="url" rel="index">
                    <span itemprop="name">App强推</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/App强推/软文/" itemprop="url" rel="index">
                    <span itemprop="name">软文</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/12/28/Android为毛耗电[1]/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/28/Android为毛耗电[1]/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong><font color="#000000"></font>**</strong><font color="#000000" size="4"><font face="微软雅黑 Light">本文只讨论安卓手机软节电，不负责推荐底包、rom、调频调压方案，<font color="#ff0000">刷机root后果自负。</font></font></font>**</p>
<font color="#000000" size="4" face="微软雅黑 Light"><strong>纯硬货，只想节电看后文。</strong></font>

<font color="#000000" size="4" face="微软雅黑 Light">使用安德猴主要还是谷歌的情怀。最近无可救药的恋上了无线高质量同步的Google相册和Keep。此外Google Contact和Gmail也时不时要收一下。</font>

<font color="#000000" size="4" face="微软雅黑 Light">问题是。。墙内不能随时翻。国内流氓自启和相互唤醒严重影响待机时间。如何破？首先搞清楚什么在耗电。再来解决怎么防流氓的同时不影响收发消息体验。</font>

<font color="#333333"><font size="4"><font face="微软雅黑 Light"><font color="#000000">这里提到的几个概念是安猪手机由于真后台，而造成的各种能耗电耗流量元凶——四大组件</font><strong><font color="#ff0000">Activity、Service、BroadCastReceiver、ContentProvider</font>。</strong></font></font></font>

<p><strong><font color="#333333" size="4" face="微软雅黑 Light">耗电–一定是这四个中的一个在以某种方式运行</font></strong></p>
<font color="#000000" size="4"><font face="微软雅黑 Light"><font color="#ff0000"><strong>Activity</strong></font>简言之就是前台窗体可视界面它上面可以显示一些控件也可以监听并处理用户的事件做出响应。你跳转到一个程序的界面、里面可能嵌套了很多个Activity。也有的一个Activity自成一个界面，例如第一次启动的引导界面。当然，程序猿代码风格迥异，一个<font size="4">Activity有的直接盖在一个上面，这样按下返回键销毁当前的能直接返回上一个；有的流程和任务则直接生成新Activity把当前的干掉。一些广告，一些无聊的需求，如淘宝摇一摇、美图下游戏，你完全不想要，则可以通过阻止Activity启动的方式，干掉。这样的做法可以降低内存消耗。但如果代码流程，若写入了不开启这个Activity就没法运行，很可能造成FC。因此测试Activity阻止就需要很谨慎。网路也有很多大神提供了Activity的阻止列表。但App更新极快，同时包名和Activity的命名方式更加让人难以捉摸，就相当难以防范。</font></font></font>

<font color="#000000"><font size="4"><font face="微软雅黑 Light"><font color="#ff0000"><strong>Activity</strong></font>之间通过<font color="#ff0000">Intent</font>进行通信，它描述的事某一个事件（单机、浏览、编辑）。也就是说这个Activity的一些参数在Activity跳转时，通过把参数塞入Intent这样一个对象，在另一个Activity读取。在Intent的描述结构中，有两个最重要的部分：动作和动作对应的数据。而IntentFilter则对应一个Activity能做哪些Intent。IntentFilter通常写入Android的AndroidManifest文件中定义好。</font></font></font>

<font color="#000000"><font size="4"><font face="微软雅黑 Light"><font color="#ff0000"><strong>BroadCastReceiver</strong></font>（广播接收器）它是监听响应各种手机变化并作出响应反应的组件。例如打进电话某个App调出号码查询，例如WiFi网络改变某App可以进行同步。这些监听并不经常是我们需要的，同时如果App写的极差，接收的广播级多，也会造成资源的浪费也相当耗电。它并不会产生一个界面，但是它能唤起一个Activity或者Service对事件进行相应。最常见的就是电话来了闪灯响铃，最讨厌的就是有Wifi了发个通知广告。甚至，当一个App装过还启动过，由于设置了开机启动的响应或网络状况的变化响应，都会产生通知。然而与Activity一样，阻止某一种广播接收同样会可能造成应用使用不正常，但FC情况相当少，测试的时候需要相当小心，但这里的组件命名方式都较为规范，因此测试起来也会比较顺利。</font></font></font>

<font color="#000000" size="4" face="微软雅黑 Light">监听广播同样可以视为一个事件，使用Intent对其参数进行传递。这些事件，就是通常意义上的权限，可以查看联系人、可以监听电话等。许多监控App都能查看并修改应用程序能够监听的内容。注册广播接收器可以写入一个App的AndroidManifest.xml中进行静态注册，若完成时间比较长必须通过线程，放进Service后台中运行，否则容易造成程序卡顿；也可以程序动态注册，当Activity关闭后，监听广播也关闭，这样的做法比较省电，但是关闭程序就无法接受一些通知和广告。（需要完全退出或者多任务杀掉）因此大多数App都采用静态注册，App不启动，也能通过订阅的广播触发，例如开机启动触发、时间变化触发等。</font>

<font color="#000000"><font size="4"><font face="微软雅黑 Light"><font color="#ff0000"><strong>Service</strong></font>（服务）也是无界面的组件，它通过后台长时间的运行来进行运行一些监测程序，例如后台听歌单曲循环等，后台轮询查询最新消息的微博。配合BroadCastReceiver使用效果极佳耗电也极棒。一个App很可能有相当多的Service在后台挂着，同时一个流氓集团的Service也会相互唤醒保证一个被杀掉的时候又自启动。但乱杀也会造成严重的后果，一些闹钟，一些天气，一些消息软件误杀后没有了后台Service做消息推送，就会错过重要的事情。</font></font></font>

<font color="#000000" size="4" face="微软雅黑 Light">一个Service不能自己运行。首次启动需要create再start，第二次之后就只用start需要别的启动或触发。但Service一旦启动，就与调用者无关了。需要停止service需要调用stop方法同时销毁destroy。可以使用bindservice让service随着调用者关闭而终止。</font>

<font color="#000000"><font size="4"><font face="微软雅黑 Light"><font color="#ff0000"><strong>ContentProvider</strong></font>(内容提供者)一个应用程序的指定数据集提供给其他应用程序。这些数据可以存储在文件系统中、在一个SQLite数据库、或以任何其他合理的方式。其他应用可以通过ContentResolver类(见ContentProviderAccessApp例子)从该内容提供者中获取或存入数据.(相当于在应用外包了一层壳),最常见的就是支付婊在别的应用中的调用，它提供了一个统一的支付接口，写在一个内部路径URL里。</font></font></font>

<font color="#ff0000" size="4" face="微软雅黑 Light">四大组件启动，</font>

<font color="#000000" size="4" face="微软雅黑 Light">除了ContentProvider是通过别的应用程序调用ContentResolver 发出内容请求后激活外，其他三个都是通过Intent异步消息激活。<br>Activity的激活通过传递一个Intent 对象至<font color="#ff0000">Context.startActivity()或Activity.startActivityForResult()</font>以载入（或指定新工作给）一个activity。 前面的函数直接启动的Activity，可以查看Intent中传入的参数。若期待新启动的Activity返回一个值（例如填写个人信息提交返回是否成功）就调用后面那个函数，并调用onActivityResult() 查询返回结果.<br>Service的激活可以通过传递一个Intent 对象至<font color="#ff0000">Context.startService()或Context.bindService()</font>前者Android 调用服务的onStart()方法并将Intent 对象传递给它，后者Android 调用服务的onBind()方法将这个Intent 对象传递给它<br>发送广播可以通过传递一个Intent 对象至给<font color="#ff0000">Context.sendBroadcast() 、Context.sendOrderedBroadcast()或Context.sendStickyBroadcast()。</font>Android 会调用所有对此广播有兴趣的广播接收器的onReceive()方法，将intent 传递给它们</font><br><br><font color="#ff0000" size="4" face="微软雅黑 Light">四大组件销毁时，</font>

<font color="#000000"><font size="4"><font face="微软雅黑 Light"><font color="#ff0000"><strong>ContentProvider</strong></font>通过别的应用程序调用，消息处理完毕即销毁（如调用图片viewer看图，调用支付接口付款）。<font color="#ff0000"><strong>BroadCastReceiver</strong></font>则注册在系统中监听，这两者都无需主动人为关闭，可以直接在权限中限制。其中BroadCastReceiver的生命周期只有十秒，否则就会报ANR(Application No Response)程序无响应的消息。<br><strong><font color="#ff0000">Activity</font></strong>则通过finish()函数退出。一般情况下，按下返回退出键，或在多任务窗口杀掉都能直接关闭显式的Activity。有时直接按下Home键则会在后台缓存（Process），当切换过多个应用后，切回来时还能完整的保留原先打开时候的数据和窗口。当然，这样的过程会占用内存空间（RAM），同时也消耗一定的电量（比较少）。当后台运行过多缓存时，部分低内存手机会出现明显的卡顿。Android5.0之后的系统做的不错，能够按照优先级杀掉缓存应用。<br><strong><font color="#ff0000">Service</font></strong>是个比较头疼的东西。尽管App可以调用<font color="#ff0000">Context.stopService()</font>方法关闭服务，或使用<font color="#ff0000">bindService()</font>绑定调用的组件关闭，但，流氓才不会这么做。<br>通常，手机应用中都看到正在运行的x个进程和y个服务。进程由多个线程组成，其中，主线程主要负责全局的参数传递，一些核心启动器及主界面的显示。而一些时间较长的函数，如获取多个图片，获取大量的数据，可以写在一个子线程，对主界面交互可以进行异步刷新，否则会造成主界面的卡顿。而当程序退居后台后，子线程依然处理数据，但没有了Activity进行联系，因此可以通过Service进行管理。由于Service并不负责应用层面的复杂操作，只对数据进行处理传递，同时可以写进单独的进程中，因而更为便利。</font></font></font>

<font color="#000000" size="4" face="微软雅黑 Light">这里总结一下Service能被启动&amp;被守护的各种方式。</font>

<font color="#000000" size="4" face="微软雅黑 Light">1.打开应用后，直接显而易见的调用它想要完成的Service，此时按照一般的逻辑，理应是退出App关闭Activity后就会stopservice.</font>

<font color="#000000" size="4" face="微软雅黑 Light">2.注册一个广播，可以按时钟、按网络变化、屏幕变化等，每次触发这些广播，就会检查一次Service的状况。遇到杀掉就重启。此时应当关注app的权限及其注册的广播。</font>

<font color="#000000" size="4" face="微软雅黑 Light">3.重写Service里的函数，在被杀时自动重启；配置到单独的进程中；配置安卓persistent=true；设置前台foreground=true.这些情况，在root情况下很容易被进程管理的杀掉</font>

<font size="4"><font face="微软雅黑 Light"><font color="#000000">4.双Service或多Service守护，在AndroidManifest.xml里面定义Service时加入android:process=”:service1”</font><br></font></font>

<pre class="brush: xml; gutter: true; first-line: 1; highlight: []; html-script: false">&lt;service android:enabled="true" 
android:name="com.service.demo.Service1" 
android:process=":service1"&gt;
&lt;service&gt;
&lt;service android:enabled="true" 
android:name="com.service.demo.Service2" 
android:process=":service2"&gt;
&lt;service&gt;  
</pre>

<p>&lt;</p>
<p>p align=”left”&gt;<span><span><font color="#000000" size="4" face="微软雅黑 Light">关键的Point是触发了service的onTrimMemory()函数。又分别重新启动。</font></span></span></p>
<p><span><span><font size="4"><font face="微软雅黑 Light"><font color="#000000"></font></font></font></span></span>&nbsp;</p>
<p><span><span><font size="4"><font face="微软雅黑 Light"><font color="#000000">5.Wakelock。Android机制下有一个唤醒锁，可以唤醒休眠中的手机。</font><font color="#000000">WakeLock阻止应用处理器（Application <wbr>Processor）挂起</font><font color="#000000">，确保关键代码的运行，通过中断唤起应用处理器（Application <wbr>Processor），可以阻止屏幕变暗。一旦有有效的wakelock，系统就不能进入深度睡眠（Deep Sleep）。一般在熄屏传输文件、下歌中使用。被滥用后，后果不堪设想。</font></font></font></span></span></p>
<p><span><span><font color="#000000" size="4" face="微软雅黑 Light">AlarmManage有一个AlarmManagerService,该服务程序主要维护app注册下来的各类Alarm,并且一直监听 Alarm设备，一旦有Alarm触发，或者是Alarm事件发生，AlarmManagerService就会遍历Alarm列表，找到相应的注册 Alarm并发出广播。Alarm <wbr>Manager会维持一个cpu的wake <wbr>lock。这样能保证电话休眠时，也能处理alarm的广播。一旦alarm <wbr>receiver的onReceive() <wbr>方法执行完，wake <wbr>lock会迅速被释放。如果在receiver中开启一个service，有可能service还没启动，wake <wbr>lock已经被释放了。所以此时要实现单独的wake <wbr>lock策略。</font></span></span></p>
<p><span><font color="#000000" size="4" face="微软雅黑 Light">这也是一般不root不能根治的唤醒service的手段。App通过反复注册系统应用，调用级别高的Wakelock使得手机很难进入低频率的待机状态。</font></span></p>
<p><span><font color="#000000" size="4" face="微软雅黑 Light">6.注册成为系统app同时包名混乱的编写。隐藏需要调用的service。一般没root的做不到。</font></span></p>
<p><span><font color="#000000" size="4" face="微软雅黑 Light">所以，杀进程很容易，杀会自启的service也不难，难的是杀各种唤醒。</font></span></p>
<font size="4" face="微软雅黑 Light"></font>

<font size="4" face="微软雅黑 Light"><br><br><div align="left"><br><br><em> </em> <em><br><br></em></div><br><br></font><br><span><font color="#000000" size="4" face="微软雅黑 Light">这里提到两个重要概念：</font></span><br><br><span><font color="#000000"><font size="4"><font face="微软雅黑 Light"><font color="#ff0000"><strong>Wakelock</strong></font>。唤醒锁；<font color="#ff0000"><strong>Alarm</strong></font>。定时器</font></font></font></span><br><br><span><font size="4"><font face="微软雅黑 Light"><font color="#000000"><em>*Wakelock</em></font><font color="#000000">定义了一个接口，能让App有权限，在停止交互、黑屏状况下</font><font color="#ff0000">阻止手机休眠</font><font color="#000000">，运行关键而必要的一些代码，通常是账户同步、消息推送。<span>Android手机有两个处理器，一个叫Application Processor（AP），一个叫Baseband Processor（BP）。AP是ARM架构的处理器，用于运行Linux+Android系统；BP用于运行实时操作系统（RTOS），通讯协议栈运行于BP的RTOS之上。非通话时间，BP的能耗基本上在5mA左右，而AP只要处于非休眠状态，能耗至少在50mA以上，执行图形运算时会更高 。此外耗电大户wifi在100mA左右，LCD灯也在100mA左右。而进入休眠的手机大部分代码会停止运行。但，并不是很容易进入深度休眠的状态。</span></font></font></font></span><br><br><span><font color="#000000" size="4" face="微软雅黑 Light"><span>wakelock针对的是<font color="#ff0000">某个Activity，而不是整个app</font>。因此，获取和释放wakelock在单个Activity中进行。</span></font></span><br><br><span><font color="#000000" size="4" face="微软雅黑 Light"><span>对于唤醒锁，官方文档中的解释是：</span></font></span><br><br><a href="http://developer.android.com/reference/android/os/PowerManager.html#goToSleep(long" target="_blank" rel="external"><font color="#000000" size="4" face="华文中宋">PowerManager</font></a>)<font color="#000000" size="4" face="华文中宋">:This class gives you control of the power state of the device.</font>

<p><a href="http://developer.android.com/reference/android/os/PowerManager.WakeLock.html" target="_blank" rel="external"><font color="#000000" size="4" face="华文中宋">PowerManager.WakeLock</font></a><font color="#000000" size="4" face="华文中宋">: lets you say that you need to have the device on.</font></p>
<font color="#ff0000" size="4" face="微软雅黑 Light">只要系统中存在任一有效的wake_lock，系统就不能进入深度休眠，但可以进行设备的浅度休眠操作。</font>

<font size="4"><font face="微软雅黑 Light"><font color="#000000">Android定义了几种低功耗状态，</font>：<strong><font color="#ff0000">earlysuspend、suspend、hibernation.</font></strong></font></font>

<font size="4"><font face="微软雅黑 Light">1) <font color="#ff0000"><strong>earlysuspend</strong></font><font color="#000000">（浅度休眠），</font><font color="#000000">也有称standby</font></font></font><font size="4"><font face="微软雅黑 Light"><font color="#000000">: 是一种低功耗的状态,某些设备可以选择进入某种功耗较低的状态,比如 LCD可以降低亮度或灭掉;它不会受到wakelock阻止。例如接收黑屏手势。<br></font>2) <font color="#ff0000"><strong>suspend</strong></font><font color="#000000">（休眠），也有称sleep（bad nomenclature）: 是指除电源管理以外的其他外围模块以及cpu均不工作,只有内存保持自刷新的状态; 一般休眠到RAM</font></font></font>

<font size="4"><font face="微软雅黑 Light">3) <font color="#ff0000"><strong>hibernation</strong></font><font color="#000000">（冬眠）是指所有内存镜像都被写入磁盘（disk）中,然后系统关机,恢复后系统将能恢复到“关机”之前的状态。是最彻底的低功耗模式，它把所有内存镜像都写入磁盘中，然后系统关机，是Linux内核系统级的休眠。</font></font></font>

<font color="#000000" size="4" face="微软雅黑 Light"><br><br>PowerManager.WakeLock有加锁与解锁两种状态，而加锁的形式有两种:<br><br>①永久锁住，这种锁除非显式的放开，否则是不会解锁的，所以用起来需要非常小心！<br><br>②超时锁，到时间后就会解锁，而创建WakeLock后，有两种加锁机制: ①不计数锁机制，②计数锁机制(默认)可通过setReferenceCounted(boolean value)来指定,区别在于: 前者无论acquire( )多少次，一次release( )就可以解开锁。 而后者则需要(–count == 0)的时候，同样当(count == 0)才会去申请锁 所以，WakeLock的计数机制并不是正真意义上对每次请求进行申请/释放一个锁; 只是对同一把锁被申请/释放的次数来进行统计，然后再去操作！</font><font face="微软雅黑 Light"><font color="#000000"><font size="4">该操作可通过setReferenceCounted(boolean value)设置。</font></font></font>

<font color="#000000" face="微软雅黑 Light">当然，需要用到权限<pre>&lt;uses-permission android:name=”android.permission.WAKE_LOCK”/&gt;</pre><pre>&lt;uses-permission android:name=”android.permission.DEVICE_POWER”/&gt;</pre></font>

<font color="#000000" size="4" face="微软雅黑 Light">锁有两种类型：</font>

<font size="4"><font face="微软雅黑 Light"><font color="#000000">WAKE_LOCK_SUSPEND：这种锁会防止系统进入睡眠(suspend)。<br>WAKE_LOCK_IDLE：这种锁不会影响系统的休眠，用于阻止系统在持有锁的过程中进入低功耗状态。即直到wake_lock被释放，系统才会从idle状态进入低功耗状态，此低功耗状态将使中断延迟或禁用一组中断</font> </font></font>

<font color="#000000" size="4" face="微软雅黑 Light">有3个地方让<font color="#ff0000">系统直接开始挂起</font>suspend()， 分别是:</font>

<font color="#000000" size="4" face="微软雅黑 Light">&nbsp;&nbsp;&nbsp; • 在wake_unlock()中， 如果发现解锁以后没有任何其他的wake lock了，就开始休眠<br>&nbsp;&nbsp;&nbsp; • 在定时器都到时间以后，定时器的回调函数会查看是否有其他的wake lock，如果没有，就在这里让系统进入睡眠。<br>&nbsp;&nbsp;&nbsp; • 在wake_lock() 中，对一个wake lock加锁以后，会再次检查一下有没有锁， 这里的检查是没有必要的， 更好的方法是使加锁的这个操作原子化，而不是繁冗的检查，而且这样的检查也有可能漏掉。</font>

<font color="#000000" size="4" face="微软雅黑 Light">如下是一些常见的调用wakelock的操作<br><br></font>

<table width="80%" border="0"><br><tbody><br><tr><br><td width="20%"><br><br><font color="#000000" size="4" face="微软雅黑 Light">应用</font><br></td><br><td width="20%"><br><br><font color="#000000" size="4" face="微软雅黑 Light">操作</font><br></td><br><td width="20%"><br><br><font color="#000000" size="4" face="微软雅黑 Light">唤醒锁的服务</font><br></td><br><td width="20%" align="center"><font color="#000000" size="4" face="微软雅黑 Light">运行状态</font></td></tr><br><tr><br><td width="20%"><br><br><font color="#000000" size="4" face="微软雅黑 Light">任意</font><br></td><br><td width="20%"><br><br><font color="#000000" size="4" face="微软雅黑 Light">按下UI中的button或listview</font><br></td><br><td width="20%"><br><br><font color="#000000" size="4" face="微软雅黑 Light">PowerManagerService</font><br></td><br><td width="20%"><br><br><font color="#000000" size="4" face="微软雅黑 Light">启用并在5秒后释放锁定</font><br></td></tr><br><tr><br><td width="20%"><br><br><font color="#000000" size="4" face="微软雅黑 Light">地图/导航</font><br></td><br><td width="20%"><br><br><font color="#000000" size="4" face="微软雅黑 Light">启用地图或进入导航</font><br></td><br><td width="20%"><br><br><font color="#000000" size="4" face="微软雅黑 Light">gps-lock</font><br></td><br><td width="20%"><br><br><font color="#000000" size="4" face="微软雅黑 Light">锁定并使用GPS直到退出应用或手动设置取消GPS</font><br></td></tr><br><tr><br><td width="20%"><br><br><font color="#000000" size="4" face="微软雅黑 Light">视频软件</font><br></td><br><td width="20%"><br><br><font color="#000000" size="4" face="微软雅黑 Light">观看视频流</font><br></td><br><td width="20%"><br><br><font color="#000000" size="4" face="微软雅黑 Light">PowerManagerService</font><br></td><br><td width="20%"><br><br><font color="#000000" size="4" face="微软雅黑 Light">视频播放过程中一直启用唤醒锁</font><br></td></tr><br><tr><br><td width="20%"><br><br><font color="#000000" size="4" face="微软雅黑 Light">音乐软件</font><br></td><br><td width="20%"><br><br><font color="#000000" size="4" face="微软雅黑 Light">听歌</font><br></td><br><td width="20%"><br><br><font color="#000000" size="4" face="微软雅黑 Light">PowerManagerService</font><br></td><br><td width="20%"><font color="#000000" size="4" face="微软雅黑 Light">音乐播放过程中一直启用唤醒锁</font></td></tr></tbody></table>

<font color="#000000" size="4" face="微软雅黑 Light">Video和 Music 应用能够很好地展示不同级别的唤醒锁。 用户播放视频时，Video应用将会启用唤醒锁。 在播放视频的整个过程中，显示器会保持开启状态（忽略系统的显示设置）。 但是，如果用户在播放过程中按下了电源按钮，设备将会挂起，这会导致显示器关闭以及音频/视频停止播放。 Music 应用在播放音频时使用不同的唤醒锁。 显示设置无法更改，因此设备的屏幕将会根据用户的显示设置来关闭。 显示器关闭后，唤醒锁会让 CPU 保持活动状态以便音频能够继续播放 — 即使用户按下了电源按钮。</font>

<font color="#000000" size="4" face="微软雅黑 Light">上图可见，<font color="#ff0000">PowerManagerService</font>是一项使用率非常高的wakelock调用的操作，它是Android上层电源管理服务，属于<font color="#ff0000">内核唤醒锁,适用于所有局部唤醒锁（partial wakelock 后文提到）的容器</font>。主要负责系统待机、屏幕背光、按键背光、键盘背光以及用户事件的处理。这些可在后文的wakelock detector软件中看到。通过锁的申请和释放以及默认待机时间来控制系统的待机状态，通过系统的灭屏时间及用户操作的事件状态来控制背光暗亮。此外该服务还包括了光线、距离传感器上层查询与控制、LCD灯控制。</font>

<font color="#000000" face="微软雅黑 Light">其他的内核唤醒锁有：</font>

<font color="#000000">Wlan_rx： 当通过 Wi-Fi* 发送或接收数据时由内核控制。</font>

<font color="#000000">Sync： 在同步流程运行时启用。</font>

<font color="#000000">Alarm_rtc： 控制告警（当应用或流程执行定期检查时使用）。</font>

<font color="#000000">Main： 保持内核处于唤醒状态。 系统进入挂起模式时，这是最后一个被释放的唤醒锁。</font>

<font color="#000000" size="4" face="微软雅黑 Light">自最初版本的Android OS 的API中就设置了Android.OS.PowerManager.WakeLock类 </font><a href="https://developer.xamarin.com/api/type/Android.OS.PowerManager+WakeLock/" target="_blank" rel="external"><font color="#000000" size="4" face="微软雅黑 Light">https://developer.xamarin.com/api/type/Android.OS.PowerManager+WakeLock/</font></a><br><br><font color="#000000" size="4" face="微软雅黑 Light">一下为Java代码应用层的操作。</font>&nbsp;<br><br><pre class="brush: java; gutter: true; first-line: 1; highlight: []; html-script: false">PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);//创建pm对象<br>PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.SCREEN_DIM_WAKE_LOCK, “Tag”);<br>//第一个参数为flag,即后文提到的六个标记；最后一个参数为实例名，可以换成其他的<br>wl.acquire(); //唤醒点亮屏幕 获取wakelock<br>wl.release(); //恢复屏幕到黑暗 释放wakelock</pre><br><br>&nbsp;<br><br><font color="#000000" size="4" face="微软雅黑 Light">2.1 API Level7开始增加了一个判断屏幕是否处于点亮状态可以使用public boolean isScreenOn ()这个方法，代码为</font>

<pre class="brush: java; gutter: true; first-line: 1; highlight: []; html-script: false">PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
boolean isScreenOn = pm.isScreenOn();
</pre>

<font color="#000000" size="4" face="微软雅黑 Light">对它进行实例化。</font>

<font size="4"><font face="微软雅黑 Light"><font color="#000000">Wakelock源码简介</font>&nbsp; </font></font><a href="http://www.07net01.com/2015/07/870479.html" target="_blank" rel="external"><font size="4" face="微软雅黑 Light">http://www.07net01.com/2015/07/870479.html</font></a><br><br><font color="#000000" size="4" face="微软雅黑 Light">PowerManager和Wakelock申请 <a href="http://blog.csdn.net/wh_19910525/article/details/8287202" target="_blank" rel="external">http://blog.csdn.net/wh_19910525/article/details/8287202</a></font><br><p align="left"><span><font color="#000000" size="4" face="微软雅黑 Light">Android PowerManager API 介绍了4种用于更改设备电源状态的<font color="#ff0000">唤醒锁标记</font>：<br><br></font></span><br><table width="80%" border="0"><br><tbody><br><tr><br><td width="20%"><font color="#000000" size="4" face="微软雅黑 Light">标记值</font></td><br><td width="20%"><font color="#000000" size="4" face="微软雅黑 Light">CPU/场景</font></td><br><td width="20%"><font color="#000000" size="4" face="微软雅黑 Light">屏幕</font></td><br><td width="20%"><font color="#000000" size="4" face="微软雅黑 Light">键盘</font></td></tr><br><tr><br><td width="20%"><font color="#ff0000" size="4" face="微软雅黑 Light">PARTIAL_WAKE_LOCK</font></td><br><td width="20%"><font color="#000000" size="4" face="微软雅黑 Light">开启-长时间运行的后台service</font></td><br><td width="20%"><font color="#000000" size="4" face="微软雅黑 Light">关闭</font></td><br><td width="20%"><font color="#000000" size="4" face="微软雅黑 Light">关闭</font></td></tr><br><tr><br><td width="20%"><font color="#000000" size="4" face="微软雅黑 Light">SCREEN_DIM_WAKE_LOCK</font></td><br><td width="20%"><font color="#000000" size="4" face="微软雅黑 Light">开启-除非必须保持CPU运行至运算完成，否则尽量使用FLAG_KEEP_SCREEN_ON</font></td><br><td width="20%"><font color="#000000" size="4" face="微软雅黑 Light">低亮度</font></td><br><td width="20%"><font color="#000000" size="4" face="微软雅黑 Light">关闭</font></td></tr><br><tr><br><td width="20%"><font color="#000000" size="4" face="微软雅黑 Light">SCREEN_BRIGHT_WAKE_LOCK</font></td><br><td width="20%"><font color="#000000" size="4" face="微软雅黑 Light">同上</font></td><br><td width="20%"><font color="#000000" size="4" face="微软雅黑 Light">高亮度</font></td><br><td width="20%"><font color="#000000" size="4" face="微软雅黑 Light">关闭</font></td></tr><br><tr><br><td width="20%"><font color="#000000" size="4" face="微软雅黑 Light">FULL_WAKE_LOCK</font></td><br><td width="20%"><font color="#000000" size="4" face="微软雅黑 Light">同上</font></td><br><td width="20%"><font color="#000000" size="4" face="微软雅黑 Light">高亮度</font></td><br><td width="20%"><font color="#000000" size="4" face="微软雅黑 Light">调亮</font></td></tr></tbody></table><br><font color="#000000" size="4" face="微软雅黑 Light">需要注意的是 API17开始，FULL_WAKE_LOCK将被弃用，取而代之的是FLAG_KEEP_SCREEN_ON 因此有的检测软件也将屏幕亮屏所单独提出来，表明调用该锁时目的是保证屏幕不会超时熄灭。</font>

<font color="#000000" size="4" face="微软雅黑 Light">除了四个标记值外，还提供了两个Flag配合使用。</font>

<font color="#000000" size="4" face="微软雅黑 Light">ACQUIRE_CAUSES_WAKEUP：默认情况下唤醒锁并不是马上开启CPU、屏幕或者调整键盘的亮度（对于屏幕处于低亮度或高亮度、键盘处于高亮，唤醒锁只是在被开启后，延续这一状态）但如果加上这一标记，就可让屏幕或键盘亮度未开启的状态下，马上开启它们。典型的例子就是受到一个重要的notification时（短信、邮件等），需要马上点亮屏幕。</font>

<font color="#000000" size="4" face="微软雅黑 Light">ON_AFTER_RELEASE：当wake lock被释放的时候，当前调用wake lock的activity的计数器会被重置，所以屏幕会继续亮一段时间。</font>

<font size="4"><font face="微软雅黑 Light"><font color="#000000">因此，Android中通常是这么写。</font><br></font></font><br><div align="center"><pre class="brush: java; gutter: true; first-line: 1; highlight: []; html-script: false">PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);<br><br> WakeLock sCpuWakeLock = pm.newWakeLock(<br>                PowerManager.FULL_WAKE_LOCK |<br>                PowerManager.ACQUIRE_CAUSES_WAKEUP,”okTag”);<br> if (sCpuWakeLock!= null) {<br> sCpuWakeLock.release();<br>          sCpuWakeLock = null;<br><br>}<br></pre></div><br><br><font color="#000000" size="4" face="微软雅黑 Light"></font>&nbsp;<br><br><strong><font color="#ff0000">注意</font></strong>：如果申请了<font color="#ff0000">partial wakelock</font>,那么即使按Power键,系统也不会进Sleep,如Music播放时。所有的锁必须成对的使用, 如果申请了而没有及时释放，会造成系统故障。如申请了partial wakelock,而没有及时释放, 那系统就永远进不了Sleep模式.<br><br>因此，partial wakelock作为6中标识中，需最为谨慎使用的一个。BBS也专门指出了partial wakelock造成的电量损耗及待机时长。其余的则可标记为屏幕锁，辅助标记CPU锁。<br><br><font color="#000000" face="微软雅黑 Light"><img src="http://ww4.sinaimg.cn/large/68eb7c93gw1eztpciku00j20de0bjjsd.jpg" alt=""></font>

<font size="4"><font color="#000000" face="微软雅黑 Light"><strong>上图表明了App内部、Android框架及内核硬件在唤醒锁交互中的流程。</strong></font></font>

<font size="4"><font face="微软雅黑 Light"><font color="#ff0000"><strong>AlarmManager</strong></font><font color="#000000">，有一个AlarmManagerService,该服务程序主要维护app注册下来的各类Alarm,并且一直监听Alarm设备，一旦有Alarm触发，或者是Alarm事件发生，AlarmManagerService就会遍历Alarm列表，找到相应的注册Alarm并发出广播，是Android中常用的一种<font color="#ff0000">系统级别的提示服务</font>，在特定的时刻为我们广播一个指定的Intent。通常我们使用 PendingIntent，可以理解为Intent的封装包，在Intent上在加个指定的动作。在使用Intent的时候，我们还需要在执行startActivity、startService或sendBroadcast才能使Intent有用。而PendingIntent的话就是将这个动作包含在内了。</font></font></font>

<font color="#000000" size="4" face="微软雅黑 Light">闹钟响起，实际上是系统发出了为这个<font color="#ff0000">闹钟注册的广播</font>，会自动开启目标应用。这种做法可以在某一时刻当做唤醒应用。注册的闹钟在设备睡眠的时候仍然会保留，可以选择性地设置是否唤醒设备，但是当设备关机和重启后，闹钟将会被清除。在alarm的receiver的onReceive()方法被执行的时候，Alarm Manager持有一个CPU唤醒锁，这样就保证了设备在处理完广播之前不会sleep。</font>

</p><p><span><font color="#000000"><font size="4"><font face="微软雅黑 Light">有4种Alarm类型： <wbr></font></font></font></span></p>
<font color="#000000"><font size="4" face="微软雅黑 Light">1)</font><font size="4"><font face="微软雅黑 Light"><font color="#ff0000">RTC_WAKEUP <wbr><br></font>在指定的时刻（设置Alarm的时候），唤醒设备来触发Intent。（闹钟）</font></font></font><font size="4" face="微软雅黑 Light"> </font>

<p><span></span><span><font color="#000000"><font size="4" face="微软雅黑 Light">2)<font color="#ff0000">RTC</font> <wbr><br>在一个显式的时间触发Intent，但不唤醒设备。<wbr><wbr><wbr><br>3)</font><font size="4"><font face="微软雅黑 Light"><font color="#ff0000">ELAPSED_REALTIME <wbr><br></font>从设备启动后，如果流逝的时间达到总时间，那么触发Intent，但不唤醒设备。流逝的时间包括设备睡眠的任何时间。注意一点的是，时间流逝的计算点是自从它最后一次启动算起。 <wbr>&nbsp;<wbr>&nbsp;<wbr><br>4)<font color="#ff0000">ELAPSED_REALTIME_WAKEUP</font> <wbr><br>从设备启动后，达到流逝的总时间后，如果需要将唤醒设备并触发Intent。</font></font></font></span></p>
<p><span><font color="#000000" size="4" face="微软雅黑 Light">这样，唤醒对齐的方案就显得相当便捷，让唤醒次数大大降低。把允许唤醒的应用，按照某一合理的时刻进行排序和对齐，不会凌乱的唤醒手机而出现过度的cpu变频造成的耗电。</font></span></p>
<p><span><font color="#000000"><font size="4"><font face="微软雅黑 Light"><font color="#ff0000">软节电</font>方案：</font></font></font></span></p>
<p><span><font color="#000000" size="4" face="微软雅黑 Light">1、对不需要联网、不需要通知的 限制权限&amp;App自调 取消通知、联网等权限 杀注册广播</font></span></p>
<p><span><font color="#000000" size="4" face="微软雅黑 Light">2、限制通知和自启动、互相启动、相互守护的service 禁启动</font></span></p>
<p><span><font color="#000000" size="4" face="微软雅黑 Light">3、（千万少做）安全软件狂杀进程process和service</font></span></p>
<p><span><font color="#000000" size="4" face="微软雅黑 Light">4、限制唤醒时长和对齐唤醒</font></span></p>
<p><span><font color="#000000" size="4" face="微软雅黑 Light">5、对可识别的Activity禁止</font></span></p>
<p><span><font color="#000000" size="4" face="微软雅黑 Light">6、对不需要通知、自升级、关闭软件啥也不想让他做的 结晶 禁止、半禁止一切后台</font></span></p>
<p><span><font color="#000000" size="4" face="微软雅黑 Light">7、争取多冬眠service</font></span></p>
<p><span><font color="#000000" size="4" face="微软雅黑 Light">8、在合理的时间重启并FQ</font></span></p>
<p><span><font color="#000000" size="4" face="微软雅黑 Light">So 开搞</font></span></p>
<p><span><font color="#000000" face="微软雅黑 Light"></font></span>参考</p>
<p><span><a href="http://www.runoob.com/w3cnote/android-tutorial-powermanager.html" target="_blank" rel="external">http://www.runoob.com/w3cnote/android-tutorial-powermanager.html</a>&nbsp; PowerManager(电源服务)</span></p>
<p><a href="http://www.kancloud.cn/kancloud/android-tutorial/87277" title="http://www.kancloud.cn/kancloud/android-tutorial/87277" target="_blank" rel="external">http://www.kancloud.cn/kancloud/android-tutorial/87277</a> 这俩好像一样、</p>
<p><a href="http://forum.xda-developers.com/galaxy-s2/general/guide-complete-guide-maximum-battery-t1909996" title="http://forum.xda-developers.com/galaxy-s2/general/guide-complete-guide-maximum-battery-t1909996" target="_blank" rel="external">http://forum.xda-developers.com/galaxy-s2/general/guide-complete-guide-maximum-battery-t1909996</a> 真的是能关的全给关了的大全</p>
<font size="4" face="微软雅黑 Light"></font>

<font size="4" face="微软雅黑 Light"></font>

<font size="4" face="微软雅黑 Light"></font>

<p><a href="http://lockekk.github.io/jekyll-bootstrap/2014/07/22/Android-Standby/" title="http://lockekk.github.io/jekyll-bootstrap/2014/07/22/Android-Standby/" target="_blank" rel="external">http://lockekk.github.io/jekyll-bootstrap/2014/07/22/Android-Standby/</a> Android Standby 解析查杀软件的弊病</p>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/18/后方交会检校(8)--光束法区域平差 bundle block adjustment/" itemprop="url">
                  后方交会检校(8)--光束法区域平差 bundle block adjustment
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-11-18T23:17:39+08:00" content="2015-11-18">
              2015-11-18
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/什么都学一下/" itemprop="url" rel="index">
                    <span itemprop="name">什么都学一下</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/什么都学一下/学习log/" itemprop="url" rel="index">
                    <span itemprop="name">学习log</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/11/18/后方交会检校(8)--光束法区域平差 bundle block adjustment/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/11/18/后方交会检校(8)--光束法区域平差 bundle block adjustment/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <font size="3">航空摄影最终的目标都是，将某一波段的图像（传感器接收的某一宽度波长的电磁波），在一定范围（地理空间范畴）内融合在一起。原因有：</font><br><br><font size="3">①拍摄的每幅图像幅宽有限（高的分辨率不够低了拍的面积不够多）</font>

<font size="3">②需要研究的区域相对一张或几张照片来说，太太太大了，没有或难以测量地面的标识，就只能靠拼接（然而飞机需要飞行，飞行需要时间，时间就带来光照、镜头本身、飞行姿态等各种变化）</font>

<font size="3">③除了高端的飞机带有精度极高的POS（position &amp; orientation system）能够实时记录飞行的姿态，即飞机的朝向、飞机的地理位置等明确告诉我该用哪个位置的点拼起来的，其他只能依赖，连续两张图片的相关性来拼（这里讲的就是，同名点即tie point）</font>

<p>——航摄大致思路？完成这一工作，最主要的工作是法一：利用地面其他物体的三维坐标（灰机、相机的某一时刻姿态也可以）点确定相邻两幅图像的地理位置（三维的，依赖地理空间的）——&gt;解算相对位置；法二，利用同名点（两幅图像都拍到的点，二维的，不依赖地理空间的），找到某个投影变换（即一个投影矩阵），直接解求两幅相邻图像的相对位置。</p>
<p>&nbsp;</p>
<font size="3">航摄中常用的三种用于加密控制点的方法有<span style="color: #ff0000">航带法、独立模型法、光束法</span>。其中航带法精度较低，不能用于高精度的测量。独立模型法较前者精度略高，光束法则是精度最高同时计算量最大的模型，适用于高精度航摄。</font>

<font size="3">——用来做啥?不同时刻的航摄图片，对绝对位置或相对坐标进行确认，为拼接准备。</font>

<font size="3"><font color="#ff0000">自检较光束</font>则是最广泛应用的做法，尽管<font size="3">粗差（奇葩的大误差）对于精度的影响极大</font>。其基本思想是选用一个由若干个参数组成的系统误差模型，将这些附加参数作为未知数与区域网的其他参数一起解求，从而达到在平差过程中自动消除系统误差的目的。其缺点是①<span style="color: #ff0000">附加参数人为选择</span>，选择不当会导致迭代结果不收敛恶化计算结果。②附加参数与区域网参数一起解求，会使<span style="color: #ff0000">计算量明显上升</span>。</font>

<font size="3"></font>&nbsp;<br><br><font size="3">光束法平差以单个像片作为平差单元（意思就是一个观测值是一个像片，主要包含像片的内外方位元素，它们作为一个整体，就如测量一个高程的值 一个坐标的值一样&nbsp; 在整个区域进行一边计算一边排错 进行平差处理 解算出每张相片的外方位元素 然后按照前方交会计算加密点（不同像片的拍下的重复点 tie point）坐标。</font>

<div class="PoweredByWebStory" style="margin-bottom: 10px; margin-top: 15px"><font size="3">&nbsp;</font></div>

<font size="3"></font>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/xiaozaizi.png" alt="Jay Wang">
          <p class="site-author-name" itemprop="name">Jay Wang</p>
          <p class="site-description motion-element" itemprop="description">你猜?</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">101</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">57</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jay Wang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"mimimomo"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax --><!-- hexo-inject:end -->


</body>
</html>