<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ov智商捉急</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ovjaywang.github.io/"/>
  <updated>2016-08-31T09:20:28.227Z</updated>
  <id>http://ovjaywang.github.io/</id>
  
  <author>
    <name>Jay Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://ovjaywang.github.io/2016/08/18/Learn-sth-the-other-day/"/>
    <id>http://ovjaywang.github.io/2016/08/18/Learn-sth-the-other-day/</id>
    <published>2016-08-18T10:58:03.744Z</published>
    <updated>2016-08-31T09:20:28.227Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;p&gt;title: Learn sth. the other day&lt;br&gt;date: 2016-08-18 18:58:03&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;learn&lt;br&gt;categories:&lt;/li&gt;
&lt;li&gt;学习log&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;16-08-31&lt;br&gt;Logistic回归是广义上的线性回归（将y变为lny）。它使用了一个单增可微函数，因而损失函数（预计值与实际值以某种函数表达的差异）接近。实际上它们都是指数分布族的函数。&lt;/p&gt;
&lt;p&gt;关于布冯投针试验，3个简易的理解方式（线宽为L 针长为a）：    &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;扔圈圈法&lt;/strong&gt;&lt;br&gt;直径为线宽（长度为时πL）的圆扔过去，必有两个点，扔n次必有2n个交点。根据机会均等原则，折成直线的情况扔过去，可能会有0,1,2,3,4个交点，但扔n次也必有2n个点。当针长为a时，显而易见的是a与交点个数m成正比，即m=αa.令a=πL，m=2n,∴α=2n/(πL)，又相交概率P=n/m，所以联立&lt;br&gt;$$ \pi =\frac{2Pa}{L} $$    &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;概率密度函数法&lt;/strong&gt;&lt;br&gt;另一种方式根据概率，针中点距离最近的一条线的距离x和与线成的角度y服从独立分布，其中x∈[0,L/2],y∈[0,π/2].相交的情况就是.P(x,y)=X&amp;lt;a×cos(y)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$f(x,y)=\left\{\begin{matrix}&lt;br&gt;\frac{4}{m}&amp;amp; 0&amp;lt;x&amp;lt;\frac{a}{2},0&amp;lt;y&amp;lt;\frac{\pi }{2} \\&lt;br&gt;0 &amp;amp; Others&lt;br&gt;\end{matrix}\right.$$&lt;/p&gt;
&lt;p&gt;$$f(x,y)=\left\{\begin{matrix}&lt;br&gt;\frac{4}{m}&amp;amp;&amp;amp; 0&amp;lt;x&amp;lt;\frac{a}{2},0&amp;lt;y&amp;lt;\frac{\pi }{2} \\&lt;br&gt;0 &amp;amp;&amp;amp; Others&lt;br&gt;\end{matrix}\right.$$&lt;/p&gt;
&lt;p&gt;16-08-29&lt;br&gt;py的机器学习包调用的好的好简单啊。。数据清洗和筛选都很舒服。。&lt;/p&gt;
&lt;p&gt;关于Java集合框架(JCF)，主要的接口和类有：&lt;br&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/08/29/57c452fde4a68.png&quot; alt=&quot;JCF&quot;&gt;&lt;br&gt;List下面都有提到，现在主要来讨论Set和Queue。值得一提的是，Set其实是一种特殊的Map。将键和值都赋为相同的值，Set为Map的一种适配器模式，即只实现了想实现的功能，其他Map的功能我不要。同时，由于在JDK1.6以后，Deque实现了双向链表的功能，也封装了顶部加入和弹出、底部加入和弹出的功能，实际完成了Stack的基本操作，所以Stack基本被Deque取代了。可以将Deque看做实现了基本所有优先队列功能的接口，其唯一实现类是LinkedList(它继承自AbstractList，因为也带有List基本的功能，好屌啊).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个很重要&lt;/strong&gt;&lt;br&gt;下图为集合框架的实现方式。&lt;br&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/08/29/57c45a1026983.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;可以看到，LinkedList几乎即实现了双链表又实现了List集合的功能；而基于红黑树的TreeMap和TreeSet能在O(lg(n))时间内完成数据的插入、删除、查找等基本操作。而链表和数组不同方式实现了的List则对于插入和删除有显而易见不同的时间复杂度。LinkedHash两者并存也是神奇的存在，一个Map里，在哈希表的slot里面插入同一位置的使用链表存放，并把链表尾端链到下一个有值的槽的键值上。。虽然很好用，但是，大量的数据需要开很大的空间来存放指针。&lt;/p&gt;
&lt;p&gt;集合框架都能使用.hasNext函数来使用迭代器进行遍历，当然，foreach大法也很好。&lt;/p&gt;
&lt;p&gt;16-08-28&lt;br&gt;近日复习了机器学习线性回归和Logistic回归。前者只需记住j(Θ)的推导和最终结论$$\theta =(X^{T}X)^{-1}X^{T}Y$$或者$$\theta =(X^{T}X+\lambda I)^{-1}X^{T}Y$$即可；为了排除求逆的复杂度则进行梯度下降也是极好。    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Batch（批量梯度下降）&lt;br&gt;$$ \theta_{j} += \alpha \sum^m_{i=1}(y^i-h_\theta(x^{(i)}))x^{(i)}_j$$&lt;br&gt;其中α是步长(学习因子)，h为Θ相关的预测，xy均已知，该方法每步需迭代所有数据&lt;/li&gt;
&lt;li&gt;stachastic（随机梯度下降）&lt;br&gt;$$ \theta_j += \alpha (y^i-h_\theta(x^{(i)}))x^{(i)}_j$$&lt;br&gt;同上类似 但每步只加入一个数据进行梯度计算迭代。&lt;/li&gt;
&lt;li&gt;mini batch（结合上俩式结合一小部分的数据进行迭代而非全部也不是一个）&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;回归不适用于分类，尤其是多分类。原理回归曲线的点会严重影响回归函数。&lt;/li&gt;
&lt;li&gt;局部加权回归是在求解梯度时在求和部分加入一个ω函数，使得残杀服从某种分布，一般选择ω为高斯核函数。&lt;/li&gt;
&lt;li&gt;J(Θ)采用的是似然函数求取极值的方式来计算参数；回归时很可能需要先验知识对数据加入某一特征的二次、三次作为新的特征来拟合回归函数。    &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;16-08-25&lt;br&gt;复习leetcode的一些基本题。两个排序数组取中值的，这个真心想了好久。虽知道是分支，但就是解决不好头尾和递推条件。还有很经典的子数组max和，子数组max积，股票买卖那几个动归的问题。单独拿那个取中值的说一下。&lt;/p&gt;
&lt;p&gt;这个算法最直接的当阿然是O(n)把排序数组重合。与快拍里面的一小节类似。但是要更快，就需要更好的思维过程了。&lt;/p&gt;
&lt;p&gt;想到分治必然是划分小区间，然而已经有两段了如何划分更 .0小的区间，一划就成4个了。然而转念一想，取中值，必然是两组里面分别小于中值的和两组里面分别大于中值的共四组。设A B倆数组，长度分别是m,n.约定划分在i∈[0,m-1],j∈[0,n-1]。这样，AB分为了左右两组，&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Left&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Right&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;A[0]~A[i]&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;A[i+1]~B[m-1]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;B[0]~B[j]&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;B[j+1]~B[n-1]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;当且仅当以下条件满足时，找到了合适的i和j。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A[i]&amp;lt;B[j+1]且B[j]&amp;lt;A[i+1] (即保证严格左堆小于又堆)&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;16-08-24&lt;br&gt;关于高并发 synchronized可以针对&lt;strong&gt;静态函数 实例方法和类对象&lt;/strong&gt;进行阻塞。当访问到里临界区资源时，不但不能写入，同时亦不能读取，防止读取到副本而做出超出预计的运算。HashMap和ArrayList在多线程时一定不能用。    &lt;/p&gt;
&lt;p&gt;针对synchronized很方便的加锁方式，重入锁可以很好的完全替代它。它的主要作用有在中断时给予响应，对某锁申请限制时间的等待，给与申请锁的线程公平的获得机会（防止饥饿产生）。其主要的方法有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lock()获得锁 如果已被占用则等待。&lt;/li&gt;
&lt;li&gt;lockInterruptibly()获得锁，但有响应则优先&lt;/li&gt;
&lt;li&gt;tryLock()尝试获得锁，获得失败直接返回false，获得成功则返回true&lt;/li&gt;
&lt;li&gt;tryLock(long time,TimeUnit unit)一个参数表示长度，一个参数表示单位。限定时间内尝试获得锁。&lt;/li&gt;
&lt;li&gt;unLock()释放锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而使用condition来配合完成wait和notify操作。&lt;/p&gt;
&lt;p&gt;16-08-22&lt;/p&gt;
&lt;h3 id=&quot;关于ArrayList与Vector&quot;&gt;&lt;a href=&quot;#关于ArrayList与Vector&quot; class=&quot;headerlink&quot; title=&quot;关于ArrayList与Vector&quot;&gt;&lt;/a&gt;关于ArrayList与Vector&lt;/h3&gt;&lt;p&gt;同步性及线程安全不同、自增方式不同；底层均基于数组（Object[]）实现，可随机访问，查询增删效率相同。&lt;br&gt;List&lt;t&gt;接口有三个实现类，ArrayList、Vector、LinkedList。前两个基于数组实现，物理位置应该是连续的；LinkedList类似C语言的链表，删除时，查询效率是O(i),i为index,而删除时指针改变效率为O(1).而两者查询效率为O(1),删除时效率为O(n-i).&lt;br&gt;LinkedList通过双链表维护，因而可以轻易的转换为栈和队列（Stack Queue Deque）等优先队列的结构。&lt;br&gt;要得到一个同步的LinkedList可以使用同步封装器实现,从Collections.synchronizedList(List)得到。但Vector就不需要进行额外的调用，尤其是在访问和更新。    &lt;/t&gt;&lt;/p&gt;
&lt;p&gt;LinkedList定义了专门用于表头和表尾操作的方法。Vector提供了indexOf(obj,start)接口，arrayList没有这个。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;List和Map中，只有Vector和HashTable能维护高效的同步&lt;/strong&gt;&lt;br&gt;List的继承链大致为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;+--java.util.Collection[I](集合框架接口)
   +--java.util.List[I](存放一类元素 可重复 有序 以下三者均继承自抽象类AbstractList，由其实现List接口。)
      +--java.util.ArrayList[C]
      +--java.util.LinkedList[C]
      +--java.util.Vector[C]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有的类要么继承自List要么继承自Set，不能直接实现Collection。&lt;br&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/08/22/57bbc0d99a834.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AbstractList&lt;/strong&gt;是一个抽象类，继承自&lt;strong&gt;AbstractCollection&lt;/strong&gt;,AbstractList实现了除size()和get(int location)之外的函数。LinkedList与正常基于数组的不同，其通过AbstractSequentialList这一抽象类继承了AbstractList并额外添加了对链表的各项操作，又实现了Deque接口而完成了双向链表的功能。可以看到，&lt;strong&gt;Queue和Deque的唯一实现类都是LinkedList&lt;/strong&gt;.Stack该类继承自Vector，完成了先进后出的操作。&lt;/p&gt;
&lt;h3 id=&quot;关于线程安全&quot;&gt;&lt;a href=&quot;#关于线程安全&quot; class=&quot;headerlink&quot; title=&quot;关于线程安全&quot;&gt;&lt;/a&gt;关于线程安全&lt;/h3&gt;&lt;p&gt;线程安全的类 ，指的是&lt;strong&gt;类内共享的全局变量的访问必须保证是不受多线程形式影响的&lt;/strong&gt;。&lt;br&gt;多线程保持原子性、可见性、有序性（涉及指令重排）&lt;/p&gt;
&lt;p&gt;16-08-21&lt;br&gt;复习了小顶堆 大顶堆的插入。以树为逻辑以数组为存储的结构。初始化第一个位置置为null或者0.插入在末尾进行heapUp,删除替换末尾进行heapDown,排序也是进行heapDown的操作。    &lt;/p&gt;
&lt;p&gt;16-08-20&lt;br&gt;TreeMap是基于红黑树的SortedMap的实现。SortedMap是基于键的大小自动运行比较器的Map集合框架，正规的实现该接口必须包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不含餐的构造函数 插入时按照键自然顺序排序&lt;/li&gt;
&lt;li&gt;实现一个comparatot的构造函数 按照比较器给定的顺序排序。该比较器应定义良好。&lt;/li&gt;
&lt;li&gt;带Map的构造函数 创建参数相同的有序映射 按照自然顺序排序&lt;/li&gt;
&lt;li&gt;带有序映射类型的构造函数，使其顺序、比较方式、键值映射关系与给定有序映射类型相同&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其修改不是同步的，不是线程安全的。所以尽量在创建时完成这一操作，或使用Collections集合的同步方法，如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;  Map m = Collections.synchronizedMap(new TreeMap(...));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他：key不可以为空，value可为空；相同值的插入会覆盖前面的。&lt;br&gt;16-08-20&lt;br&gt;心疼李宗伟&lt;br&gt;复习了树的前驱后继的求法。求前有左求后有右都好求，关键的是相反的话，需要记录最接近的拐点，同时记录父母亲（如果是向的树），这样可以避免中序遍历的O(N)时间复杂度而变成O(lg(N))的二分查找复杂度。&lt;/p&gt;
&lt;p&gt;16-08-18&lt;br&gt;复习了非递归树的遍历 主要是栈的应用。利用单队列 双队列实现层次遍历。树的旋转还是容易变化，删除操作里的三种情况也要记住。删除二儿子节点找到前驱或者后继（右子树最左 左子树最右）并替换之，并按照一儿子或者0儿子的删除将该节点删除。&lt;/p&gt;
&lt;p&gt;16-08-17&lt;br&gt;tire树几个特征：适用单词（短语）模糊推荐 N叉树-多基于单词分叉-每个节点独设标记位记录是否为单词节点   一些方案中记录共用该节点单词数（非到叶子路径数）使得查询时间复杂度O(lg(kN)).k为当前查询字符长度 N为最多分支数。&lt;br&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/08/18/57b5962f1d2d2.gif&quot; alt=&quot;trie树&quot;&gt;    &lt;/p&gt;
&lt;p&gt;尝试一下 有道的网页笔试 其中一道题是分两摞的洗牌问题。从上到下1、2……N标号的纸牌，各取一半，左下取一张，右下取一张，左下取第二张，右下取第二张……以此类推，和正常洗牌类似，求k次洗牌后的顺序。牌堆编号给出。例如1,2,3,4,5,6洗一次后变为4,1,5,2,6,3.额。。。尝试了暴力求解 但是应该能有什么规律似的。尝试给每张牌记录是否存在的记号，还是略微痛苦。    &lt;/p&gt;
&lt;p&gt;接近刷完了算法导论的课程，更多的接近于概率论的算法证明课。收获的很扎实，但是还是书看的快，权当是复习算法的内涵和合理性部分了。&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: Learn sth. the other day&lt;br&gt;date: 2016-08-18 18:58:03&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;learn&lt;br&gt;categories:&lt;/li&gt;
&lt;li&gt;学习log&lt;/li&gt;
&lt;/ul&gt;
&lt;h
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git的小tips</title>
    <link href="http://ovjaywang.github.io/2016/06/14/git%E7%9A%84%E5%B0%8Ftips/"/>
    <id>http://ovjaywang.github.io/2016/06/14/git的小tips/</id>
    <published>2016-06-14T12:59:12.000Z</published>
    <updated>2016-06-15T02:00:41.867Z</updated>
    
    <content type="html">&lt;p&gt;Git是当下最流行最舒适的版本控制系统。这里大致把git容易忘记的事情做小结。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Git-Tips&quot;&gt;&lt;a href=&quot;#Git-Tips&quot; class=&quot;headerlink&quot; title=&quot;Git Tips&quot;&gt;&lt;/a&gt;Git Tips&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Git的机制&quot;&gt;&lt;a href=&quot;#Git的机制&quot; class=&quot;headerlink&quot; title=&quot;Git的机制&quot;&gt;&lt;/a&gt;Git的机制&lt;/h2&gt;&lt;p&gt;记录每次commit的快照及镜像，而非版本增量。完全的分布式及提倡多分支非线性开发。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类似CVS Subversion记录次提交时更新的文件及更新了哪些内容。&lt;/li&gt;
&lt;li&gt;Git则将快照记录在微型文件系统中，并使用指针(索引)指向当前快照以区别版本。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Git每次提交不必联网 大部分操作在本地完成 只在完成一部分功能或需要共享时提交远程仓库 节约了流量 提升了效率 无网络状态亦可提交更新及浏览历史。&lt;/p&gt;
&lt;h2 id=&quot;Git的四个状态&quot;&gt;&lt;a href=&quot;#Git的四个状态&quot; class=&quot;headerlink&quot; title=&quot;Git的四个状态&quot;&gt;&lt;/a&gt;Git的四个状态&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;!http://ooo.0o0.ooo/2016/06/14/57600bfe92c91.png&quot;&gt;Git的四个状态&lt;/a&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未追逐 新添加之前未有版本信息的文件 将未追踪的添加到版本管理使用&lt;strong&gt;add&lt;/strong&gt;命令&lt;/li&gt;
&lt;li&gt;已追踪有三类（已修改 未修改 已暂存）&lt;/li&gt;
&lt;li&gt;未修改 一个时间点做了快照之后未修改的就是未修改 只要做出任意改动就会变成&lt;/li&gt;
&lt;li&gt;已修改 此时若修正好 需要把文件添加到暂缓存区 同样使用&lt;strong&gt;add&lt;/strong&gt; 命令&lt;/li&gt;
&lt;li&gt;已暂存 此时暂时存储在内存中 需要把它永久的存在硬盘的git本地系统中 使用&lt;strong&gt;commit&lt;/strong&gt;提交命令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用下命令显示本目录下的文件跟踪情况&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;git status
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用下命令查看修改和比较两个版本差异&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;git diff
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;跟踪一个有趣的远程仓库&quot;&gt;&lt;a href=&quot;#跟踪一个有趣的远程仓库&quot; class=&quot;headerlink&quot; title=&quot;跟踪一个有趣的远程仓库&quot;&gt;&lt;/a&gt;跟踪一个有趣的远程仓库&lt;/h2&gt;&lt;p&gt;其实要做的只是 copy下来；过一段时间、知道它有更新的时候就pull一下，拉取下来&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;git clone git://github.com/[user_name]/[project_name].git
..
git pull origin project_name
## 或者
git fetch origin project_name
git merge
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;键入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;git remote show origin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以查看到以下几个关键的东西&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;local branch pushed with ‘git push’ 缺省推送分支&lt;/li&gt;
&lt;li&gt;caching 那些远端分支还未同步到本地&lt;/li&gt;
&lt;li&gt;stale tracking branches那些分支已经在远端被删除&lt;/li&gt;
&lt;li&gt;Remote branch merged with ‘git pull’ while on branch  git pull时自动合并那些分支&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;小逼格&quot;&gt;&lt;a href=&quot;#小逼格&quot; class=&quot;headerlink&quot; title=&quot;小逼格&quot;&gt;&lt;/a&gt;小逼格&lt;/h2&gt;&lt;h3 id=&quot;加标签&quot;&gt;&lt;a href=&quot;#加标签&quot; class=&quot;headerlink&quot; title=&quot;加标签&quot;&gt;&lt;/a&gt;加标签&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;git tag [tag_name] #写入tag
git tag #显示所有tag
git show [tag_name] -lw #显示某个tag名字的提交
git tag -a [tag_name] [commit_code] #给忘记添加标记的提交起个标签
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;查看日志&quot;&gt;&lt;a href=&quot;#查看日志&quot; class=&quot;headerlink&quot; title=&quot;查看日志&quot;&gt;&lt;/a&gt;查看日志&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;git log 
e.g. 
git log --pretty=format:&amp;quot;%h - %an, %ar : %s&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上式以一个很优美的显示方案：哈希字符串、对象、时间、提交的说明 一行一个提交显示。&lt;br&gt;对于可显示选项，可选用下表备用词。&lt;/p&gt;
&lt;table class=&quot;table table-bordered table-striped table-condensed&quot;&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;选项 &lt;/td&gt;&lt;br&gt;        &lt;td&gt;说明&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;-p &lt;/td&gt;&lt;br&gt;        &lt;td&gt;按补丁格式显示每个更新之间的差异。&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;–word-diff &lt;/td&gt;&lt;br&gt;        &lt;td&gt;按 word diff 格式显示差异。&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;–stat &lt;/td&gt;&lt;br&gt;        &lt;td&gt;显示每次更新的文件修改统计信息。&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;–shortstat &lt;/td&gt;&lt;br&gt;        &lt;td&gt;只显示 –stat 中最后的行数修改添加移除统计。&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;–name-only &lt;/td&gt;&lt;br&gt;        &lt;td&gt;仅在提交信息后显示已修改的文件清单。&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;–name-status &lt;/td&gt;&lt;br&gt;        &lt;td&gt;显示新增、修改、删除的文件清单。&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;–abbrev-commit &lt;/td&gt;&lt;br&gt;        &lt;td&gt;仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;–relative-date &lt;/td&gt;&lt;br&gt;        &lt;td&gt;使用较短的相对时间显示（比如，“2 weeks ago”）。&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;–graph &lt;/td&gt;&lt;br&gt;        &lt;td&gt;显示 ASCII 图形表示的分支合并历史。&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;–pretty &lt;/td&gt;&lt;br&gt;        &lt;td&gt;使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;–oneline &lt;/td&gt;&lt;br&gt;        &lt;td&gt;–pretty=oneline –abbrev-commit 的简化用法。&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;&lt;/table&gt;&lt;br&gt;而对于pretty中的格式，可以自由设定，如下表标注。&lt;br&gt;&lt;table&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;选项 &lt;/td&gt;&lt;br&gt;        &lt;td&gt;说明&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%H &lt;/td&gt;&lt;br&gt;        &lt;td&gt;提交对象（commit）的完整哈希字串&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%h &lt;/td&gt;&lt;br&gt;        &lt;td&gt;提交对象的简短哈希字串&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%T &lt;/td&gt;&lt;br&gt;        &lt;td&gt;树对象（tree）的完整哈希字串&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%t &lt;/td&gt;&lt;br&gt;        &lt;td&gt;树对象的简短哈希字串&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%P &lt;/td&gt;&lt;br&gt;        &lt;td&gt;父对象（parent）的完整哈希字串&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%p &lt;/td&gt;&lt;br&gt;        &lt;td&gt;父对象的简短哈希字串&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%an &lt;/td&gt;&lt;br&gt;        &lt;td&gt;作者（author）的名字&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%ae &lt;/td&gt;&lt;br&gt;        &lt;td&gt;作者的电子邮件地址&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%ad &lt;/td&gt;&lt;br&gt;        &lt;td&gt;作者修订日期（可以用 -date= 选项定制格式）&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%ar &lt;/td&gt;&lt;br&gt;        &lt;td&gt;作者修订日期，按多久以前的方式显示&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%cn &lt;/td&gt;&lt;br&gt;        &lt;td&gt;提交者(committer)的名字&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%ce &lt;/td&gt;&lt;br&gt;        &lt;td&gt;提交者的电子邮件地址&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%cd &lt;/td&gt;&lt;br&gt;        &lt;td&gt;提交日期&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%cr &lt;/td&gt;&lt;br&gt;        &lt;td&gt;提交日期，按多久以前的方式显示&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%s &lt;/td&gt;&lt;br&gt;        &lt;td&gt;提交说明&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;&lt;/table&gt;

&lt;h2 id=&quot;自动补全-命令别名&quot;&gt;&lt;a href=&quot;#自动补全-命令别名&quot; class=&quot;headerlink&quot; title=&quot;自动补全-命令别名&quot;&gt;&lt;/a&gt;自动补全-命令别名&lt;/h2&gt;&lt;p&gt;相当酷炫而有用。直接看&lt;a href=&quot;http://www.fenby.com/courses/sections/ji-qiao-he-qiao-men/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;Git是当下最流行最舒适的版本控制系统。这里大致把git容易忘记的事情做小结。&lt;br&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://ovjaywang.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>位运算各种</title>
    <link href="http://ovjaywang.github.io/2016/05/12/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%90%84%E7%A7%8D/"/>
    <id>http://ovjaywang.github.io/2016/05/12/位运算各种/</id>
    <published>2016-05-12T03:12:00.000Z</published>
    <updated>2016-05-31T06:34:17.728Z</updated>
    
    <content type="html">&lt;p&gt;最近发现位运算在很多场合有很多运用啊。大概有以下几个方面:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;涉及二进制及其2^n进制的运算&lt;/li&gt;
&lt;li&gt;很少字段的struct class的改写例如棋盘记录和模式比较&lt;/li&gt;
&lt;li&gt;逼格&amp;amp;效率比较高的小心机&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;几个运算符&quot;&gt;&lt;a href=&quot;#几个运算符&quot; class=&quot;headerlink&quot; title=&quot;几个运算符&quot;&gt;&lt;/a&gt;几个运算符&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;符号&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;名称&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;按位亦或&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;同为0，异为1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$\mid $&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;按位或&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;有1则1，双0为0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;按位与&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;有0则0，双为1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;~&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;按位取反&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;变1为0，变0为1（包含符号位）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;按位左移（包括符号）&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;二进制每移一位乘二,最右补零&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;按位右移（包括符号）&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;二进制每移一位除二,无符号最左补零，有符号补符号位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;`&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;按位无符号右移&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;对应二进制全指定的位数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以上均是按位操作，要区分逻辑运算&lt;code&gt;&amp;amp;&amp;amp; ||&lt;/code&gt;和位运算符&lt;code&gt;&amp;amp; |&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;关于取反&quot;&gt;&lt;a href=&quot;#关于取反&quot; class=&quot;headerlink&quot; title=&quot;关于取反&quot;&gt;&lt;/a&gt;关于取反&lt;/h1&gt;&lt;p&gt;普通的Integer char等按位操作都是直接按照它们的二进制补码操作，int直接使用该数字的补码，char则先按照ascii转换成二进制在进行操作。&lt;br&gt;e.g.&lt;code&gt;char a = &amp;#39;a&amp;#39;&lt;/code&gt;a的ascii码十进制为097，二进制原码为1100001，这里注意，作为char，它在java中是一个&lt;font color=&quot;red&quot;&gt;无符号16位的整数&lt;/font&gt;，所以补齐它的&lt;br&gt;二进制原码 补码 反码（非负数原码 补码 反码相同）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;000000000 1100001&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;取反后的补码&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;111111111 0011110&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;取反后的反码&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;111111111 0011101&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;取反后的源码&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;100000000 1100010&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;十进制即为 &lt;strong&gt;-98&lt;/strong&gt;。&lt;br&gt;同理的，byte如果存储字符型也是按照先转成ascii码进行操作，即便是字符型的数字也一样。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;byte a = 2;
int b = ~a;//输出b为-3
byte c = &amp;#39;2&amp;#39;;
int d = ~c;//输出d为-51 2的ascii为50(十进制) 32(十六进制)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;关于亦或&quot;&gt;&lt;a href=&quot;#关于亦或&quot; class=&quot;headerlink&quot; title=&quot;关于亦或&quot;&gt;&lt;/a&gt;关于亦或&lt;/h1&gt;&lt;p&gt;亦或相当的特别同时阴森啊，有几个性质&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a^a = 0 也就是亦或自己为0，因为每位都是相同的。&lt;/li&gt;
&lt;li&gt;a^a^a = a^0 = 0^a  = a&lt;/li&gt;
&lt;li&gt;a^b = b^a 符合交换律&lt;/li&gt;
&lt;li&gt;(a^b)^c = a^(b^c) 符合结合律&lt;/li&gt;
&lt;li&gt;e = a^b^c^d &amp;lt;-&amp;gt; e^a = b^c^d &amp;lt;-&amp;gt; e^a^b= c^d &amp;lt;-&amp;gt; e^a^b^c=d&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然满足交换律结合律，则如果出现这么一种情况，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[一个数组里除了一个数值出现一次，其他都出现了两次。找出这个数值。]&lt;br&gt;将这个数组全部亦或一遍，则出现两次的都可以按照交换律结合律化为0，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;数组内只存在两个奇数次出现的数，其他都出现了偶数次，找出这两个数&quot;&gt;&lt;a href=&quot;#数组内只存在两个奇数次出现的数，其他都出现了偶数次，找出这两个数&quot; class=&quot;headerlink&quot; title=&quot;数组内只存在两个奇数次出现的数，其他都出现了偶数次，找出这两个数&quot;&gt;&lt;/a&gt;数组内只存在两个奇数次出现的数，其他都出现了偶数次，找出这两个数&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;思路：这就是上面实例的改进，因为知道了其他数字都出现了偶数次，全体亦或的结果就是&lt;code&gt;x=a^b&lt;/code&gt; 其中a b分别是所要找的这两个数。由于a b不同，则x必然不为零，也必然存在为1的位（可以取从右第一次出现1的位置）。同时由于是亦或操作，这个1必然是a和b相异造成的。这样，把这一位为1的分一组，这一位为0的分一组，出现偶数次的依然会被分到一组通过亦或自己消除。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;    //从右寻找补码中1第一次出现的位置
    public static int getFirst1(int num){
        int index = 0;
        while(index&amp;lt;32){//Integer有32位
            if(((num&amp;amp;(1&amp;lt;&amp;lt;index))^(1&amp;lt;&amp;lt;index))==0)
                return index+1;
            else
                index++;
        }
        return -1;
    }

    //判断这个数这一位是否为1
    public static boolean is1AtPos(int num,int pos){    
        return ((num&amp;gt;&amp;gt;(pos-1))&amp;amp;1)==1;
    }

    //寻找这两个数
    public static int[] get2Num(int[] a){
        int [] find2Num = new int[2];
        //默认初始化0
        int rs = 0;
        for (int i : a) {
            rs ^= i;//亦或全体求x
        int pos=getFirst1(rs);//寻找第一个出现1的位
        for (int j : a) {
            if(is1AtPos(j,pos))//按这位是否位1分组
                find2Num[0] ^= j;
            else
                find2Num[1] ^= j;           
        }
        System.out.println(find2Num[0]+&amp;quot; &amp;quot;+find2Num[1]);
        return find2Num;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;使用位亦或-节约空间的数据交换&quot;&gt;&lt;a href=&quot;#使用位亦或-节约空间的数据交换&quot; class=&quot;headerlink&quot; title=&quot;使用位亦或^节约空间的数据交换&quot;&gt;&lt;/a&gt;使用位亦或^节约空间的数据交换&lt;/h2&gt;&lt;p&gt;原理：a亦或b=c，b亦或a=c，也就是亦或满足交换律；位亦或的逆运算，也就是&lt;code&gt;(a^b)^b=a&lt;/code&gt;等于它自己。所以，只需三个亦或运算即可交换数据。看代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    a ^= b;
    b ^= a;
    a ^= b;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;使用亦或加密&quot;&gt;&lt;a href=&quot;#使用亦或加密&quot; class=&quot;headerlink&quot; title=&quot;使用亦或加密&quot;&gt;&lt;/a&gt;使用亦或加密&lt;/h2&gt;&lt;p&gt;中文配合亦或加密再加上其他的一些加密算法可以很好的掩护原文。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        char  a1=&amp;#39;晚&amp;#39; ,  a2=&amp;#39;上&amp;#39; ,  a3=&amp;#39;来&amp;#39; ,  a4=&amp;#39;我&amp;#39;,  a5=&amp;#39;家&amp;#39; ; 
        char secret=&amp;#39;8&amp;#39; ; 
        a1=(char) (a1^secret); 
        a2=(char) (a2^secret); 
        a3=(char) (a3^secret); 
        a4=(char) (a4^secret); 
        a5=(char) (a5^secret); 
        System.out.println(&amp;quot;密文:&amp;quot;+a1+a2+a3+a4+a5); 
        a1=(char) (a1^secret); 
        a2=(char) (a2^secret); 
        a3=(char) (a3^secret); 
        a4=(char) (a4^secret); 
        a5=(char) (a5^secret); 
        System.out.println(&amp;quot;原文:&amp;quot;+a1+a2+a3+a4+a5);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;亦或判别IP地址是否相等&quot;&gt;&lt;a href=&quot;#亦或判别IP地址是否相等&quot; class=&quot;headerlink&quot; title=&quot;亦或判别IP地址是否相等&quot;&gt;&lt;/a&gt;亦或判别IP地址是否相等&lt;/h2&gt;&lt;p&gt;使用亦或在加上按位与的方式比==加&amp;amp;&amp;amp;的方式效率高。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    static int ipv6_addr_equal(int[] in6_addr_a1, int[] in6_addr_a2)
    {
    return (((in6_addr_a1[0] ^ in6_addr_a2[0]) |
        (in6_addr_a1[1] ^ in6_addr_a2[1]) |
        (in6_addr_a1[2] ^ in6_addr_a2[2]) |
        (in6_addr_a1[3] ^ in6_addr_a2[3])) == 0);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;关于按位与&quot;&gt;&lt;a href=&quot;#关于按位与&quot; class=&quot;headerlink&quot; title=&quot;关于按位与&quot;&gt;&lt;/a&gt;关于按位与&lt;/h1&gt;&lt;p&gt;按位与操作一般是与1配合 判断奇偶，或者判断某位是否为1；或保留下某位位数字(与位移结合)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a&amp;amp;1 == 0    偶数
a&amp;amp;1 == 1    奇数
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;关于按位与-1&quot;&gt;&lt;a href=&quot;#关于按位与-1&quot; class=&quot;headerlink&quot; title=&quot;关于按位与&quot;&gt;&lt;/a&gt;关于按位与&lt;/h1&gt;&lt;p&gt;按位或操作一般与0配合 &lt;/p&gt;
&lt;h1 id=&quot;按位左右移&quot;&gt;&lt;a href=&quot;#按位左右移&quot; class=&quot;headerlink&quot; title=&quot;按位左右移&quot;&gt;&lt;/a&gt;按位左右移&lt;/h1&gt;&lt;p&gt;左右移本质上就是以bit为单元进行二进制的操作，而二进制左右移n位在十进制就意味着乘以2^n或除以2^n.按位操作可以大大提升效率&lt;br&gt;港真，很多面试都有求幂的题目。很棒，刷题狗就喜欢做这种题，然而第一次碰到这题我懵逼的采用了树。傻缺了。&lt;/p&gt;
&lt;p&gt;将二进制数绕圈循环，取往左(右)第k个为头。很多题目里面有啊&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;int a = a&amp;lt;&amp;lt;k | a &amp;gt;&amp;gt; (Integer.SIZE-k); //左数第k个当头
int b = b&amp;gt;&amp;gt;k | b &amp;gt;&amp;gt; (Integer.SIZE-k); //右数第k个当头
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第k位置1&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;    a|(1&amp;lt;&amp;lt;k);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第k位置0&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    a&amp;amp;(~(1&amp;lt;&amp;lt;k));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;取第k位的数值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    a&amp;gt;&amp;gt;k&amp;amp;1;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;后k位为0，其余为1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    (~0)&amp;amp;(1&amp;lt;&amp;lt;(k+1));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;后k位为1，其余为0&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    ~((~0)&amp;lt;&amp;lt;k);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;左右移应用-二分求幂&quot;&gt;&lt;a href=&quot;#左右移应用-二分求幂&quot; class=&quot;headerlink&quot; title=&quot;左右移应用-二分求幂&quot;&gt;&lt;/a&gt;左右移应用-二分求幂&lt;/h2&gt;&lt;p&gt;&lt;strong&gt; &lt;font color=&quot;red&quot;&gt;Caution！这个思想很重要!&lt;/font&gt;&lt;/strong&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;思路：求a^b，如果b是一个2的整数幂，举个栗子，32，那可以进行这样的迭代，由于$32=2^5$,那么就可以这样求，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;第一次求 $a_1=a^2$  &lt;/li&gt;
&lt;li&gt;第二次求 $a_2=a^4=a^{2*2}={a_1}^2$  &lt;/li&gt;
&lt;li&gt;第三次求 $a_3=a^8=a^{4*2}={a_2}^2$  &lt;/li&gt;
&lt;li&gt;第四次求 $a_4=a^{16}=a^{8*2}={a_3}^2$&lt;/li&gt;
&lt;li&gt;第五次求 $a_5=a^{32}=a^{16*2}={a_4}^2$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果是通过迭代幂的次数，需要32次才能达到，然而通过分治的方式，只需要5次就能解算32次幂。那如果不是2的整数幂次方呢，很好办，通过将该整数分解成各个2的整数次幂的和，例如求取a的23次方,又$23=16+4+2=1$，所以原式可化为$a^{2^4+2^2+2^1+2^0}$,通过二分的方式，变形为$$(a^{16})\cdot (a^4)\cdot (a^1)\cdot (a^0)$$.&lt;br&gt;显然！上式就是二进制和十进制转换的过程，通过4+2+1=7次计算就可解出，而非单循环的23次。&lt;br&gt;其实，解算a的16次方中，即可用到$${a^4}^{2^2}$$,即计算a^的16次方只需用到2步，总共2+2+1=5次迭代就可计算完毕。&lt;br&gt;因而解决a^b次幂的步骤是  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将幂次化为2进制  &lt;/li&gt;
&lt;li&gt;从低位遍历，为1则乘以当前幂次，为0则计算当前幂次，然后跳过，直接移至下一位  &lt;/li&gt;
&lt;li&gt;当幂指数的二进制推到最高位  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;    public static long Power(int a, int n){
        long ans = 1;
        System.out.println(&amp;quot;幂指数二进制：&amp;quot;+Integer.toBinaryString(n));
        while (n &amp;gt; 0) {
            if ((n &amp;amp; 1)!=0) {//末位不为零
                ans *= a;
            } 
            a *= a;//计算当前幂次
            n &amp;gt;&amp;gt;= 1;//迭代每次推一位
        }
        return ans;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;递归版本可能更清晰&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;    public static int power(int a,int n)  {  
        if(n==1) return a;  
        if(n&amp;amp;1)  
          return power(a,n-1) * a;  
        else  
        {  
            int t=power(a,n&amp;gt;&amp;gt;1);  
            return t*t;  
        }  
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面还有更&lt;strong&gt;炸裂&lt;/strong&gt;的&lt;/p&gt;
&lt;h2 id=&quot;利用位移求二进制里1的奇偶&quot;&gt;&lt;a href=&quot;#利用位移求二进制里1的奇偶&quot; class=&quot;headerlink&quot; title=&quot;利用位移求二进制里1的奇偶&quot;&gt;&lt;/a&gt;利用位移求二进制里1的奇偶&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;一般的思路就是，一位一位截末位，为1则亦或一下，为0则不管。对于Integer需要循环32次，对byte需要循环8次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1数量为奇则返回1，为偶数则返回0。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;    public static int get11Count(int x){
            int i=0;
            for(int j =0 ;j&amp;lt;32;j++){
                if((x&amp;amp;1)==1)
                    i ^= x&amp;amp;1;  
                x &amp;gt;&amp;gt;= 1;
            }
            return i;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;但四，这个方式没有体现位移的优越性。通过分治的思想，由于结果只求1或0，那么通过1位表达2位的信息，通过2位表达4位的信息，通过4位表达8位的信息，通过8位表达16位的信息，通过16位表达32位的信息。通过五次&lt;strong&gt;表达&lt;/strong&gt;，就可以求出结果。&lt;br&gt;最关心的，其实只是&lt;font color=&quot;red&quot;&gt;最后一位&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先看代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;    public static int get1Count(int x){
    //返回二进制数有偶数还是奇数个1 偶数返回0 奇数返回1
            x = x ^ (x &amp;gt;&amp;gt; 1);
            x = x ^ (x &amp;gt;&amp;gt; 2);
            x = x ^ (x &amp;gt;&amp;gt; 4);
            x = x ^ (x &amp;gt;&amp;gt; 8);
            x = x ^ (x &amp;gt;&amp;gt; 16);
        return x&amp;amp;1;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;解析一下。先拿byte举个栗子。因为byte是1个字节8个bit，所以表达-128~127即$-2^7\sim 2^7$.按照上面的方式，只需右移三次.举个例子88，二进制为$2^6+2^4+2^3=1011000$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一次&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        01011000
        00101100
    xor --------
        01110100  -&amp;gt;这个是结果！
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果的数值含义是，将原式中，这一位i与该位的上一位(即第i+1位)做了一次亦或，&lt;font color=&quot;red&quot;&gt;结果式中每出现一个1，则代表原式中必然邻位相异。&lt;/font&gt;其实，由于最终结果只需要表述奇偶，因此两个1为0，等同于抵消的含义。&lt;/p&gt;
&lt;p&gt;第二次亦或&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        01110100
        00011101
    xor --------
        01101001 —&amp;gt;第二次的结果
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果的含义是，每一个数字1表示##原式##中，每一位与其前3位二进制数值中1的个数为奇数；每一个数字0表示##原式##中，每一位与其前3位二进制数值中1的个数为0.&lt;/p&gt;
&lt;p&gt;第三次亦或&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
        01101001
        00000110
    xor --------
        01101111 -&amp;gt;第三次结果
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;显而易见，每个1的出现表示与其前7个数字1出现奇数次。&lt;br&gt;最后取最后一位&lt;code&gt;x&amp;amp;1&lt;/code&gt;,得到1，即原式中有奇数次1.结果正确。&lt;/p&gt;
&lt;h2 id=&quot;进阶-计算二进制1的个数&quot;&gt;&lt;a href=&quot;#进阶-计算二进制1的个数&quot; class=&quot;headerlink&quot; title=&quot;进阶-计算二进制1的个数&quot;&gt;&lt;/a&gt;进阶-计算二进制1的个数&lt;/h2&gt;&lt;h3 id=&quot;最原始的方式&quot;&gt;&lt;a href=&quot;#最原始的方式&quot; class=&quot;headerlink&quot; title=&quot;最原始的方式&quot;&gt;&lt;/a&gt;最原始的方式&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;    int BitCount(unsigned int n)
    {
        unsigned int c =0 ; // 计数器
        while (n &amp;gt;0)
        {
            if((n &amp;amp;1) ==1) // 当前位是1
                ++c ; // 计数器加1
            n &amp;gt;&amp;gt;=1 ; // 移位
        }
        return c ;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;原始方式的改进&quot;&gt;&lt;a href=&quot;#原始方式的改进&quot; class=&quot;headerlink&quot; title=&quot;原始方式的改进&quot;&gt;&lt;/a&gt;原始方式的改进&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;    int BitCount1(unsigned int n)
    {
        unsigned int c =0 ; // 计数器
        for (c =0; n; n &amp;gt;&amp;gt;=1) // 循环移位
            c += n &amp;amp;1 ; // 如果当前位是1，则计数器加1
        return c ;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;亦或清1法&quot;&gt;&lt;a href=&quot;#亦或清1法&quot; class=&quot;headerlink&quot; title=&quot;亦或清1法&quot;&gt;&lt;/a&gt;亦或清1法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;int BitCount2(unsigned int n)
{
    unsigned int c =0 ;
    for (c =0; n; ++c)
    {
        n &amp;amp;= (n -1) ; // 清除最低位的1
    }
    return c ;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;查表法1：&quot;&gt;&lt;a href=&quot;#查表法1：&quot; class=&quot;headerlink&quot; title=&quot;查表法1：&quot;&gt;&lt;/a&gt;查表法1：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;int BitCount3(unsigned int n) 
{ 
    // 建表
    unsigned char BitsSetTable256[256] = {0} ; 

    // 初始化表 
    for (int i =0; i &amp;lt;256; i++) 
    { 
        BitsSetTable256[i] = (i &amp;amp;1) + BitsSetTable256[i /2]; 
    } 

    unsigned int c =0 ; 

    // 查表
    unsigned char* p = (unsigned char*) &amp;amp;n ; 

    c = BitsSetTable256[p[0]] + 
        BitsSetTable256[p[1]] + 
        BitsSetTable256[p[2]] + 
        BitsSetTable256[p[3]]; 

    return c ; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;查表法2：4bit查表&quot;&gt;&lt;a href=&quot;#查表法2：4bit查表&quot; class=&quot;headerlink&quot; title=&quot;查表法2：4bit查表&quot;&gt;&lt;/a&gt;查表法2：4bit查表&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;int BitCount4(unsigned int n)
{
    unsigned int table[16] = 
    {
        0, 1, 1, 2, 
        1, 2, 2, 3, 
        1, 2, 2, 3, 
        2, 3, 3, 4
    } ;

    unsigned int count =0 ;
    while (n)
    {
        count += table[n &amp;amp;0xf] ;
        n &amp;gt;&amp;gt;=4 ;
    }
    return count ;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;查表法3：8bit查表&quot;&gt;&lt;a href=&quot;#查表法3：8bit查表&quot; class=&quot;headerlink&quot; title=&quot;查表法3：8bit查表&quot;&gt;&lt;/a&gt;查表法3：8bit查表&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;int BitCount7(unsigned int n)
{ 
    unsigned int table[256] = 
    { 
        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
        4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 
    }; 

    return table[n &amp;amp;0xff] +
        table[(n &amp;gt;&amp;gt;8) &amp;amp;0xff] +
        table[(n &amp;gt;&amp;gt;16) &amp;amp;0xff] +
        table[(n &amp;gt;&amp;gt;24) &amp;amp;0xff] ;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###炸裂的平行算法&lt;br&gt;邻位相加，重复这一过程，直到只剩一位。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    #include &amp;lt;stdio.h&amp;gt;
    #include &amp;lt;iostream&amp;gt;

    using namespace std;

    int main(int argc, char *argv[]) {
        int x;
        while (cin &amp;gt;&amp;gt; x) {
            x = (x &amp;amp; 0x55555555) + ((x &amp;gt;&amp;gt; 1) &amp;amp; 0x55555555);
            x = (x &amp;amp; 0x33333333) + ((x &amp;gt;&amp;gt; 2) &amp;amp; 0x33333333);
            x = (x &amp;amp; 0x0F0F0F0F) + ((x &amp;gt;&amp;gt; 4) &amp;amp; 0x0F0F0F0F);
            x = (x &amp;amp; 0x00FF00FF) + ((x &amp;gt;&amp;gt; 8) &amp;amp; 0x00FF00FF);
            x = (x &amp;amp; 0x0000FFFF) + ((x &amp;gt;&amp;gt; 16) &amp;amp; 0x0000FFFF);
            cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; endl;
        }
        return 0;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###终极大招&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int BitCount5(unsigned int n) 
{
    unsigned int tmp = n - ((n &amp;gt;&amp;gt;1) &amp;amp;033333333333) - ((n &amp;gt;&amp;gt;2) &amp;amp;011111111111);
    return ((tmp + (tmp &amp;gt;&amp;gt;3)) &amp;amp;030707070707) %63;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;补充：位标志法&quot;&gt;&lt;a href=&quot;#补充：位标志法&quot; class=&quot;headerlink&quot; title=&quot;补充：位标志法&quot;&gt;&lt;/a&gt;补充：位标志法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;struct _byte 
{ 
    unsigned a:1; 
    unsigned b:1; 
    unsigned c:1; 
    unsigned d:1; 
    unsigned e:1; 
    unsigned f:1; 
    unsigned g:1; 
    unsigned h:1; 
}; 

long get_bit_count( unsigned char b ) 
{
    struct _byte *by = (struct _byte*)&amp;amp;b; 
    return (by-&amp;gt;a+by-&amp;gt;b+by-&amp;gt;c+by-&amp;gt;d+by-&amp;gt;e+by-&amp;gt;f+by-&amp;gt;g+by-&amp;gt;h); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;求二进制最高位前0的个数&quot;&gt;&lt;a href=&quot;#求二进制最高位前0的个数&quot; class=&quot;headerlink&quot; title=&quot;求二进制最高位前0的个数&quot;&gt;&lt;/a&gt;求二进制最高位前0的个数&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;int nlz(unsigned x)
{
   int n;

   if (x == 0) return(32);
   n = 1;
   if ((x &amp;gt;&amp;gt; 16) == 0) {n += 16; x &amp;lt;&amp;lt;= 16;}
   if ((x &amp;gt;&amp;gt; 24) == 0) {n += 8; x &amp;lt;&amp;lt;= 8;}
   if ((x &amp;gt;&amp;gt; 28) == 0) {n += 4; x &amp;lt;&amp;lt;= 4;}
   if ((x &amp;gt;&amp;gt; 30) == 0) {n += 2; x &amp;lt;&amp;lt;= 2;}
   n = n - (x &amp;gt;&amp;gt; 31);
   return n;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;二进制逆序&quot;&gt;&lt;a href=&quot;#二进制逆序&quot; class=&quot;headerlink&quot; title=&quot;二进制逆序&quot;&gt;&lt;/a&gt;二进制逆序&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;int change(int x)
{
    x = (x &amp;amp; 0x55555555) &amp;lt;&amp;lt; 1 | (x &amp;amp; 0xAAAAAAAA) &amp;gt;&amp;gt; 1;
    x = (x &amp;amp; 0x33333333) &amp;lt;&amp;lt; 2 | (x &amp;amp; 0xCCCCCCCC) &amp;gt;&amp;gt; 2;
    x = (x &amp;amp; 0x0F0F0F0F) &amp;lt;&amp;lt; 4 | (x &amp;amp; 0xF0F0F0F0) &amp;gt;&amp;gt; 4;
    x = (x &amp;amp; 0x00FF00FF) &amp;lt;&amp;lt; 8 | (x &amp;amp; 0xFF00FF00) &amp;gt;&amp;gt; 8;
    x = (x &amp;amp; 0x0000FFFF) &amp;lt;&amp;lt; 16 | (x &amp;amp; 0xFFFF0000) &amp;gt;&amp;gt; 16;
    return x;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;位移求绝对值&quot;&gt;&lt;a href=&quot;#位移求绝对值&quot; class=&quot;headerlink&quot; title=&quot;位移求绝对值&quot;&gt;&lt;/a&gt;位移求绝对值&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;x xor (not (x shr 31) + 1) + x shr 31
x = x ^ ((~(x&amp;gt;&amp;gt;31))+1) + x&amp;gt;&amp;gt;31;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;交换二进制高16位和低16位&quot;&gt;&lt;a href=&quot;#交换二进制高16位和低16位&quot; class=&quot;headerlink&quot; title=&quot;交换二进制高16位和低16位&quot;&gt;&lt;/a&gt;交换二进制高16位和低16位&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;int change(int x)
{
   return (x &amp;gt;&amp;gt; 16) | (x &amp;lt;&amp;lt; 16);
   //byte可写成(x &amp;gt;&amp;gt; 4) | (x &amp;lt;&amp;lt; 4);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考链接：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.lijinma.com/blog/2014/05/29/amazing-xor/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.lijinma.com/blog/2014/05/29/amazing-xor/&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/graphics/archive/2010/06/21/1752421.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/graphics/archive/2010/06/21/1752421.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;最近发现位运算在很多场合有很多运用啊。大概有以下几个方面:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;涉及二进制及其2^n进制的运算&lt;/li&gt;
&lt;li&gt;很少字段的struct class的改写例如棋盘记录和模式比较&lt;/li&gt;
&lt;li&gt;逼格&amp;amp;效率比较高的小心机&lt;/li&gt;
&lt;/ul&gt;

    
    </summary>
    
      <category term="代码狗" scheme="http://ovjaywang.github.io/categories/%E4%BB%A3%E7%A0%81%E7%8B%97/"/>
    
      <category term="学习log" scheme="http://ovjaywang.github.io/categories/%E4%BB%A3%E7%A0%81%E7%8B%97/%E5%AD%A6%E4%B9%A0log/"/>
    
    
      <category term="BitManipulattion" scheme="http://ovjaywang.github.io/tags/BitManipulattion/"/>
    
  </entry>
  
  <entry>
    <title>jQuery的三个坑</title>
    <link href="http://ovjaywang.github.io/2016/05/10/jQuery%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9D%91/"/>
    <id>http://ovjaywang.github.io/2016/05/10/jQuery的两个坑/</id>
    <published>2016-05-09T17:23:30.000Z</published>
    <updated>2016-05-12T03:13:22.340Z</updated>
    
    <content type="html">&lt;p&gt;许久没用jquery，今天碰到三个坑。小记一下&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;第一个是live()这个函数，在学习很早的资料，表示用来为被选元素附加一个或多个事件处理程序,形式为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;$(selector).live(event,data,function)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如为button绑定一个单击事件，event为事件名，data为可选的传参，function为自定义函数。&lt;br&gt;测了半天没开F12一直以为代码有问题，，后来一看原来jquery1.9+以上不支持live了。先改成了delegate代理，后来又改成on,真特么烦人。  &lt;/p&gt;
&lt;p&gt;应该值得注意到的是，改成on后，触发的事件在容器对象上，而live返回值在事件触发的对象上。&lt;br&gt;&lt;a href=&quot;http://jquery.com/upgrade-guide/1.9/#live-removed&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;是官方解释&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;一直以为&lt;code&gt;$(selector)&lt;/code&gt;能抓到所有的id啊。。。原来好像dom树的id不能明明一样的。（但在1.4-版本测试是可以的，不知道是改进了对id选择器的定义和方法加载，明确了id唯一这个特征）&lt;br&gt;要对类似的组件操作类似的方法，例如对tr表单下的td采用同个样式，a使用类似的连接，可以使用&lt;code&gt;$(.class)&lt;/code&gt;的方式获取。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;jquery1.9+以后不支持.attr属性的设置了，改成了.prop .妈蛋啊怎么改这么多好烦啊简直排错都不知道什么bug&lt;br&gt;炸裂看看1.9+的&lt;a href=&quot;http://www.ppblog.cn/jquery1-9live.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;更新&lt;/a&gt;  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;true false两个选项的属性用prop&lt;/li&gt;
&lt;li&gt;添加属性名称该属性就生效用prop&lt;/li&gt;
&lt;li&gt;其他可以用attr&lt;/li&gt;
&lt;/ol&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;许久没用jquery，今天碰到三个坑。小记一下&lt;br&gt;
    
    </summary>
    
      <category term="代码狗" scheme="http://ovjaywang.github.io/categories/%E4%BB%A3%E7%A0%81%E7%8B%97/"/>
    
      <category term="学习log" scheme="http://ovjaywang.github.io/categories/%E4%BB%A3%E7%A0%81%E7%8B%97/%E5%AD%A6%E4%B9%A0log/"/>
    
    
      <category term="jQuery" scheme="http://ovjaywang.github.io/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>树系列码集合[持更20160517]</title>
    <link href="http://ovjaywang.github.io/2016/05/03/%E6%A0%91%E7%B3%BB%E5%88%97%E7%A0%81%E9%9B%86%E5%90%88-%E6%8C%81%E6%9B%B4/"/>
    <id>http://ovjaywang.github.io/2016/05/03/树系列码集合-持更/</id>
    <published>2016-05-03T15:06:28.000Z</published>
    <updated>2016-05-18T02:48:10.913Z</updated>
    
    <content type="html">&lt;p&gt;本文持更树操作集合-码狗学习中&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;二叉查找树转双链表（c-）&quot;&gt;&lt;a href=&quot;#二叉查找树转双链表（c-）&quot; class=&quot;headerlink&quot; title=&quot;二叉查找树转双链表（c++）&quot;&gt;&lt;/a&gt;二叉查找树转双链表（c++）&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;需求就是一个二叉树查找树 ，要转成按顺序排列的双向链表&lt;/p&gt;
&lt;p&gt;思路差不多就是：中序可以按顺序输出；左儿子指针指向相邻小的，右儿子指针指向相邻大的；相邻由中序控制,左右儿子改动的时候寄存在pre(前驱)和root(当前)下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;关键代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义模版类及head pre指针&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;    template&amp;lt;class T&amp;gt;                  //模版结构体
    struct TreeNode
    {
        T data;                       //节点的内容
        TreeNode &amp;lt;T&amp;gt; *Lchild, *Rchild,*pParent; //节点的左子树和右子树
    //可选择参数的默认构造函数
    TreeNode(T nodeValue = T(), TreeNode&amp;lt;T&amp;gt; *leftNode = NULL, TreeNode&amp;lt;T&amp;gt; *rightNode = NULL, TreeNode&amp;lt;T&amp;gt; *parentNode = NULL)
    :data(nodeValue),Lchild(leftNode),Rchild(rightNode),pParent(parentNode){}
    };

    TreeNode&amp;lt;int&amp;gt; * pHead =NULL;//存放头指针
    TreeNode&amp;lt;int&amp;gt; * previous = NULL;//存放前驱
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;核心转换代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;    template&amp;lt;class T&amp;gt;
    void Tranverse(TreeNode&amp;lt;T&amp;gt; * root)//记前序
    {
        if (root){
            Tranverse(root-&amp;gt;Lchild);//很明显的中序遍历阿！
            if (previous){
                if (!pHead){//这个if可以不写啊 只是为了记录头结点而已
                    pHead = previous;
                }
                previous-&amp;gt;Rchild = root;//前驱的右指针指向root
                root-&amp;gt;Lchild = previous;//root的左指针指向前驱
            }
            previous = root;//前驱跑到下一个更新
            Tranverse(root-&amp;gt;Rchild);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用代码,我才懒得写insert代码啊，rootNode从哪里来的我也不管啊&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c+&quot;&gt;    Tranverse(rootNode);
    while (pHead != NULL){
        cout &amp;lt;&amp;lt; pHead-&amp;gt;data &amp;lt;&amp;lt; endl;
        pHead = pHead-&amp;gt;Rchild;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码见&lt;a href=&quot;https://github.com/ovjaywang/TreeInvolved/tree/master/BSTree2DoubleLinkList&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;  &lt;/p&gt;
&lt;h1 id=&quot;在二叉查找树里查找范围内数据-c&quot;&gt;&lt;a href=&quot;#在二叉查找树里查找范围内数据-c&quot; class=&quot;headerlink&quot; title=&quot;在二叉查找树里查找范围内数据(c++)&quot;&gt;&lt;/a&gt;在二叉查找树里查找范围内数据(c++)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;二叉查找树对于范围查找效率比普通线性查找效率高，Point仍旧是中序按序输出。&lt;/p&gt;
&lt;p&gt;思路：这次换一个c语言方式类typedef定义二叉树模版，以二叉按次序找到下限第一个，然后其后的数据与最大最小值比较，在范围内就输出。因此，在二叉查找树中序输出中中，加两个判断条件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进入左子树需要根节点比最小值大  &lt;/li&gt;
&lt;li&gt;进入右子树需要根节点比最大值小&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;类模版定义&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;typedef int KeyType;
typedef struct TreeNode
{
    KeyType key;          //关键字
    struct TreeNode * left;   //左孩子指针
    struct TreeNode * right;  //右孩子指针
    struct TreeNode * parent; //指向父节点指针
}TreeNode, *PNode;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关键代码 以范围搜索&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;    set&amp;lt;KeyType&amp;gt; searchRange(KeyType min, KeyType max, set&amp;lt;KeyType&amp;gt; &amp;amp;vt, TreeNode *root){
        if (!root) return vt ;
        if (min &amp;lt; root-&amp;gt;key)
            searchRange(min, max, vt,root-&amp;gt;left);
        if (min &amp;lt;= root-&amp;gt;key &amp;amp;&amp;amp; max &amp;gt;= root-&amp;gt;key){
            vt.insert(root-&amp;gt;key);
        }
        if (max&amp;gt;root-&amp;gt;key)
            searchRange(min, max, vt,root-&amp;gt;right);
        return vt;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;    set&amp;lt;int&amp;gt; ss = set&amp;lt;int&amp;gt;();
    //很多地方都会把set带进函数迭代传递
    ss = searchRange(0, 3, ss, root);
    cout &amp;lt;&amp;lt; &amp;quot;vv.size() &amp;quot;&amp;lt;&amp;lt;ss.size()&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;&amp;quot;范围内包含节点有:&amp;quot;&amp;lt;&amp;lt;endl;
    for each (int item in ss)
    {
        cout &amp;lt;&amp;lt; item&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码见&lt;a href=&quot;https://github.com/ovjaywang/TreeInvolved/tree/master/FindInBSTree&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;输出-平衡-二叉树所有和为某值的路径&quot;&gt;&lt;a href=&quot;#输出-平衡-二叉树所有和为某值的路径&quot; class=&quot;headerlink&quot; title=&quot;输出(平衡)二叉树所有和为某值的路径&quot;&gt;&lt;/a&gt;输出(平衡)二叉树所有和为某值的路径&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;需求：一条路径就是从根到叶子所有节点，路径数就是叶子数。要输出所有满足路径上所有节点和为某值的路径。&lt;/p&gt;
&lt;p&gt;思路：为了保证效率，不能每次从头遍历到每个叶子才输出一次。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用栈压入根到当前节点的路径所有制，以便求和&lt;/li&gt;
&lt;li&gt;栈和超过值可以不继续寻找当前路径的儿子&lt;/li&gt;
&lt;li&gt;找一个儿子就在栈压入一个数值，跳回一个根就弹出一个儿子的值&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然，我很无聊，试一试平衡二叉(AVL).平衡二叉防止了直接建立查找二叉时候的随机，保证了时间复杂式始终在log(n).但建立AVL时候的插入删除代价也相对较大。&lt;/p&gt;
&lt;p&gt;AVL模版类的声明，多了一个height（高度）属性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;    template &amp;lt;class T&amp;gt;
    class AVLTreeNode{
    public:
        T key;                // 关键字(键值)
        int height;         // 高度
        AVLTreeNode *left;    // 左孩子
        AVLTreeNode *right;    // 右孩子
        //构造函数
        AVLTreeNode(T value, AVLTreeNode *l, AVLTreeNode *r) :
            key(value), height(0), left(l), right(r) {}
    };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;AVLtree类中包含了函数声明和一个&lt;code&gt;AVLTreeNode&amp;lt;T&amp;gt; *mRoot;&lt;/code&gt;作为根节点；一个public的函数&lt;code&gt;void SearchPath(const T value);&lt;/code&gt;给外部调用；一个private的函数&lt;code&gt;void SearchPath(AVLTreeNode&amp;lt;T&amp;gt;* root, T* seq, T top, T sumCount, const T value);&lt;/code&gt;作为自迭代的函数，传入当前节点指针，当前线性表指针，栈顶指针(栈压入的数目)，当前和以及目标值。&lt;/p&gt;
&lt;p&gt;关键代码，使用的是栈，但其实就是个顺序表，系统自动建立内存空间，每次进栈自增。&lt;br&gt;公有函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;    template&amp;lt;class T&amp;gt;
    void AVLTree&amp;lt;T&amp;gt;::SearchPath(const T value){
        T * seq = new int[0];
        T sumCount = 0;//当前累积值
        T top = 0;
        return SearchPath(mRoot, seq, top, sumCount, value);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;私有函数  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;    //遍历次序无所谓的 反正要遍历所有叶子
    template&amp;lt;class T&amp;gt;
    void AVLTree&amp;lt;T&amp;gt;::SearchPath(AVLTreeNode&amp;lt;T&amp;gt;* root, T* seq, T top, T sumCount, const T value)//按值传递回溯不用恢复参数值和栈顶  
    {
        seq[top++] = root-&amp;gt;key;//入栈
        sumCount += root-&amp;gt;key;//累加和
        //if(sumCount &amp;gt; value) return;//当值为正数时可加上这句话
        if (root-&amp;gt;left == NULL &amp;amp;&amp;amp; root-&amp;gt;right == NULL){//为叶子节点
            if (sumCount == value)
                for (int i = 0; i&amp;lt;top; i++)
                    cout &amp;lt;&amp;lt; seq[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        }
        else{
            if (root-&amp;gt;left)
                SearchPath(root-&amp;gt;left, seq, top, sumCount, value);
            if (root-&amp;gt;right)
                SearchPath(root-&amp;gt;right, seq, top, sumCount, value);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用代码  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;    AVLTree&amp;lt;int&amp;gt;* tree = new AVLTree&amp;lt;int&amp;gt;();
    int const value = 16;//目标和
    tree-&amp;gt;SearchPath(value);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码见&lt;a href=&quot;https://github.com/ovjaywang/TreeInvolved/tree/master/FindSumEqualNumInAVL&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;求树高的几种方式&quot;&gt;&lt;a href=&quot;#求树高的几种方式&quot; class=&quot;headerlink&quot; title=&quot;求树高的几种方式&quot;&gt;&lt;/a&gt;求树高的几种方式&lt;/h1&gt;&lt;p&gt;首先定义一波树结构属性名字&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;    typedef struct TreeNode{
        char data;
        struct TreeNode *lchild, *rchild;
    }TreeNode, *BiTree;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;后序遍历，栈求高，最大栈长度为树高&quot;&gt;&lt;a href=&quot;#后序遍历，栈求高，最大栈长度为树高&quot; class=&quot;headerlink&quot; title=&quot;后序遍历，栈求高，最大栈长度为树高&quot;&gt;&lt;/a&gt;后序遍历，栈求高，最大栈长度为树高&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;思路：进左右子则入栈，返回根节点则出栈。每次左右子树检查完毕就比较一次栈长度是否大于最大高度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;    int BT_high(BiTree T){
        BiTree p = T, r = NULL;
        int max = 0;//记录最大树高  
        stack&amp;lt;BiTree&amp;gt; s;//声明一个堆 存放树根节点
        while (p || !s.empty()){//节点非空且堆栈非空
            if (p != NULL){
                s.push(p);//入栈
                p = p-&amp;gt;lchild;
            }
            else{
                p = s.top();
                if (p-&amp;gt;rchild != NULL &amp;amp;&amp;amp; p-&amp;gt;rchild != r)
                //判断是否从右子树返回根
                    p = p-&amp;gt;rchild;
                else{//左右子树都算完了 比较一下
                    if (s.size()&amp;gt;max) max = s.size();//最大层次即为高度  
                    r = p;
                    s.pop();//出栈
                    p = NULL;
                }
            }
        }
        return max;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;层次遍历-层高即树高&quot;&gt;&lt;a href=&quot;#层次遍历-层高即树高&quot; class=&quot;headerlink&quot; title=&quot;层次遍历 层高即树高&quot;&gt;&lt;/a&gt;层次遍历 层高即树高&lt;/h2&gt;&lt;p&gt;层次遍历服用队列或堆栈效果更佳！  &lt;/p&gt;
&lt;h3 id=&quot;层次遍历-单数组&quot;&gt;&lt;a href=&quot;#层次遍历-单数组&quot; class=&quot;headerlink&quot; title=&quot;层次遍历-单数组&quot;&gt;&lt;/a&gt;层次遍历-单数组&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;思路：按层将树输入到数组，下标记下本层元素头尾，从头遍历到尾加入它们的儿子，不断循环&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;int BT_level_depth(BiTree T)
{
    if (!T)  return 0;
    BiTree p = T, Q[100];//队列
    int front = -1, rear = -1, last = 0, level = 0;
    //定义首指针 尾指针 上层尾元素 当前高度
    Q[++rear] = p;//入队列
    while (front&amp;lt;rear){
        p = Q[++front];//先设置本次循环的根
        if (p-&amp;gt;lchild)//加入根的左儿子 同时移动尾
            Q[++rear] = p-&amp;gt;lchild;
        if (p-&amp;gt;rchild)//加入根的右儿子 同时移动尾
            Q[++rear] = p-&amp;gt;rchild;
        if (front == last){//当头指针遍历完本层所有元素
            last = rear;
            level++;//层次+1  
        }
    }
    return level;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;层次遍历-双端队列&quot;&gt;&lt;a href=&quot;#层次遍历-双端队列&quot; class=&quot;headerlink&quot; title=&quot;层次遍历-双端队列&quot;&gt;&lt;/a&gt;层次遍历-双端队列&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;思路：按层将树输入到双端队列，一个队列记录上一层所有节点，另一个队列加入所有另一个队列的儿子，不断交替。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;int BT_level_depth222(BiTree T)
{
    int  max = 0;
    deque&amp;lt;TreeNode*&amp;gt; q_first, q_second;
    q_first.push_back(T);
    while (!q_first.empty()) {
        while (!q_first.empty()) {
            TreeNode *temp = q_first.front();
            q_first.pop_front();
            cout &amp;lt;&amp;lt; (int)temp-&amp;gt;data &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            if (temp-&amp;gt;lchild)
                q_second.push_back(temp-&amp;gt;lchild);
            if (temp-&amp;gt;rchild)
                q_second.push_back(temp-&amp;gt;rchild);
        }
        cout &amp;lt;&amp;lt; endl;
        max++;
        q_first.swap(q_second);
    }
    return max;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;递归求树高&quot;&gt;&lt;a href=&quot;#递归求树高&quot; class=&quot;headerlink&quot; title=&quot;递归求树高&quot;&gt;&lt;/a&gt;递归求树高&lt;/h2&gt;&lt;h3 id=&quot;后序递归带深度求高&quot;&gt;&lt;a href=&quot;#后序递归带深度求高&quot; class=&quot;headerlink&quot; title=&quot;后序递归带深度求高&quot;&gt;&lt;/a&gt;后序递归带深度求高&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;思路:后序遍历所有节点，递归调用并检查当前节点是否为最大值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;int max1 = 0;//树高  
int BT_depth1(BiTree T, int depth)
{
    if (T)
    {
        if (T-&amp;gt;lchild)
            BT_depth1(T-&amp;gt;lchild, depth + 1);
        if (T-&amp;gt;rchild)
            BT_depth1(T-&amp;gt;rchild, depth + 1);
    }
    if (depth&amp;gt;max1)
        max1 = depth;
    return depth;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;左右子树递归求树高&quot;&gt;&lt;a href=&quot;#左右子树递归求树高&quot; class=&quot;headerlink&quot; title=&quot;左右子树递归求树高&quot;&gt;&lt;/a&gt;左右子树递归求树高&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;思路： 求左右子树的高度，分别又把左右子树当做根求他们的子树。每次迭代返回当前左右子树高的那一个。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;int Height(BiTree T)
{
    if (T == NULL) return 0;
    else
    {
        int m = Height(T-&amp;gt;lchild);
        int n = Height(T-&amp;gt;rchild);
        return (m &amp;gt; n) ? (m + 1) : (n + 1);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码见&lt;a href=&quot;https://github.com/ovjaywang/TreeInvolved/tree/master/GetMaxDepth&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;本文持更树操作集合-码狗学习中&lt;br&gt;
    
    </summary>
    
      <category term="代码狗" scheme="http://ovjaywang.github.io/categories/%E4%BB%A3%E7%A0%81%E7%8B%97/"/>
    
      <category term="学习log" scheme="http://ovjaywang.github.io/categories/%E4%BB%A3%E7%A0%81%E7%8B%97/%E5%AD%A6%E4%B9%A0log/"/>
    
    
      <category term="code" scheme="http://ovjaywang.github.io/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>Svm初探</title>
    <link href="http://ovjaywang.github.io/2016/04/28/svm%E5%88%9D%E6%8E%A2/"/>
    <id>http://ovjaywang.github.io/2016/04/28/svm初探/</id>
    <published>2016-04-28T14:26:41.000Z</published>
    <updated>2016-04-28T15:16:56.004Z</updated>
    
    <content type="html">&lt;p&gt;待更……&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;待更……&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Effective Java 笔记--创建对象的几个Tips</title>
    <link href="http://ovjaywang.github.io/2016/04/27/effective-java-tips-of-create-object/"/>
    <id>http://ovjaywang.github.io/2016/04/27/effective-java-tips-of-create-object/</id>
    <published>2016-04-27T03:50:01.000Z</published>
    <updated>2016-04-28T15:23:29.022Z</updated>
    
    <content type="html">&lt;p&gt;第一章-创建和销毁对象 的一些 小tips&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;不希望被实例化-又不想抽象化&quot;&gt;&lt;a href=&quot;#不希望被实例化-又不想抽象化&quot; class=&quot;headerlink&quot; title=&quot;不希望被实例化 又不想抽象化&quot;&gt;&lt;/a&gt;不希望被实例化 又不想抽象化&lt;/h1&gt;&lt;p&gt;某些类不希望被实例化出毫无意义的对象 但不编写显示构造器类会自定义一个隐式无参的构造器 因此可以用一下方式，编写不能实例化的类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;
  public class UtilityClass{
    private UtilityClass(){
      throw new AssertionError();//直接抛出assert验证异常 好坏
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该构造器是私有的。其他类不能过访问（即使同包）。&lt;/p&gt;
&lt;h1 id=&quot;不要创建没必要的对象&quot;&gt;&lt;a href=&quot;#不要创建没必要的对象&quot; class=&quot;headerlink&quot; title=&quot;不要创建没必要的对象&quot;&gt;&lt;/a&gt;不要创建没必要的对象&lt;/h1&gt;&lt;p&gt;不可变的对象一定要重用（singleton）；重用绝逼不会变的对象（例如计时初始时间、例如物种的属性）。例如，实例化Person对象的时候判断是不是计划生育年代出生的，即判断出生年份是否在1983-2015年。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Person{
   private final Date birthDate;
   private static final Date BIRTH_START;
   //这俩参数都是不变的 为了对比出生时间 
   //没必要每次都创建一个日期对象，只在初始化时调用。
   private static final Date BIRTH_END; 

//静态块的方法 第一次声明Person对象时构建（不用实例化）
// 后面占用一块内存 不用再次创建
   static{
        Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(&amp;quot;GMT&amp;quot;));
        gmtCal.set(1983,Calendar.JANUARY,1,0,0,0);
        //这里对日期做了时区判断 
        //保证都是从某一客观时间点出生的
        BIRTH_START = gmtCal.getTime();
        gmtCal.set(2016,Calendar.JANUARY,1,0,0,0);
        //截止2015年年底 所以取2016年年初
        BIRTH_END = gmtCal.getTime();
   }

    public boolean isJiHuaShengYu(){
        return birthDate.compareTo(BIRTH_START) &amp;gt;=0 &amp;amp;&amp;amp;
            birthDate.compareTo(BIRTH_END) &amp;lt;=0;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果isJiHuaShengYu方法&lt;font color=&quot;red&quot;&gt;从未调用&lt;/font&gt;，这个方法就显得不合时宜了，这块静态块的内存就一直占着，因此，可以采用延时初始化的方式，在第一次调用该方法时调用。&lt;/p&gt;
&lt;p&gt;adapter适配器模式可以提供一个后备对象，使实例化次数减少（包括类适配器和对象适配器）；autoboxing自动装箱模式能够自动创建多余对象，所以尽量少用，而使用基本数据类型。&lt;/p&gt;
&lt;h2 id=&quot;适配器Adapter&quot;&gt;&lt;a href=&quot;#适配器Adapter&quot; class=&quot;headerlink&quot; title=&quot;适配器Adapter&quot;&gt;&lt;/a&gt;适配器Adapter&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;adapter工作场景&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;适配器模式工作场景是：给定的一个接口不满足需求，需要其一些功能与其他的接口或类配合使用.正如已经给了电压和充电插座，但是插座电压与设备工作电压，这是时候就需要一个转换接头。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;adapter分类 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般分为类适配器和对象适配器。&lt;strong&gt;类适配器&lt;/strong&gt;一般继承了给定接口的被适配类，同时拓展实现了标准的接口；而&lt;strong&gt;对象适配器&lt;/strong&gt;则直接关联，以委托的方式完成已知接口的特殊功能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;类适配器实例：Adaptee（已知的待适配的类） Target（目标类） Adapter（适配器类）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到，类适配器的方式通过继承或实现接口的方式，来传递某些功能或方法，以达到利用已知功能的目的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;
    // 已存在的、具有特殊功能、但不符合我们既有的标准接口的类
class Adaptee {
    public void specificRequest() {
        System.out.println(&amp;quot;被适配类具有 特殊功能...&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;
// 目标接口，或称为标准接口
interface Target {
    public void request();
}

// 具体目标类，只提供普通功能
class ConcreteTarget implements Target {
    public void request() {
        System.out.println(&amp;quot;普通类 具有 普通功能...&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;
// 适配器类，继承了被适配类，同时实现标准接口
class Adapter extends Adaptee implements Target{
    public void request() {
        super.specificRequest();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;
// 测试类
    public class Client {
        public static void main(String[] args) {
            // 使用普通功能类
            Target concreteTarget = new ConcreteTarget();
            concreteTarget.request();

            // 使用特殊功能类，即适配类
            Target adapter = new Adapter();
            adapter.request();
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;对象适配器实例 Adapter适配器类 被适配器同上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对象适配器则通过对被适配类实例化，通过其对象获取其中部分功能，委托这一实例来完成想要传递的方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
// 适配器类，直接关联被适配类，同时实现标准接口
class Adapter implements Target{
    // 直接关联被适配类
    private Adaptee adaptee;

    // 可以通过构造函数传入具体需要适配的被适配类对象
    public Adapter (Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    public void request() {
        // 这里是使用委托的方式完成特殊功能
        this.adaptee.specificRequest();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;
public class Client {
    public static void main(String[] args) {
        // 使用普通功能类
        Target concreteTarget = new ConcreteTarget();
        concreteTarget.request();

        // 使用特殊功能类，即适配类，
        // 需要先创建一个被适配类的对象作为参数
        Target adapter = new Adapter(new Adaptee());
        adapter.request();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考&lt;a href=&quot;http://haolloyin.blog.51cto.com/1177454/346128&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;##&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;autoboxing方式&lt;/p&gt;
&lt;/blockquote&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;第一章-创建和销毁对象 的一些 小tips&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo多客户端写作</title>
    <link href="http://ovjaywang.github.io/2016/04/27/hexo%E5%A4%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%86%99%E4%BD%9C/"/>
    <id>http://ovjaywang.github.io/2016/04/27/hexo多客户端写作/</id>
    <published>2016-04-27T03:50:01.000Z</published>
    <updated>2016-04-28T15:29:03.676Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;Hexo是很棒的静态博客，简单的安装配置即可专注写作。&lt;br&gt;但是强迫症就是很爱折腾。倘若：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主机烧了数据备份怎么破？&lt;/li&gt;
&lt;li&gt;换了系统想继续之前的写作怎么破?&lt;/li&gt;
&lt;li&gt;纯粹就是想多客户端写作怎么破？&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;我就纯属蛋疼的。喜欢在办公和休息的地方都写作；或者我一win本&lt;br&gt;一mac 都想写文章。但Hexo的静态部署的原则不像WordPress一样，能关联博客地址，利用数据库进行博客更新。好了，这里就来解决这个问题。┑(￣Д ￣)┍&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;Hexo写作的部署逻辑-amp-其他&quot;&gt;&lt;a href=&quot;#Hexo写作的部署逻辑-amp-其他&quot; class=&quot;headerlink&quot; title=&quot;Hexo写作的部署逻辑&amp;amp;其他&quot;&gt;&lt;/a&gt;Hexo写作的部署逻辑&amp;amp;其他&lt;/h1&gt;&lt;h2 id=&quot;Hexo的写作特点&quot;&gt;&lt;a href=&quot;#Hexo的写作特点&quot; class=&quot;headerlink&quot; title=&quot;Hexo的写作特点&quot;&gt;&lt;/a&gt;Hexo的写作特点&lt;/h2&gt;&lt;p&gt;Hexo最大特点就是静态博客，即部署到服务器的博客内容是静态写好的html（由markdown转义），而不像类似wordpress的数据都存放在服务器端数据库，每次更新即一次读写数据库的操作。所以如果需要更改博客内容、发布新内容，必须&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;更改源文件source文件夹下_post及其他各页面文件夹的md文件&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;hexo g&lt;/code&gt;或&lt;code&gt;hexo generate&lt;/code&gt;在public生成静态文件。&lt;/li&gt;
&lt;li&gt;利用&lt;code&gt;hexo-deployer-git&lt;/code&gt;插件及&lt;code&gt;hexo d&lt;/code&gt;命令将public的文件自动的部署到创建好的&lt;code&gt;user-name.github.io&lt;/code&gt;项目中。&lt;blockquote&gt;
&lt;p&gt;在github项目中可以看到，自动上传的只有public文件夹中的文件，包括以年份分类的静态页面文件夹、tag、categories及其他辅助css、js、img等，还有域名指引的CNAME和rss sitemap等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;在博客中看到更新的内容。当然，本地目录中，即存放了md源文件，也包含了生成的public文件。其实，本地并不需要public里的内容，只要有写作的源文件，generate一下就能生成。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Hexo的缺憾&quot;&gt;&lt;a href=&quot;#Hexo的缺憾&quot; class=&quot;headerlink&quot; title=&quot;Hexo的缺憾&quot;&gt;&lt;/a&gt;Hexo的缺憾&lt;/h2&gt;&lt;p&gt;那么问题来了，如果我在公司和贫民窟都想写作怎么办。总不能在两个本地仓库hexo init都部署到pages项目。在公司更新一篇blog里面全都是公司写的，然后回到地下室又写一篇更新又全是小黑屋的内容。  &lt;/p&gt;
&lt;p&gt;尽管Hexo让人专注写作，随时随地用md写一篇博，等到来到同步的机器才更新一次也让人很不爽。对于远程仓库只存放静态文件的方案，就想到了两个思路&lt;/p&gt;
&lt;h3 id=&quot;同步静态文件&quot;&gt;&lt;a href=&quot;#同步静态文件&quot; class=&quot;headerlink&quot; title=&quot;同步静态文件&quot;&gt;&lt;/a&gt;同步静态文件&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;新仓库同步静态文件-&amp;gt;hexo g生成静态文件-&amp;gt;合并静态文件-&amp;gt;hexo d部署&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;在两地分别hexo init建立hexo博客目录，在_config.yml中都部署到同一个远程仓库，在每次generate时，都先将远程仓库的静态文件同步下来（新建一个单独的folder专门用于同步静态文件）。请勿使用hexo博客中的public文件夹用于同步，每次generate会覆盖同名文件。若另一台主机曾做过修改并提交，这次修改的静态文件将被本地未修改的静态文件覆盖。具体操作：&lt;br&gt;第一次克隆远程hexo主分支：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git clone git@github.com:user-name/user-name.github.io.git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后每次hexo仓库发布首先在静态文件仓库获取远程仓库最新静态文件(无条件merge)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git pull origin master
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;在静态文件同步仓库中，将自上次部署后，本地修改过的静态文件&lt;strong&gt;删掉&lt;/strong&gt;（不记得怪我咯┑(￣Д ￣)┍）；同时在hexo blog仓库中&lt;code&gt;hexo -g&lt;/code&gt;生成本地静态文件。&lt;/li&gt;
&lt;li&gt;将剔除过期静态文件的public仓库中文件复制到hexo的public中。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;hexo -d&lt;/code&gt;部署&lt;blockquote&gt;
&lt;p&gt;以上步骤2中的删除操作是为了保证静态文件的数据都是最新的，保证博客内容的一致性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;同步源文件（大招）&quot;&gt;&lt;a href=&quot;#同步源文件（大招）&quot; class=&quot;headerlink&quot; title=&quot;同步源文件（大招）&quot;&gt;&lt;/a&gt;同步源文件（大招）&lt;/h3&gt;&lt;p&gt;想到上述方式需要进行2步骤的主要原因就是本地的源文件不同步，只能通过生成的静态文件进行合并的方式，为毛不将源文件同步呢？！参考&lt;a href=&quot;http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;的思路，同步源文件就是通过远程仓库对源文件融合统一。&lt;/p&gt;
&lt;h2 id=&quot;呵呵哒&quot;&gt;&lt;a href=&quot;#呵呵哒&quot; class=&quot;headerlink&quot; title=&quot;呵呵哒&quot;&gt;&lt;/a&gt;呵呵哒&lt;/h2&gt;&lt;p&gt;本文为了完成多客户端的同Hexo博的管理和发布，对ssh、git安装、Hexo安装、配置插件主题管理、域名绑定&lt;strong&gt;不涉及&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统不限制 &lt;/li&gt;
&lt;li&gt;是否写过博部署过没差&lt;/li&gt;
&lt;li&gt;最好Hexo3.X,2.X没试过出事自负&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;真·多客户端&quot;&gt;&lt;a href=&quot;#真·多客户端&quot; class=&quot;headerlink&quot; title=&quot;真·多客户端&quot;&gt;&lt;/a&gt;真·多客户端&lt;/h1&gt;&lt;h2 id=&quot;创建远程仓库&quot;&gt;&lt;a href=&quot;#创建远程仓库&quot; class=&quot;headerlink&quot; title=&quot;创建远程仓库&quot;&gt;&lt;/a&gt;创建远程仓库&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;对于没有进行创作的hexo博客，首先创建同名仓库，再创建一个hexo branch。此时俩分支都是空的  &lt;/li&gt;
&lt;li&gt;对于已经进行创作的hexo博客，直接创建一个hexo 分支。此时，hexo clone了master的静态文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;设置主分支&quot;&gt;&lt;a href=&quot;#设置主分支&quot; class=&quot;headerlink&quot; title=&quot;设置主分支&quot;&gt;&lt;/a&gt;设置主分支&lt;/h2&gt;&lt;p&gt;将hexo branch设为主分支，用于同步源文件；master branch作为静态文件的存放。（由于github pages会检索master分支作为该域名下的部署分支，因此必须把master名字保留）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/04/27/5720a2a70a238.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;同步远程仓库并初始化&quot;&gt;&lt;a href=&quot;#同步远程仓库并初始化&quot; class=&quot;headerlink&quot; title=&quot;同步远程仓库并初始化&quot;&gt;&lt;/a&gt;同步远程仓库并初始化&lt;/h2&gt;&lt;p&gt;在本地（包含第一次所有源文件的主机）新建一个文件夹（就算已经写过博客的也这么搞）同步远程仓库并初始化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone git@github.com:your-Id/your-Id.github.io.git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时输入&lt;code&gt;git branch&lt;/code&gt;可以看到两个分支，红色分支为主分支。&lt;br&gt;若是非空白博客，同步后需要先删掉里面的静态文件.直接删光，把原博客的文件全部复制过来&lt;strong&gt;（好像没有发现更换远程仓库主分支后本地同步更换的git bash。求解?）&lt;/strong&gt;;若是空白博客，那么需要再令建一个文件夹，（因为hexo init操作会覆盖原.git文件导致与远程仓库失联）在该文件夹git bash执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g hexo
hexo init
npm install
hexo g
npm install hexo-deployer-git--save
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;好了，里面该有的差不多都有了。全部复制到源文件仓库。&lt;strong&gt;注意把hello worl删掉啊。&lt;/strong&gt;关键的就是，config.yml里deployer的branch是master，而本地仓库关联的是hexo就对了。&lt;br&gt;然后执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
git commit -m &amp;quot;init&amp;quot;
git push -u origin hexo
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;值得注意的是，有的时候提示主题的文件夹并未加入同步操作，显示&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;
Changes not staged for commit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即主题文件夹的内容尚未有之前版本，应该加入tracked。应在提交前输入&lt;code&gt;git add themes/themes_name/&lt;/code&gt;.最后那个斜杠别忘了加。&lt;br&gt;这就完成源文件的同步了！(￣▽￣)”” 执行&lt;code&gt;hexo d&lt;/code&gt;操作将本地public静态文件部署。&lt;/p&gt;
&lt;h1 id=&quot;发博日常&quot;&gt;&lt;a href=&quot;#发博日常&quot; class=&quot;headerlink&quot; title=&quot;发博日常&quot;&gt;&lt;/a&gt;发博日常&lt;/h1&gt;&lt;h2 id=&quot;更博&quot;&gt;&lt;a href=&quot;#更博&quot; class=&quot;headerlink&quot; title=&quot;更博&quot;&gt;&lt;/a&gt;更博&lt;/h2&gt;&lt;p&gt;如果你不能确定是否抽风需要经常换客户端，因此需要每次都要同步本地源文件；如果能忍住，，或者有规律的换客户端，那么平时更新不需要经常同步。&lt;br&gt;写博前操作(&lt;strong&gt;特么狠重要啊&lt;/strong&gt;)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git pull origin hexo
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更新操作：(同步源文件到hexo分支)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
git commit -m &amp;quot;hehe&amp;quot;
git push origin hexo
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样每次更博都需要多几个步骤，嫌麻烦就要忍住不手痒了。在手机、pad写md再同步到电脑也是个不错的习惯。&lt;/p&gt;
&lt;h2 id=&quot;换客户端&quot;&gt;&lt;a href=&quot;#换客户端&quot; class=&quot;headerlink&quot; title=&quot;换客户端&quot;&gt;&lt;/a&gt;换客户端&lt;/h2&gt;&lt;p&gt;easy.只要远程仓库存在了一份完整的源文件，那同步就很容易了。似上步第一次同步，使用&lt;code&gt;git clone git@github.com:your-Id/your-Id.github.io.git&lt;/code&gt;拷贝仓库。然后执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g hexo
npm install
npm install hexo-deployer-git
&lt;/code&gt;&lt;/pre&gt;&lt;font color=&quot;red&quot;&gt;&lt;strong&gt;不用hexo init!!!&lt;/strong&gt;&lt;/font&gt;

&lt;h1 id=&quot;后记&quot;&gt;&lt;a href=&quot;#后记&quot; class=&quot;headerlink&quot; title=&quot;后记&quot;&gt;&lt;/a&gt;后记&lt;/h1&gt;&lt;h2 id=&quot;多地部署&quot;&gt;&lt;a href=&quot;#多地部署&quot; class=&quot;headerlink&quot; title=&quot;多地部署&quot;&gt;&lt;/a&gt;多地部署&lt;/h2&gt;&lt;p&gt;pacman的公式和代码支持好差啊~还有需要多地备份的可以尝试coding（page之前免费的现在要钱了 = =）.在站点部署文件中更改deploy：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;markdown&quot;&gt;deploy:
   type: git
   repo: 
      github: https://github.com/{YOUR_ID}/{YOUR_ID}.github.io.git,master
      coding: https://git.coding.net/{YOUR_ID}/{BLOG　NAME}.git,master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同理也能部署到自己的ftp服务器上。&lt;/p&gt;
&lt;h2 id=&quot;bug1-file-name-too-long&quot;&gt;&lt;a href=&quot;#bug1-file-name-too-long&quot; class=&quot;headerlink&quot; title=&quot;bug1 file-name-too-long&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt;bug1 file-name-too-long&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;在拷贝原始数据的时候，提交远程仓库时可能会报modules的文件夹无法同步。这个情况在windows下安装msysgit进行git bash会报这一问题。&lt;a href=&quot;https://github.com/msysgit/git/pull/110&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;也提到了这个异常。但这并不是git的问题，而是msysgit的问题。使用其他git方式对文件路径较长的提交就不会报错。实测在github for windows下提交该modules文件就不会报错。&lt;/p&gt;
&lt;h2 id=&quot;bug2-could-not-read-Username-for-‘https-XXX‘&quot;&gt;&lt;a href=&quot;#bug2-could-not-read-Username-for-‘https-XXX‘&quot; class=&quot;headerlink&quot; title=&quot;bug2 could not read Username for ‘https://XXX‘&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt;bug2 could not read Username for ‘&lt;a href=&quot;https://XXX&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://XXX&lt;/a&gt;‘&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;当需要推送另一台设备的静态文件时，可能极少情况会碰上这个问题。有的说是bash的版本问题，不识别这种方式的推送。然而我用的同一版本的msysgit..&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;http://stackoverflow.com/questions/20871549/error-when-push-commits-with-github-fatal-could-not-read-username&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;也发现了这个问题，尝试了一下使用在https中加入用户名和密码的方式能够良好的推送。。当然配置文件别泄露了。。更改配置文件的deploy如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;markdown&quot;&gt;deploy:
   type: git
   repo: 
      github: https://{YOUR_ID}:{Your_Pwd}@github.com/{YOUR_ID}/{YOUR_ID}.github.io.git,master
      coding: https://{YOUR_ID}:{Your_Pwd}@git.coding.net/{YOUR_ID}/{BLOG　NAME}.git,master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Enjoy Hexo!&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Hexo是很棒的静态博客，简单的安装配置即可专注写作。&lt;br&gt;但是强迫症就是很爱折腾。倘若：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主机烧了数据备份怎么破？&lt;/li&gt;
&lt;li&gt;换了系统想继续之前的写作怎么破?&lt;/li&gt;
&lt;li&gt;纯粹就是想多客户端写作怎么破？&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;我就纯属蛋疼的。喜欢在办公和休息的地方都写作；或者我一win本&lt;br&gt;一mac 都想写文章。但Hexo的静态部署的原则不像WordPress一样，能关联博客地址，利用数据库进行博客更新。好了，这里就来解决这个问题。┑(￣Д ￣)┍&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Effective Java--Builer构造器</title>
    <link href="http://ovjaywang.github.io/2016/04/22/effective%20java--builer%E6%9E%84%E9%80%A0%E5%99%A8/"/>
    <id>http://ovjaywang.github.io/2016/04/22/effective java--builer构造器/</id>
    <published>2016-04-22T09:10:48.000Z</published>
    <updated>2016-05-16T13:18:24.708Z</updated>
    
    <content type="html">&lt;p&gt;一个实体类往往有不同的属性 属性有的用于构造器 视为构造时的必需参数 而有的可有可无 类似json和xml一般，有多少个属性，每个属性有多少个赋值都不确定 。e.g.动物 名称string name和是否有尾巴istail是必须的，是否吃草iseatgrass 多重weight 交配手段sexmethod 科目等为非必须字段。解决这一构造问题一般有三种方式。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;可以采用不同的构造函数，一般的，把调用最多的构造出来，其余的按字段个数构造1-n个。诚然，有的字段并不需要，可能赋为空或者0。这样严重的影响了效率，同时字段多时构造函数也异常的多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;采用类似c#的方式 采用一个空字段构造器，使用setter和getter赋值和取值。这样的好处避免了过度的编写构造函数。但是在异步交互中，不能保证该对象的正确性和一致性。因此很可能需要冷冻。例如，名字叫草泥马的动物，是不具有排卵受精的性爱方式的。这样的setter不能及时维护数据的统一。又或者必须给予字段的动物名字和是否有尾巴在构造中并未赋值，造成的结果很可能在后面的调用中无法get到对应属性报异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;强悍的builder.在实体类中，再编写一个builder用于构造和赋值，必须的字段出现在构造函数中，需要赋值的字段在后面以.setter的方式调用，相当简洁高效，同时易于观察和修正。类似jQuery和python中一样。棒呆。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最丑的长字段实体类原本是这么写的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Animal{
    private string name;//必须参数
    private bool isTail;//必须参数
    private bool isEatGrass;//可选参数
    private double weight;//可选参数
    privaet int sexMethod;//可选参数

    Animal(string name,bool isTail)//这两个字段我特么就想要{
        this.name = name;
        this.isTail = isTail;
    }
    Animal(string name,bool isTail)//这两个字段我特么就想要{
        this.name = name;
        this.isTail = isTail;
    }
    Animal(string name,bool isTail,bool isEatGrass){
        this.name = name;
        this.isTail = isTail;
        this.isEatGrass = isEatGrass;
    }
    Animal(string name,bool isTail,bool isEatGrass,double weight){
        this.name = name;
        this.isTail = isTail;
        this.isEatGrass = isEatGrass;
        this.weight = weight;
    }
    Animal(string name,bool isTail,bool isEatGrass,double weight,int sexMe){
        this.name = name;
        this.isTail = isTail;
        this.isEatGrass = isEatGrass;
        this.weight = weight;
        this.sexMethon = sexMe;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在某处调用就可能是这样&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;Animal animal = new Animal(&amp;quot;caonima&amp;quot;,true,true,-1,3);
//由于我并不想知道体重，但又因为构造函数的关系不得不加上。
//所以相当繁琐。当字段达到几十个时，调用构造函数都分不清参数是否对应上。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​将上文的动物实体类以builder的方式写出来，大概是这样的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Animal{
    private final string name;
    private final bool isTail;
    private final bool isEatGrass;
    private final double weight;
    private final int sexMethod;

    public static class Builder{//类内嵌套的静态类，可以通过类名的类名调用构造函数
        private final string name;
        //注意这里 final只对必需字段定义 表明不可修改 区分不同对象
        private final bool isTail;
        //给非必需字段设置默认值
        private bool isEatGrass =false;
        private double weight = 0.0;
        privaet int sexMethod =1;
        public Builder(string name,bool isTail){
            //构造函数只取必需字段
            this.name = name;
            this.isTail = isTail;
        }
        public Builder setISEatGrass(bool isEatGrass){
            this.isEatGrass = isEatGrass;
            return this;
        }
        public Builder setISEatGrass(double weight){
            this.weight = weight;
            return this;
        }
        public Builder setSexMethod(int sexMetho){
            this.sexMetho = sexMetho;
            return this;
        }

        public Animal build(){//在builder类内声明一个构造器 返回animal对象
            return new Animal(this);
        }
    }
    //当然 在animal类的最后 也需要把builder的参数取出来
    private Animal(Builder builder){
        name = builder.name;
        isTail = builder.isTail;
        isEatGrass = builder.isEatGrass;
        weigth = builder.weigth;
        sexMethod = builder.sexMethod;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在某处构造该类对象时，即可像下面一样声明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    Animal dog = new Animal.Builder(&amp;quot;旺财&amp;quot;,true).setIsEatGrass(false).setSexMethod(3).setWeight(20.0)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;builder类似一个抽象工厂 客户端可以将这样一个builder传给方法，在方法中生成需要数量的对象。1.5+版本可以使用泛型定义。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Builder{
    public T build();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在类似生成二叉树，kd树的时候，往往用户只需要将数据push进入，然后调用一个builder整棵树就构造好了。这种方式往往类似于带限制通配符类型的builder.&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;还有一点值得注意的是，新增字段时，不比增加更多的构造函数 ！&lt;/p&gt;
&lt;p&gt;caution!&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;增加了类长度，当字段较多时才较好的使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建对象首先得创建构造器，在强调性能的地方会比较麻烦。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;一个实体类往往有不同的属性 属性有的用于构造器 视为构造时的必需参数 而有的可有可无 类似json和xml一般，有多少个属性，每个属性有多少个赋值都不确定 。e.g.动物 名称string name和是否有尾巴istail是必须的，是否吃草iseatgrass 多重weight 交配手段sexmethod 科目等为非必须字段。解决这一构造问题一般有三种方式。&lt;br&gt;
    
    </summary>
    
      <category term="代码狗" scheme="http://ovjaywang.github.io/categories/%E4%BB%A3%E7%A0%81%E7%8B%97/"/>
    
      <category term="学习log" scheme="http://ovjaywang.github.io/categories/%E4%BB%A3%E7%A0%81%E7%8B%97/%E5%AD%A6%E4%B9%A0log/"/>
    
    
      <category term="java" scheme="http://ovjaywang.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>删除Sdf文件导致转到定义失效</title>
    <link href="http://ovjaywang.github.io/2016/04/22/what-the-hell-of-sdf/"/>
    <id>http://ovjaywang.github.io/2016/04/22/what-the-hell-of-sdf/</id>
    <published>2016-04-22T08:38:11.000Z</published>
    <updated>2016-04-23T12:18:50.416Z</updated>
    
    <content type="html">&lt;p&gt;cmomit的时候发现一个&lt;strong&gt;.sdf&lt;/strong&gt;的文件特别大，项目才不到2m，一个sdf就30多m了。能不能删？&lt;br&gt;谷歌了一下，提示sdf文件和iph文件是存放预编译头和Intellisense的。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;预编译头是 c++下的.h和.hpp等需要调用的文件头&lt;br&gt;Intellisense是自动补齐和代码检测的文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;巨硬在&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/hcw1s69b.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;也给出了Intellisense的强大功效。&lt;/p&gt;
&lt;p&gt;在工具-&amp;gt;选项-&amp;gt;文本编辑器-&amp;gt;C/C++-&amp;gt;高级-&amp;gt;禁用数据库改为true。的确就能不生成了。&lt;br&gt;怒删了。居然?调试的时候转到定义（F12）失效了。自动补全和错误更正失效了。该选项的第一个表单Intellisense居然全都不能改变了。。。那么问题来了。我每次commit都需要删掉。然后每次又给我生成。烦躁。&lt;/p&gt;
&lt;p&gt;search到很多F12失效和类名找不到的，都很有可能是这个问题。即使，再次把禁用数据库false掉、把 工具-&amp;gt;选项-&amp;gt;项目和解决方案-&amp;gt;常规-&amp;gt;在解决方案资源管理器中跟踪活动项 反复勾选也没有用。呵呵哒。好险回收站里的sdf文件没有删。同时，这一更改在别的工程不会影响，只要sdf在就没事。&lt;/p&gt;
&lt;p&gt;解决方案：尝试每次删简直繁琐。在选项禁用数据库上面，可以改正sdf文件的存放位置。将始终使用退回位置设为true，把sdf删掉。使用一个每次不需要同步的文件夹，编译调试时能使用，又不影响git速度，棒呆。&lt;br&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/04/22/5719e9865cfc6.png&quot; alt=&quot;haha&quot;&gt;&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;cmomit的时候发现一个&lt;strong&gt;.sdf&lt;/strong&gt;的文件特别大，项目才不到2m，一个sdf就30多m了。能不能删？&lt;br&gt;谷歌了一下，提示sdf文件和iph文件是存放预编译头和Intellisense的。&lt;br&gt;
    
    </summary>
    
      <category term="什么都学一下" scheme="http://ovjaywang.github.io/categories/%E4%BB%80%E4%B9%88%E9%83%BD%E5%AD%A6%E4%B8%80%E4%B8%8B/"/>
    
      <category term="学习log" scheme="http://ovjaywang.github.io/categories/%E4%BB%80%E4%B9%88%E9%83%BD%E5%AD%A6%E4%B8%80%E4%B8%8B/%E5%AD%A6%E4%B9%A0log/"/>
    
    
      <category term="c++" scheme="http://ovjaywang.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java笔记--静态工厂和Builder模式</title>
    <link href="http://ovjaywang.github.io/2016/04/13/effective%20java--%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82/"/>
    <id>http://ovjaywang.github.io/2016/04/13/effective java--静态工厂/</id>
    <published>2016-04-13T07:15:14.000Z</published>
    <updated>2016-05-16T15:21:17.911Z</updated>
    
    <content type="html">&lt;h1 id=&quot;静态工厂&quot;&gt;&lt;a href=&quot;#静态工厂&quot; class=&quot;headerlink&quot; title=&quot;静态工厂&quot;&gt;&lt;/a&gt;静态工厂&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;    public static Boolean valueOf (boolean b){
        return b?Boolean.True:Boolean.False;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;静态工厂以其名字显见，以[类名.方法名]的方式调用，其静态函数主要返回其类的对象，一般是引用值。返回什么东西，由参数决定，这个工厂给你产出来。其在API开发中使用广泛。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;静态工厂最有趣的地方在于把方法&lt;strong&gt;提供者&lt;/strong&gt;同方法&lt;strong&gt;使用者&lt;/strong&gt;剥离开来，使用者不能明细地看到对象构造的具体过程，而是可见可得地获得所需的对象。当然好处有很多，例如返回的对象可以是该类的子类，能让被调用静态工厂方法的类不成为公有；例如有效的降低了构造对象的成本，静态工厂&lt;strong&gt;「&lt;/strong&gt;不生产对像，一般只是对象的搬运工&lt;strong&gt;」&lt;/strong&gt;。使用静态方法返回对象的方式在单态中使用广泛。&lt;/p&gt;
&lt;p&gt;List、Set有着相似的方式。它们都继承自Collection，同时不能实例化为该类的对象，必须通过子类实现父类的方法来实例化不同属性的对象。ArrayList HashSet等都通过注册的方式进行映射。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;单态就是整个类能且只能有一个对象存在，为null则构造一个，不为null应返回该对象。例如购物车只能有一个、聊天平台只能有一个、饭馆的点菜平台只能有一个 这种类似的场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;与不同参数的构造函数不同，不同参数的静态工厂可能返回同一属性的该(子)类的对象。该方式抛弃了重复冗杂的new形式，在C#常见newInstance()构造新对象，而在Java里就比较少的出现，一般都是左右对等的。&lt;/p&gt;
&lt;p&gt;最上面这段代码最有趣的地方在于，它是Boolean的包装类，输入的是值类型而返回的是Boolean对象,当然Boolean只实例化了两个对象。但当新的子类构建，简单的静态工厂必须重写，常用的改进方法有：&lt;/p&gt;
&lt;h2 id=&quot;反射机制-配置&quot;&gt;&lt;a href=&quot;#反射机制-配置&quot; class=&quot;headerlink&quot; title=&quot;反射机制+配置&quot;&gt;&lt;/a&gt;反射机制+配置&lt;/h2&gt;&lt;p&gt;  例如下面一段就是根据不同的类名，返回不同的对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;    public static InterFace_Name staticFactory(String name)throws
                                InstantiationException,
                                IllegalAccessException,
                                ClassNotFoundException{     
        // 这边使用的是Java的Reflection机制来产生实例
        // 以后就算改变了这边的程式，客户端程式是不用更改的
        return (InterFace_Name) Class.forName(name).newInstance();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;注册方式-Service-Provider-Framework&quot;&gt;&lt;a href=&quot;#注册方式-Service-Provider-Framework&quot; class=&quot;headerlink&quot; title=&quot;注册方式(Service Provider Framework)&quot;&gt;&lt;/a&gt;注册方式(Service Provider Framework)&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;注册方式需要&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务具体实现类(由服务提供商实现)&lt;/li&gt;
&lt;li&gt;服务提供者实现类，1为2的实例，(由服务提供商实现)&lt;/li&gt;
&lt;li&gt;服务定义接口，定义服务内容，不包含实现。&lt;/li&gt;
&lt;li&gt;服务提供者接口，3为4的实例，定义获取提供者的方式，不包含实现。&lt;/li&gt;
&lt;li&gt;服务提供者注册类&lt;br&gt;最常见的实例就是JDBC(Java DataBase Connection)。下面这段最常见的连接mysql的标准函数就很好的体现了注册的方式。&lt;pre&gt;&lt;code class=&quot;java&quot;&gt; public synchronized static Connection getCon() 
     throws ClassNotFoundException, SQLException
 {
     //服务提供者接口
       String DRIVERNAME = &amp;quot;com.mysql.jdbc.Driver&amp;quot;;
       //java.sql.Driver.class这个是服务提供者接口，
       //服务提供者若使mysql，那就使用&amp;quot;com.mysql.jdbc.Driver&amp;quot;；
       //如果是sql server，那就使用&amp;quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&amp;quot;;
       //如果是Oracle，那就要用&amp;quot;oracle.jdbc.driver.OracleDriver&amp;quot;...
       String URL = &amp;quot;jdbc:mysql://URL/DataBase_Names&amp;quot;;
       String USER = &amp;quot;USER&amp;quot;;
       String PWD = &amp;quot;PWD&amp;quot;; 
       Connection connection = null;//接口 由服务提供者提供并实现具体服务 
       Class.forName(DRIVERNAME);
       //这里映射通过DriverManager判断获取的是哪个服务
       connection = (Connection) DriverManager.getConnection(URL, USER,PWD);
       //链接数据库  mysql已经在驱动管理注册了API(本机装mysql的时候)
       //这里使用者编写的服务访问getConnection这个API，
       if(connection!=null){return connection;}
       else{return null;}//具体的数据库操作逻辑   
 }
&lt;/code&gt;&lt;/pre&gt;
上式的意义就是，使用&lt;strong&gt;Java&lt;/strong&gt;连接上&lt;strong&gt;数据库&lt;/strong&gt;。注意，不是某种数据库，是数据库。数据库的提供商按照定义的接口（Java提供的,增删改查等数据库操作），都可以顺利的连接上它们的数据库。  &lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Class.forName(&amp;quot;...&amp;quot;)&lt;/code&gt;这句实例化一个mysql等数据库提供商的&lt;font color=&quot;red&quot;&gt;服务提供者实现类&lt;/font&gt;，并将这个类的实例注册到DriverManager即&lt;font color=&quot;red&quot;&gt;服务提供者注册类&lt;/font&gt;。&lt;/li&gt;
&lt;li&gt;通过URL指明连接的地址和端口，判断所连接的数据库类别，在利用USERNAME PWD参数连接到数据库获取操作数据库的一个连接Connection。&lt;/li&gt;
&lt;li&gt;Connection作为一个实现类，客户端的程序得到了这个实例就可以操作各种数据库，但其内部的原理对客户端不可见的，这就是所谓的面向接口编程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里举一个炸裂的例子。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;具体服务接口定义了live和die，然后实现类实现了具体的方法&lt;/li&gt;
&lt;li&gt;服务提供者接口定义了获取服务实例的函数，然后服务提供者实现类实现了注册方式获取实例&lt;/li&gt;
&lt;li&gt;注册类则对ClassName和服务提供者接口进行绑定。相当于，对不同的服务提供商通过名字进行映射&lt;/li&gt;
&lt;li&gt;调用类则通过常规步骤，调用具体服务。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;HaInterface.java&lt;br&gt;&lt;pre&gt;&lt;code&gt;package com.gua.com;
public interface HaInterface {
    public void Live();
    public void Die();
}&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;HaClass.java&lt;br&gt;&lt;pre&gt;&lt;code&gt;package com.gua.com;
public class HaClass implements HaInterface{
    @Override
    public void Live() {
        System.out.println(&quot;给你们一些人生经验&quot;);
    }
    @Override
    public void Die() {
        System.out.println(&quot;又想搞大新闻!&quot;);
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;Xuyimiao.java&lt;br&gt;&lt;pre&gt;&lt;code&gt;package com.gua.com;
public interface Xuyimiao {
    public HaInterface HahaGo();
}&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;WoyaoXuyimiao.java&lt;br&gt;&lt;pre&gt;&lt;code&gt;package com.gua.com;
public class WoyaoXuyimiao implements  Xuyimiao{
    static{
        MingwangManager.registerProvider(&quot;辣妹子辣&quot;, new WoyaoXuyimiao());  
    }
    @Override
    public HaInterface HahaGo() {
        return new HaClass(); 
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;MingwangManager.java&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.gua.com;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
public class MingwangManager {
    public MingwangManager(){};
    private static final Map&amp;lt;String, Xuyimiao&amp;gt; providers = new ConcurrentHashMap&amp;lt;String, Xuyimiao&amp;gt;();  
    public static void registerProvider(String name, Xuyimiao p) {
            providers.put(name, p);  
        }  
    public static HaInterface getService(String name) {       
            Xuyimiao p = providers.get(name);  
            if (p == null) {  
                throw new IllegalArgumentException(  
                        &amp;quot;No provider registered with name:&amp;quot; + name);  
            } 
            return p.HahaGo();
        }  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;TestHa.java&lt;br&gt;&lt;pre&gt;&lt;code&gt;package com.gua.com; 
public class TestHa {  
    public static void main(String[] args) throws ClassNotFoundException {
        Class.forName(&quot;com.gua.com.WoyaoXuyimiao&quot;);  
        HaInterface hi = MingwangManager.getService(&quot;辣妹子辣&quot;);  
        hi.Live();  
        hi.Die();  
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2 id=&quot;这种方式已经不推荐-工厂模式&quot;&gt;&lt;a href=&quot;#这种方式已经不推荐-工厂模式&quot; class=&quot;headerlink&quot; title=&quot;这种方式已经不推荐-工厂模式&quot;&gt;&lt;/a&gt;这种方式已经不推荐-工厂模式&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;工厂方法&lt;/a&gt;  &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;抽象工厂&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考文章:&lt;a href=&quot;(http://liwenshui322.iteye.com/blog/1267202)&quot;&gt;JAVA 服务提供者框架介绍&lt;/a&gt;、&lt;a href=&quot;(http://blog.csdn.net/csdn0123/article/details/7388445)&quot;&gt;构造器和静态方法&lt;/a&gt;&lt;/p&gt;
&lt;script src=&quot;../../../../js/highlight.min.js&quot;&gt;&lt;/script&gt;
&lt;link href=&quot;../../../../css/monokai_sublime.min.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;静态工厂&quot;&gt;&lt;a href=&quot;#静态工厂&quot; class=&quot;headerlink&quot; title=&quot;静态工厂&quot;&gt;&lt;/a&gt;静态工厂&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;    public static Boolean valueOf (boolean b){
        return b?Boolean.True:Boolean.False;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;静态工厂以其名字显见，以[类名.方法名]的方式调用，其静态函数主要返回其类的对象，一般是引用值。返回什么东西，由参数决定，这个工厂给你产出来。其在API开发中使用广泛。&lt;br&gt;
    
    </summary>
    
      <category term="代码狗" scheme="http://ovjaywang.github.io/categories/%E4%BB%A3%E7%A0%81%E7%8B%97/"/>
    
      <category term="学习log" scheme="http://ovjaywang.github.io/categories/%E4%BB%A3%E7%A0%81%E7%8B%97/%E5%AD%A6%E4%B9%A0log/"/>
    
    
      <category term="test" scheme="http://ovjaywang.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Hexo双备份Github和Coding及域名绑定</title>
    <link href="http://ovjaywang.github.io/2016/04/10/Hello-Hexo/"/>
    <id>http://ovjaywang.github.io/2016/04/10/Hello-Hexo/</id>
    <published>2016-04-10T14:51:49.000Z</published>
    <updated>2016-08-29T08:52:17.503Z</updated>
    
    <content type="html">&lt;p&gt;感谢&lt;a href=&quot;http://zipperary.com/2013/05/28/hexo-guide-2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个教程&lt;/a&gt;&lt;br&gt;还有&lt;a href=&quot;http://ibruce.info/2013/11/22/hexo-your-blog/?utm_source=tuicool&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个&lt;/a&gt;&lt;br&gt;解决了好多bugs的&lt;a href=&quot;http://www.jianshu.com/p/35e197cb1273&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个&lt;/a&gt;&lt;br&gt;优化cdn图床缓冲的&lt;a href=&quot;http://lukang.me/2015/optimization-of-hexo-2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.dute.me/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个&lt;/a&gt;让我找到了便宜的狗爹优惠码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;从一开始的阵地wp搬到这里来了。后会有期了dooby.me 再见了WordPress  
默默的是有些不舍。虽然push很慢虽然被墙了大半  
4年光阴不复返啊。从一个逗比成长为大逗比了。
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;hexo坑还是挺多的。&lt;br&gt;$$ \begin{bmatrix} x \\ y \\ 1&lt;br&gt;\end{bmatrix} \sim \begin{bmatrix} f &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; f &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \end{bmatrix} \begin{bmatrix} r_11 &amp;amp; r_12 &amp;amp; r_13 &amp;amp; t_x \\ r_21 &amp;amp; r_22 &amp;amp; r_23 &amp;amp; t_y \\ r_31 &amp;amp; r_32&amp;amp; r_33 &amp;amp; t_z \\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \end{bmatrix} \begin{bmatrix} p \\ q \\ 0 \\ 1 \end{bmatrix} \sim \begin{bmatrix} fr_11 &amp;amp; fr_12 &amp;amp; ft_x \\ fr_21 &amp;amp; fr_22 &amp;amp; ft_y \\ r_31 &amp;amp; r_32 &amp;amp; t_z \end{bmatrix} \begin{bmatrix} p \\ q \\ 1 \end{bmatrix}&lt;br&gt;$$$$\sim \begin{bmatrix} h_11 &amp;amp; h_12&amp;amp;h_13 \\ h_21 &amp;amp; h_22 &amp;amp; h_23 \\ h_31 &amp;amp; h_32 &amp;amp; h_33 \end{bmatrix} \begin{bmatrix} p \\ q \\ 1 \end{bmatrix}$$&lt;/p&gt;
&lt;h1 id=&quot;公式和Markdown冲突&quot;&gt;&lt;a href=&quot;#公式和Markdown冲突&quot; class=&quot;headerlink&quot; title=&quot;公式和Markdown冲突&quot;&gt;&lt;/a&gt;公式和Markdown冲突&lt;/h1&gt;&lt;p&gt;由于下划线在LaTex公式编辑器和MarkDown中都有，因此如果在公式中有两个xiahuaxian”_”则必须注意不要发生冲突，需加入反斜杠在下划线前！！在SublimeText中也可以看到如果又两个双下划线字体已变成斜体。&lt;/p&gt;
&lt;p&gt;$$ 2H_2 = 2O_2+H_2$$&lt;/p&gt;
&lt;h1 id=&quot;WordPress迁移&quot;&gt;&lt;a href=&quot;#WordPress迁移&quot; class=&quot;headerlink&quot; title=&quot;WordPress迁移&quot;&gt;&lt;/a&gt;WordPress迁移&lt;/h1&gt;&lt;p&gt;这个使用hexo-migrate-wordpress插件还不错 但是切记导出的xml是文章 tag和category会自动建好。否则使用hexo migrate wordpress 会报错&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;沙扬娜拉dooby.me&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/05/02/5727757865698.png&quot; alt=&quot;dooby.me&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Github和Coding双备份&quot;&gt;&lt;a href=&quot;#Github和Coding双备份&quot; class=&quot;headerlink&quot; title=&quot;Github和Coding双备份&quot;&gt;&lt;/a&gt;Github和Coding双备份&lt;/h1&gt;&lt;p&gt;按照一般的教程都能配置好Github的。但是Coding对国内线路速度相对较快（好蛋疼GitCafe已经被收了）配置文档差不多是这样&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;markdown&quot;&gt;deploy:
   type: git
   repo: 
      github: https://github.com/{YOUR_ID}/{YOUR_ID}.github.io.git,master
      coding: https://git.coding.net/{YOUR_ID}/{BLOG　NAME}.git,master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然也需要先将ssh的key添加上去（同一个码即可），Coding不需要同一个名字..然而最近发现Coding的项目展示页面收费了……虽说是注重团队协作和代码交易 但是个人用户的托管真的完全要丢掉了吗？差不多1块钱1天的样子 相当不划算&lt;/p&gt;
&lt;h1 id=&quot;SEO是极好的&quot;&gt;&lt;a href=&quot;#SEO是极好的&quot; class=&quot;headerlink&quot; title=&quot;SEO是极好的&quot;&gt;&lt;/a&gt;SEO是极好的&lt;/h1&gt;&lt;p&gt;切莫贪杯 google就好 但是 切记！标题不要带有‘&amp;amp;’。年少无知，这个符号不能正常解析出xml会报错&lt;/p&gt;
&lt;h1 id=&quot;域名绑定&quot;&gt;&lt;a href=&quot;#域名绑定&quot; class=&quot;headerlink&quot; title=&quot;域名绑定&quot;&gt;&lt;/a&gt;域名绑定&lt;/h1&gt;&lt;p&gt;切记@解析的是{YOUR_ID}.github.io的地址而不是github.com的 CNAME需要放在source下才能被generate。dnspod被企鹅注资后ui变得相当土了&lt;/p&gt;
&lt;h1 id=&quot;专注写作&quot;&gt;&lt;a href=&quot;#专注写作&quot; class=&quot;headerlink&quot; title=&quot;专注写作&quot;&gt;&lt;/a&gt;专注写作&lt;/h1&gt;&lt;p&gt;放弃各种挂饰 插件 统计吧 seo和评论就足够了。多写作多讨论 当然很想适时的学一发nodejs因为折腾了好久ig的照片还是没能get进来。&lt;/p&gt;
&lt;script src=&quot;//gist.github.com/86cc40065a691b7c4534e483249583dd.js?file=transValue.java&quot;&gt;&lt;/script&gt;
&lt;blockquote&gt;&lt;p&gt;NEW: DevDocs now comes with syntax highlighting. &lt;a href=&quot;http://devdocs.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://devdocs.io&lt;/a&gt;&lt;/p&gt;&lt;footer&gt;&lt;strong&gt;@DevDocs&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;https://twitter.com/devdocs/status/356095192085962752&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;twitter.com/devdocs/status/356095192085962752&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.&lt;/p&gt;&lt;footer&gt;&lt;strong&gt;David Levithan&lt;/strong&gt;&lt;cite&gt;Wide Awake&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Every interaction is both precious and an opportunity to delight.&lt;/p&gt;&lt;footer&gt;&lt;strong&gt;Seth Godin&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Welcome to Island Marketing&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;void transValue(int a,int b){
        a ^= b;
        b ^= a;
        a ^=b;
    }&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;alert(&#39;Hello World!&#39;);&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote class=&quot;pullquote [class]&quot;&gt;&lt;p&gt;blah blah blah&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;2016.04.11&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;感谢&lt;a href=&quot;http://zipperary.com/2013/05/28/hexo-guide-2/&quot;&gt;这个教程&lt;/a&gt;&lt;br&gt;还有&lt;a href=&quot;http://ibruce.info/2013/11/22/hexo-your-blog/?utm_source=tuicool&quot;&gt;这个&lt;/a&gt;&lt;br&gt;解决了好多bugs的&lt;a href=&quot;http://www.jianshu.com/p/35e197cb1273&quot;&gt;这个&lt;/a&gt;&lt;br&gt;优化cdn图床缓冲的&lt;a href=&quot;http://lukang.me/2015/optimization-of-hexo-2.html&quot;&gt;这个&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.dute.me/&quot;&gt;这个&lt;/a&gt;让我找到了便宜的狗爹优惠码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;从一开始的阵地wp搬到这里来了。后会有期了dooby.me 再见了WordPress  
默默的是有些不舍。虽然push很慢虽然被墙了大半  
4年光阴不复返啊。从一个逗比成长为大逗比了。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="槽" scheme="http://ovjaywang.github.io/categories/%E6%A7%BD/"/>
    
    
      <category term="hello" scheme="http://ovjaywang.github.io/tags/hello/"/>
    
  </entry>
  
  <entry>
    <title>记静态Ip的坑</title>
    <link href="http://ovjaywang.github.io/2016/04/01/%E8%AE%B0%E9%9D%99%E6%80%81ip%E7%9A%84%E5%9D%91/"/>
    <id>http://ovjaywang.github.io/2016/04/01/记静态ip的坑/</id>
    <published>2016-04-01T08:06:32.000Z</published>
    <updated>2016-04-23T12:21:11.330Z</updated>
    
    <content type="html">&lt;p&gt;明明在hadoop配置静态IP的时候被坑过一次，却完全想不起来怎么解决的。尤其是在ssh登录的时候需要记下host和ip的对应，才能直接输出主机名来访问局域网内的其他主机。&lt;br&gt;现在记下来。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;1.原生linux+无线网卡/有线端口&lt;br&gt;ubuntu改interface和fedora改eth0-XXXXX都是极好的 里面对应的netmask ipaddress gateway dns1dns2（dnsnameserver）在resolv.conf配置dns信息&lt;br&gt;但是&lt;strong&gt;比较easy&lt;/strong&gt;的纯粹做法直接在有线/无线的连接信息里面加这几个对应信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/04/01/56fe2742cea08.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;最最最easy的就是直接在路由器dhcp绑定mac静态分配，直接原生效果拔群。&lt;/p&gt;
&lt;p&gt;2.虚拟机+有线端口/原生无线网卡&lt;/p&gt;
&lt;p&gt;这种情况有点坑 虚拟机切记开启桥接模式 直接把主机和虚拟机按照局域网内的两台机器分配ip。这样当然也可以按照配置文件配置 切记写入MN_COTROLLED=yes 然后开启networkmanager管理网络，并使用&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;systemctl enable netwoekmanager&lt;/pre&gt;

&lt;p&gt;开启开机启动。诚然，在连接信息直接配置也行。&lt;br&gt;3.虚拟机+外接无线网卡&lt;br&gt;呵呵 没找到解决方案。直接桥接驱动没法搞；直接nat不是我想要的结果。反正奏事上不了网ping不了局域网&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;明明在hadoop配置静态IP的时候被坑过一次，却完全想不起来怎么解决的。尤其是在ssh登录的时候需要记下host和ip的对应，才能直接输出主机名来访问局域网内的其他主机。&lt;br&gt;现在记下来。&lt;/p&gt;
    
    </summary>
    
      <category term="什么都学一下" scheme="http://ovjaywang.github.io/categories/%E4%BB%80%E4%B9%88%E9%83%BD%E5%AD%A6%E4%B8%80%E4%B8%8B/"/>
    
      <category term="学习log" scheme="http://ovjaywang.github.io/categories/%E4%BB%80%E4%B9%88%E9%83%BD%E5%AD%A6%E4%B8%80%E4%B8%8B/%E5%AD%A6%E4%B9%A0log/"/>
    
    
      <category term="hadoop" scheme="http://ovjaywang.github.io/tags/hadoop/"/>
    
      <category term="静态ip" scheme="http://ovjaywang.github.io/tags/%E9%9D%99%E6%80%81ip/"/>
    
  </entry>
  
  <entry>
    <title>最近Demo 模块 算法总结</title>
    <link href="http://ovjaywang.github.io/2016/03/08/demo-conclusion/"/>
    <id>http://ovjaywang.github.io/2016/03/08/demo-conclusion/</id>
    <published>2016-03-08T09:43:56.000Z</published>
    <updated>2016-04-23T12:22:24.295Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;http://ju.outofmemory.cn/entry/106397&quot; title=&quot;http://ju.outofmemory.cn/entry/106397&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://ju.outofmemory.cn/entry/106397&lt;/a&gt; 【坑妹填完】&lt;/p&gt;
&lt;p&gt;最近各种乱整。。文章妹时间管光顾着折腾手头派下来的事情了。再加上每天固定的复习提高一下。小论文完全没有头绪。&lt;br&gt;最近get到的实用方法还是很多阿。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;DBScan（Density-Based-Spatial-Clustering-of-Applications-with-Noise）基于密度的含噪空间聚类&quot;&gt;&lt;a href=&quot;#DBScan（Density-Based-Spatial-Clustering-of-Applications-with-Noise）基于密度的含噪空间聚类&quot; class=&quot;headerlink&quot; title=&quot;DBScan（Density-Based Spatial Clustering of Applications with Noise）基于密度的含噪空间聚类&quot;&gt;&lt;/a&gt;&lt;strong&gt;DBScan&lt;/strong&gt;（Density-Based Spatial Clustering of Applications with Noise）&lt;strong&gt;基于密度的含噪空间聚类&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;最大特点是：多维、任何形状聚类、聚类数任意、噪声可控、对输入不敏感；缺点很明显，需要提前知道2个参数（一般实验多了，根据经验对同一类型聚类可以不用改。），时间复杂度和空间复杂度都很大，需要计算点两两之间距离[这里需要优化，否则算法超出一般忍受时间] 不对密度变化做出选择。&lt;br&gt;输入参数2个，单一点半径范围R及其最小包含的点数N。算法本质是遍历所有点并计算邻域内的点数并拓展该类（以R范围内是否达到N来判断）。被分类的点将会标记并不再被检测到。因此耗时表现在邻域查找和拓展聚类上。但解算效果相当良好。&lt;br&gt;算法的优化方案相当多：kdtree的、基于网格计算的、基于适应性解算阈值的、局部敏感哈希。主要解决的都是如何加快求解邻域解求速度。诚然它的算法复杂度有n^3显然想要加快并不是那么容易。深入研讨了一番发现计算距离时有的不止一遍，因此写入硬盘或许是个好的方案，但是I/O读取的效率就要考虑进来了；还有一种方式是限制深入迭代次数，即做多在第几层nearestpoint()这个数组中进行聚类的拓展。这种做法的危害是使得同一个点集很可能多次才并入，或者完全没有并到一块，因此需要一个后手，将聚类中心相近的再次组合，其实在kdtree中也有类似的做法。参考&lt;a href=&quot;https://github.com/alitouka/spark_dbscan&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;基于SPark的DBSCAN的图解&lt;/a&gt;，KDTree建立时，按区域分割好数据后，同一类的点集亦可能先分散于个个区间。各自区间先进行小聚类后，再进行大聚类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/03/30/56fb7e092b350.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;（中了SPark的毒，后面会进行测试）&lt;br&gt;demo很好的展示了算法的原理。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.naftaliharris.com/blog/visualizing-dbscan-clustering/&quot; title=&quot;http://www.naftaliharris.com/blog/visualizing-dbscan-clustering/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.naftaliharris.com/blog/visualizing-dbscan-clustering/&lt;/a&gt; 在线666可视化理解dbscan过程。不同的实例可以看到，对不同图形的检测相当准确；同时聚类精度亦相当高。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/6621630/dbscan-code-in-c-sharp-or-vb-net-for-cluster-analysis&quot; title=&quot;http://stackoverflow.com/questions/6621630/dbscan-code-in-c-sharp-or-vb-net-for-cluster-analysis&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://stackoverflow.com/questions/6621630/dbscan-code-in-c-sharp-or-vb-net-for-cluster-analysis&lt;/a&gt;stackoverflow图解dbscan&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.yzuzun.com/2015/07/dbscan-clustering-algorithm-and-c-implementation/&quot; title=&quot;https://www.yzuzun.com/2015/07/dbscan-clustering-algorithm-and-c-implementation/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.yzuzun.com/2015/07/dbscan-clustering-algorithm-and-c-implementation/&lt;/a&gt; dbscan的C#实现和作者的gayhub项目&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://download.csdn.net/detail/f112122/7482303&quot; title=&quot;http://download.csdn.net/detail/f112122/7482303&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://download.csdn.net/detail/f112122/7482303 &lt;/a&gt;c#简易可视化工程例子&lt;/p&gt;
&lt;p&gt;诚然，boost把很多常用的算法都写进去了。但c++使用起来才比较顺。这是c++环境下使用dbscan的正确方式：上boost。比如下面这个&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yusufuzun/dbscan&quot; title=&quot;https://github.com/yusufuzun/dbscan&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/yusufuzun/dbscan&lt;/a&gt;（C# 以算法原理为基准 不是很快）&lt;/p&gt;
&lt;p&gt;或这个&lt;a href=&quot;https://github.com/Terranlee/DBSCAN&quot; title=&quot;https://github.com/Terranlee/DBSCAN&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Terranlee/DBSCAN&lt;/a&gt;（C++&amp;amp;boost&amp;amp;KDTree&amp;nbsp; 至今没有明白第一个参数ire的含义啊。一般都2个参数就好了啊 而且结果貌似也不太对 等待修正）&lt;/p&gt;
&lt;h1 id=&quot;boost的使用&quot;&gt;&lt;a href=&quot;#boost的使用&quot; class=&quot;headerlink&quot; title=&quot;boost的使用&quot;&gt;&lt;/a&gt;&lt;strong&gt;boost的使用&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;上边两个github的例子都基于c++开发，其中都使用到了流行的c++高性能计算类库boost。&lt;/p&gt;
&lt;p&gt;linux下的编译和安装遵循这个帖比较顺 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://ju.outofmemory.cn/entry/106397&quot; title=&quot;http://ju.outofmemory.cn/entry/106397&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://ju.outofmemory.cn/entry/106397&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;KDTree &lt;/p&gt;
&lt;p&gt;KDTree作为一种数据结构的拓展，其实是一种变异的二叉排序树，其最最最原始的构造就是，在二叉树左小右大的基础上，对多维数据，第一层比较第一个维度，第二层比较第二个维度，以此类推…………排到最后一维又返回第一位继续排，当然，而已设定排序的次数，到多少维就懒得排了。这个数据结构的好处是，寻找欧几里得空间（也就是任意维度的两个对象的连线长度&amp;amp;有的地方也使用该值当做两个对象相似度）的最邻近点（集）复杂度大大降低，不用迭代整个数就能找到最近的点。&lt;/p&gt;
&lt;p&gt;上面说的DBSCAN、后面的ICP、图像匹配中的SIFT算子比较相似度（128维），使用KDTree可以很好的解决时间太长的问题。&lt;/p&gt;
&lt;p&gt;来一波树形结合，&lt;/p&gt;
&lt;p&gt;KDTree的改进方法有Best Bin Fisrt、Best First Search。它主要的临近查找是基于路径和回路的，但没有考虑节点的一些性质，BBF则根据查询路径上的节点进行排序，排序原则是按照超平面的最短距离。另外还可设置超时，优先级队列中的所有节点都经过检查或者超出时间限制时，返回当前最好结果当做近似的最近邻。这种方式在高维上效率提升很大。（尤其sift）&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;font color=&quot;#555555&quot;&gt;&lt;/font&gt;&amp;nbsp;&lt;/p&gt;
&lt;h1 id=&quot;ICP（Iterative-closest-point）&quot;&gt;&lt;a href=&quot;#ICP（Iterative-closest-point）&quot; class=&quot;headerlink&quot; title=&quot;ICP（Iterative closest point）&quot;&gt;&lt;/a&gt;&lt;strong&gt;ICP&lt;/strong&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Iterative_closest_point&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Iterative closest point&lt;/a&gt;）&lt;/h1&gt;&lt;p&gt;点集匹配算法——两组有部分重叠区域的点集，进行拟合和对应点匹配。匹配中如果模式重复程度过高可能陷入局部最小值，因此需要对模式进行了良好的解析。&lt;/p&gt;
&lt;p&gt;算法原理：①算法先解算归一两组点集比例尺、解算质心，将质心重合②对其中一个点集，寻找每个另一点集的最近点，解算梯度和旋转平移量③再次计算最近点，若旋转量小于阈值则停止，若大于阈值则继续②步骤。④按照对应点计算H矩阵（单映矩阵）。&lt;/p&gt;
&lt;p&gt;第二部中的关键步骤其实就是解算每一步的迭代旋转和平移量，用到的是最小二乘法；其次，输入模式及输入顺序对匹配影像也比较大。一般的，停止迭代可以设置限差或者迭代次数。&lt;/p&gt;
&lt;p&gt;VTK5.8的C#dll中有包含ICP最新的算法，但算法较旧，效率较低，但新版6.0+在C#上未开源，忧伤。算法中，求取最近点有三种做法，一点对点，直接找最近点，常用kd-tree实现；二点对面，求取最近的切面的一个切点，主要针对点集和曲面匹配；三点做发现与另一曲面交点，主要针对面与面配准。&lt;/p&gt;
&lt;p&gt;mrpt类库中关于ICP的例子&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.mrpt.org/Iterative_Closest_Point_%28ICP%29_and_other_matching_algorithms&quot; title=&quot;http://www.mrpt.org/Iterative_Closest_Point_%28ICP%29_and_other_matching_algorithms&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.mrpt.org/Iterative_Closest&lt;em&gt;Point&lt;/em&gt;%28ICP%29_and_other_matching_algorithms&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;结合NUnit的ICP算法&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.codeproject.com/Articles/865830/Point-cloud-alignment-ICP-methods-compared&quot; title=&quot;http://www.codeproject.com/Articles/865830/Point-cloud-alignment-ICP-methods-compared&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.codeproject.com/Articles/865830/Point-cloud-alignment-ICP-methods-compared&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;适应性：对自由形状的曲面适应性较好，VTK算法在LiDar数据扫描配准中应用较好。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;convex-hull-of-a-set-of-points-点集的凸包&quot;&gt;&lt;a href=&quot;#convex-hull-of-a-set-of-points-点集的凸包&quot; class=&quot;headerlink&quot; title=&quot;convex hull of a set of points 点集的凸包&quot;&gt;&lt;/a&gt;&lt;strong&gt;convex hull of a set of points&lt;/strong&gt; 点集的凸包&lt;/h1&gt;&lt;p&gt;没啥特点。但相当基础。在外接圆计算、外接矩形计算的时候必须首先解算。demo相当完美。可直接改了用了。能把demo做的这么直白这么易用相当666了(c#)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://csharphelper.com/blog/2014/07/find-the-convex-hull-of-a-set-of-points-in-c/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;查找点集外包圆&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;minimal bounding rectangle for a polygon &lt;/strong&gt;凸包的最小外接矩形。这个算法在解求聚类、数据形态方面有很多利用。前提是前面提到的点集凸包以及点集是否按顺时针排序。同样的网站，给的demo我只能说酷炸了。（c#）包含了两种模式：最小面积和最小周长，两者相差不会很大。demo的计算原则是面积。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://csharphelper.com/blog/2014/07/find-minimal-bounding-rectangle-polygon-c/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算凸多边形最小外接矩形&lt;/a&gt;&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://ju.outofmemory.cn/entry/106397&quot; title=&quot;http://ju.outofmemory.cn/entry/106397&quot;&gt;http://ju.outofmemory.cn/entry/106397&lt;/a&gt; 【坑妹填完】&lt;/p&gt;
&lt;p&gt;最近各种乱整。。文章妹时间管光顾着折腾手头派下来的事情了。再加上每天固定的复习提高一下。小论文完全没有头绪。&lt;br&gt;最近get到的实用方法还是很多阿。&lt;br&gt;
    
    </summary>
    
      <category term="代码狗" scheme="http://ovjaywang.github.io/categories/%E4%BB%A3%E7%A0%81%E7%8B%97/"/>
    
      <category term="学习log" scheme="http://ovjaywang.github.io/categories/%E4%BB%A3%E7%A0%81%E7%8B%97/%E5%AD%A6%E4%B9%A0log/"/>
    
    
      <category term="dbscan" scheme="http://ovjaywang.github.io/tags/dbscan/"/>
    
      <category term="demo" scheme="http://ovjaywang.github.io/tags/demo/"/>
    
      <category term="ICP" scheme="http://ovjaywang.github.io/tags/ICP/"/>
    
      <category term="MMC" scheme="http://ovjaywang.github.io/tags/MMC/"/>
    
      <category term="MME" scheme="http://ovjaywang.github.io/tags/MME/"/>
    
      <category term="SPark" scheme="http://ovjaywang.github.io/tags/SPark/"/>
    
      <category term="算法" scheme="http://ovjaywang.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>由opencv中findFundamentalMat和findHomography区别的引申</title>
    <link href="http://ovjaywang.github.io/2016/01/25/opencv-findhomography-findfundanmentalmat/"/>
    <id>http://ovjaywang.github.io/2016/01/25/opencv-findhomography-findfundanmentalmat/</id>
    <published>2016-01-24T16:54:26.000Z</published>
    <updated>2016-04-29T09:13:23.591Z</updated>
    
    <content type="html">&lt;p&gt;openCV中有两个函数，findhomography和findfundamentalmat，长的很像。。一开始严重的弄混，以为都是求对应点投影矩阵的公式，万万没想到其实是两个完全不同的内涵。😒&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;opencv 中，进行&lt;strong&gt;图像拼接(全景拼接 航摄拼接 三维重建 街景地图)&lt;/strong&gt;，大致流程如下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用opencv提供的各类型特征点检测方法（Fast Start SIFT SURF ORB SimpleBlobPyramidAdapter DynamicAdapter 等）在图像中将感兴趣的有独特标识的点找出来,其中orb 是最近提出效率较高的检测和描述算法，金字塔算法则是更高的提高效率的算法；&lt;/li&gt;
&lt;li&gt;利用不同的描述方式（SIFT SURF），对特征点的信息（周围的梯度、灰度相关性 二进制编码等）进行描述； &lt;/li&gt;
&lt;li&gt;利用不同原则的匹配方式（BF Flann-based等），对这些描述子（一般是多维矩阵）进行匹配（匹配中数据的输入参数的筛选Ransac方法），对匹配结果反向计算进一步的筛查，选择更健壮更有代表性的数据（knn Ransac），&lt;/li&gt;
&lt;li&gt;最后利用findhomography找到映射矩阵，再利用affine将该坐标映射关系对其中一幅图贴到其中一幅图中。 完成拼接。拼接区域涉及融合平滑。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这其中，&lt;strong&gt;findfundamentalmat()&lt;/strong&gt;和&lt;strong&gt;findhomography()&lt;/strong&gt;都是用来查找两组匹配坐标点的映射关系的（两组坐标几何 数目相同 同一&lt;strong&gt;数组位&lt;/strong&gt;为同一对匹配点）试着运行了一下homography生成的矩阵拼接效果良好。而findfundamentalmat就不太6.找了一些相关资料，其实这是两个相似但不相同的函数。so开始之前科普几个概念：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;核点（极点）&lt;/strong&gt;：摄影中心连线（基线）ss’延长线，与左右影像的交点，分为左右核点（极点）。（注：下图两影像接近平行，则ss’连线与影像无交点，而在下下图中，el er分别为左右核点【极点】）亦可理解为左右摄影中心分别在对方像片的像点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核面（极面）&lt;/strong&gt; ：过摄影基线与物方任意一点组成的平面。（所以缩，物方点不同，核面一般也不同 任意一个下图的PO1O2都是核面）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核线（极线）：立体像对中，同名光线与摄影基线所组成核面与左右像片的交线。&lt;/strong&gt; （不同同名点极线不同，因而有很多很多条） &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;极线约束&lt;/strong&gt; ：同一个点在两幅图像上的映射，已知左图映射点p1，那么右图映射点p2一定在p1的外极线上，这样可以减少匹配点数量。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/24/56ce7786da1fa.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;上图中，红线即为极线，物方点P（X,Y,Z）分别在左右两图留下了同名点（xl，yl）、（xr,yr）。Tx即为基线长。但上图为两个平面接近平行且z方向接近0，但一般情况下，两像平面以任意角度成像同时内参数并不相同，因此上图中的极线呈现出共线的情况，更多的情况是下面这个图，两图像成任意角度。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/24/56ce782a3235f.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;下图中，O1O2连线与左右像平面交点el和er即为左右极点(极点亦可理解为左右摄影中心在另一像平面的像)，而极线则为plel和prer。可以看到，这两条线显然就不平行了。 &lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/24/56ce77b362343.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;strong&gt;基线&lt;/strong&gt; ：相邻两摄站点（摄影中心 一般标为s）之间的连线。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主核面&lt;/strong&gt; ：左右像主点分别与基线构成的平面，分别称为左主核面和右主核面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;灭点vanishing &lt;/strong&gt; point：平行线在二维图像中汇聚的地方，空间中每一组平行线都有自己的灭点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;灭线vanishing line（消隐线 ）&lt;/strong&gt; ：不同的灭线连线，即灭线。如果两组不同的平行线，都平行于大地，则他们的连线就是地平线（horizon line）&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-第一个矩阵Essential本质矩阵&quot;&gt;&lt;a href=&quot;#1-第一个矩阵Essential本质矩阵&quot; class=&quot;headerlink&quot; title=&quot;1. 第一个矩阵Essential本质矩阵&quot;&gt;&lt;/a&gt;1. 第一个矩阵Essential本质矩阵&lt;/h1&gt;&lt;p&gt;由于拍摄物体时，摄影中并不能被反映在图像中。如果让第二个观察者同时拍摄下某摄影中心和它所拍的照片呢?&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56cfbd34f3c9e.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;反映在第二个观察者的照片，摄影中心和物体分别投影在像片上，任意第一个摄影中心和它所拍摄物体的连线都可视为第二个摄影中心的极线。直观的理解，即为下图的erpr。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56cfc06a0ddc5.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;strong&gt;极线约束的理论就是左侧的物体成像在右侧的同名点一定在erpr上。&lt;/strong&gt;反映左右极线关系的就是表达向量和右向量之间的约束关系的——&lt;strong&gt;本质矩阵**&lt;/strong&gt;Eseential Matrix&lt;strong&gt;**。&lt;/strong&gt;但大多数情况下，别的摄影中心并不一定会被成像，即极点不在相片中。如下图&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56cfc2d883aab.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;具体的矩阵运算参考&lt;strong&gt;  &lt;/strong&gt;&lt;a href=&quot;http://www.cnblogs.com/gemstone/archive/2011/12/20/2294551.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;计算机视觉基础4——对极几何(Epipolar Geometry)&lt;/strong&gt;&lt;/a&gt; ，原理为三线同面（下图蓝色区域三边）  &lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/24/56ce77dc874bc.png&quot; alt=&quot;&quot;&gt; &lt;/center&gt;

&lt;p&gt;&lt;strong&gt;其中，E是本质矩阵（Essential Matrix），R是像平面旋转矩阵，T是摄影中心平移矩阵，Pl和Pr分别为左右摄影中心指向同名点P的向量。S由矩阵T决定，具体形式为&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/24/56ce77fc78812.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;strong&gt;本质矩阵&lt;/strong&gt; 采用的是相机的外部参数，也就是说采用相机坐标(The essential matrix uses CAMERA coordinates)，不涉及相机内参数，如果要分析数字图像，则要考虑坐标(u,v)，此时需要用到内部参数(To use image coordinates we must consider the INTRINSIC camera parameters)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 谨记1：Essential Matrix是连结两个摄影中心指向同名点的向量的矩阵，秩为2。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 左向量·E·右向量=0！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; E由两部分组成！E=R·S  E仅由外方位元素决定！一张图记住E!!!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56cfcab0b492e.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由向量引申而出的，是同名点的像素坐标，原理是共线方程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二维同名点&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/26/56d00bc787259.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;上图中推导出对极几何中相当重要的公式，E矩阵作为连接同名点像素坐标而出现，这就意味着，已知求取E的外方位参数，就能求取出左右同名点的对应关系。然而，其中隐含的条件是在共线方程的化简中，默认忽略了镜头畸变。然而这已足够重要，在镜头畸变在拼接中影响不大时，该公式在仅仅知道外方位元素的情况就能解算corresponding point&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;极线方程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同理，由于极点、同名点都位于极线上，因此亦可通过E求得极线的方程（采用相机坐标系）。&lt;/p&gt;
&lt;p&gt;设极线方程为 au + bv + c = 0&lt;/p&gt;
&lt;p&gt;使用齐次坐标，矩阵表示为：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/26/56d01aa83d7d6.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;其中，$\widetilde{p}$是像片任意同名点相机坐标，$\widetilde{l}$是方程系数。又依据同名点公式，$$Ep&lt;em&gt;{l} =\widetilde{l&lt;/em&gt;{r}}$$，所以！对应外极线的方程系数可以直接由E矩阵和本侧同名点求出。其中，$\widetilde{l_{l}}$是左极点对应外极线方程。&lt;/p&gt;
&lt;p&gt;当已知左侧点，其右侧对应点在直线&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/26/56d08c864e4a7.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;当已知右侧点，其左侧对应点在极线&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/26/56d01c07d68ed.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;strong&gt;极点&lt;/strong&gt;&lt;br&gt;&lt;br&gt;别忘了。极点也是在极线上，所以有&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/26/56d0673df0710.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;且，极点属于所有极线，因而&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/26/56d0678f1ddfc.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;上式可用来定位极点的坐标&lt;br&gt;&lt;br&gt;&lt;em&gt; &lt;/em&gt; &lt;em&gt;&lt;br&gt;&lt;br&gt;# &lt;strong&gt; 2.第2个矩阵 Fundamental基础矩阵&lt;/strong&gt;&lt;br&gt;&lt;br&gt;另一个需要提到的概念是基础矩阵。&lt;br&gt;&lt;br&gt;Essential矩阵使用CameraCoords相机坐标系。尽管其中可计算像素坐标，但仍然以摄影中心为原点，像平面所有点z值都是f。当考虑相机内参数时，这就是FundamentalMatrix基础矩阵&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/22/56a2556c54d1d.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;该图显示了fundamentalmatrix（基础矩阵）的基本内涵。p q分别为同名点。计算基础矩阵需要考虑到内参数的仿射变换。M为内参数的矩阵，包含6个参数的3&lt;/em&gt;3矩阵。&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/26/56d069db39519.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;将上式中的Camera坐标提到一边，带入基本矩阵解求对极同名点的方程，即可得到F的表达式.&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/24/56ce7854f3d64.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;上式即为基础矩阵方程。其中，F是基础矩阵，x’x分别为同名点。而左右两个平面的两条极线为，显而易见，F由E和两个内参数矩阵决定。&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/26/56d06ae01c63d.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;类似的，F与E一样都能指同名点坐标在对应极线的关系。下图分别是已知左右点其对应极线的关系。&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/24/56ce78b202e41.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;一个简单的例子，如果从某种方式计算出基础矩阵，则在对应图中即可表示出像素点对应的极线。&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/28/56d3bee0758a5.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;计算出矩阵即为l的三个参数。一般的，调整比例 将前两项的平方和定为1.&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/28/56d3bf4cbf895.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;findfundamentalmat()本意为基础矩阵，是假设两幅图像在同一三维场景中的不同视角。例如立体摄像机，从不同的角度拍摄同一个目标，它解算的是，两幅图像其中一个同名点，与其在外极线同名点的转换关系。它的映射基于三维场景，因此使用这个函数的时候，在不同的视角之间，应该有一个明显的基线。默认使用7点算法拟合数据。基础矩阵把左边图像的一个点的图像坐标与它右边图像中的对应点的图像联系起来，他是一个3x3的退化矩阵，描述了两个立体图像对的外极限几何关系，其计算依赖于在两个图像中相对应的一组点。&lt;/p&gt;
&lt;p&gt;与Homography矩阵（下文提到）不同，它在每组对应点有两组约束：x、y同时作为x’y’的自变量，估算一组对应点只有一行的约束，因为极线约束是标量等式。因此至少需要8个点。所以一般使用8点算法计算F矩阵(8点算法)。&lt;/p&gt;
&lt;p&gt;$$\begin{bmatrix} x^{‘}_i &amp;amp; y^{‘}&lt;em&gt;i &amp;amp; 1 \end{bmatrix} \begin{bmatrix} f&lt;/em&gt;{11} &amp;amp; f&lt;em&gt;{12} &amp;amp; f&lt;/em&gt;{13} \\ f&lt;em&gt;{21} &amp;amp; f&lt;/em&gt;{22} &amp;amp; f&lt;em&gt;{23} \\  f&lt;/em&gt;{31} &amp;amp; f&lt;em&gt;{32}  &amp;amp; f&lt;/em&gt;{33}  \end{bmatrix} \begin{bmatrix} x_i \\ y_i \\ 1 \end{bmatrix}=0$$&lt;/p&gt;
&lt;p&gt;可推到出方程：&lt;/p&gt;
&lt;p&gt;$$ x_i x^{‘}_i {f_11} + x_i y^{‘}_i f_21 + x_i f_31 + y_i x^{‘}_i f_12 + y_i y^{‘}_i f_22 + y_i f_32 + {x_i}^{‘} f_13 + y^{‘}_i f_23 + f_33 =0$$&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/02/29/56d3ed9679e76.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;最终目标是找到ATA的一个特征向量使得它的特征值最小。常用的解法是构造m*9的矩阵A（m是点对数），求解A的奇异值分解，即A=UDVT，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;U是m*m正交矩阵，其列为AAT特征向量&lt;/p&gt;
&lt;p&gt;V是m*n正交阵，其列为ATA的特征向量&lt;/p&gt;
&lt;p&gt;D是m*n对角阵，对角元素为奇异值，平方值为AAT和ATA的特征值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而F是由7个自由度构成的3*3矩阵，其秩为2，因此，讲道理，9个表达式由7个参数构成，因此只用7对对应点理应也能解算出F矩阵（7点算法）。使用此方法计算F矩阵时，需要加上秩为2的限制，以保证计算结果唯一。该方法亦叫做奇异约束。该约束限制假设以F’替代F矩阵，计算时以&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%9F%A9%E9%99%A3%E7%AF%84%E6%95%B8#.E5.BC.97.E7.BD.97.E8.B4.9D.E5.B0.BC.E4.B9.8C.E6.96.AF.E7.AF.84.E6.95.B0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;F范式&lt;/a&gt;作为标准。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/03/29/56fb45459399e.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;其中，$\sigma$是M矩阵的奇异值（A*·A的n个特征值的非负平方根叫作A的奇异值），M=F-F’,可以通过SVD分解解出该奇异值。&lt;br&gt;&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/03/29/56fb506cb6765.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;F由于秩为2的限制可以以以下形式表示：&lt;/p&gt;
&lt;p&gt;F=αF1+(1-α)F2.其中，F1和F2分别Fx=0的两个解。&lt;/p&gt;
&lt;p&gt;由于秩=2，因此det(F=αF1+(1-α)F2)=0,通过该式即可求出α的值。&lt;/p&gt;
&lt;p&gt;更多内容可以看计算机视觉Trifocal tensor三角点张量的部分。&lt;/p&gt;
&lt;p&gt;Caution!&lt;/p&gt;
&lt;p&gt;对图像进行匹配的一个重要步骤就是把两幅图像的极线平行于基线，使得极点处在正无穷，这样的拼接结果效果才能更好。这一重要步骤即为重投影。如下图将黑线投影为蓝线。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/02/29/56d3f1e8a7005.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;对图像进行矫正。需要一个单映矩阵，作两步旋转。其第一步是将极点旋转到无穷远，第二部是将极线平行。其中，左右图像均需要应用该单映聚阵R将极点无穷远化；而右图像需要应用旋转矩阵（E=RS中的R）。最后比例一致化。&lt;/p&gt;
&lt;p&gt;上文中需要构造的矫正矩阵形式为：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/02/29/56d3f5a8ace5f.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;T是单位矩阵，代表左图的极点，可由E计算。其余的参数：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/02/29/56d3f66d34abd.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;整理一下步骤即为：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/29/56d3f7afcf9ce.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;下图即为矫正的例子（两幅图的变化很小，但是从边缘还是可以看到细微的变化），最后把图像的极点都化为无穷远，两幅图基于基线平行。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/29/56d3f7745f920.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;hr&gt;
&lt;h1 id=&quot;3-第二个矩阵-Homography（单映）矩阵&quot;&gt;&lt;a href=&quot;#3-第二个矩阵-Homography（单映）矩阵&quot; class=&quot;headerlink&quot; title=&quot; 3. 第二个矩阵 Homography（单映）矩阵&quot;&gt;&lt;/a&gt;&lt;strong&gt; 3. 第二个矩阵 Homography（单映）矩阵&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;findhomography的前提是2D的转换，本意为单映（包含平移、仿射、尺度三种变换），试图找到一个3*3的投影矩阵，能够把1图中所有的点，通过某种形变，匹配到2图中去。当基线很小的时候(视差变化小，扭曲形变也少)，这个方法能够计算出精度极高的解。&lt;br&gt;当然可以首先参考opencv的&lt;a href=&quot;http://docs.opencv.org/2.4/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html?highlight=findhomography&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt; 这里首先介绍二维映射的单映（homography）矩阵&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/01/23/56a3baf462830.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;该式反应了像点齐次坐标的单映变换的方程。（u v）(u’ v’)分别是左右图像的同名像点坐标。通过一个8个自由度的矩阵P来解算两者之间的关系。p02 p12与平移相关，p00,p01,p10,p11与旋转 尺度和仿射（平行变换）变换有关，p20,p21与拉伸扭曲有关。&lt;/p&gt;
&lt;p&gt;一般的，单映矩阵的计算由以下几个参数构成&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/01/23/56a3bf63f1be0.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;其中，K是相机的内矩阵，由焦距决定；R是主光轴朝向，一般由3个方向余弦决定；C是摄影中心的物方位置。当在原地旋转时，C1-C2为0，因此方程可简化为&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/01/23/56a3c1dd3035a.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;由相机纯粹旋转而形成的单映，自由度3-5（根据是否已知焦距决定）。&lt;/p&gt;
&lt;p&gt;Caution！应该注意到的是，上式中的H3*3矩阵的最后一个元素为1。这里使用到的是计算H矩阵最常用的一种方法，4点算法，即使用4个点即可解算一组H中的8个未知数。在ransac验证外点的过程中，也采用随机4点为一组构建8个方程解算H。&lt;/p&gt;
&lt;p&gt;尽管homography是处理二维点集之间的关系，但倘若三维物体中某些点都处于一个平面，即可设该面的z方向值为0，以三维物方xy值作为像素值与所成像片进行homography的变换。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/24/56ce6ba16113c.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;上图是几种坐标系之间的关系，Mext是外参数矩阵，包含旋转和平移；Mproj是投影矩阵，主要由焦距决定，原理是共线方程；Maff是内参数仿射变换矩阵，由内参数决定。普通的homography是两幅图像像素坐标间或相片坐标间的变换，但上文提到，当三维物体某些点处于一个平面，亦可在World坐标和Film坐标之间进行homography矩阵变换。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/24/56ce6cd71fc88.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;上图可以看到，将三维坐标点z值设为0，[p,q,0,1]即为三维齐次坐标。&lt;/p&gt;
&lt;p&gt;$$ \begin{bmatrix} x \\ y \\ 1&lt;br&gt;\end{bmatrix} \sim \begin{bmatrix} f &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; f &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \end{bmatrix} \begin{bmatrix} r_11 &amp;amp; r_12 &amp;amp; r_13 &amp;amp; t_x \\ r_21 &amp;amp; r_22 &amp;amp; r_23 &amp;amp; t_y \\ r_31 &amp;amp; r_32&amp;amp; r_33 &amp;amp; t_z \\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \end{bmatrix} \begin{bmatrix} p \\ q \\ 0 \\ 1 \end{bmatrix} \sim \begin{bmatrix} fr_11 &amp;amp; fr_12 &amp;amp; ft_x \\ fr_21 &amp;amp; fr_22 &amp;amp; ft_y \\ r_31 &amp;amp; r_32 &amp;amp; t_z \end{bmatrix} \begin{bmatrix} p \\ q \\ 1 \end{bmatrix}&lt;br&gt;$$$$\sim \begin{bmatrix} h_11 &amp;amp; h_12&amp;amp;h_13 \\ h_21 &amp;amp; h_22 &amp;amp; h_23 \\ h_31 &amp;amp; h_32 &amp;amp; h_33 \end{bmatrix} \begin{bmatrix} p \\ q \\ 1 \end{bmatrix}$$&lt;br&gt;最终推到出，3D转2D的投影变换成为2D转2D的变换，该变化可逆！其特例是，当采用的物方坐标系z轴与主光轴平行，即正射影像，则上式R矩阵为&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/24/56ce7aab1b305.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;则上式变形为：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/24/56ce7b0376427.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;该式与相似变换的形式一样，只有4个自由度（tz可化为1），因而正射影像不会产生拉伸形变。（前提是拍摄物体几乎没有深度，几乎处在一个平面）。下图是依照三维中某平面进行拼接，会造成除平面部分其余图像的虚影。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56cf114fc872a.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56cf117891dbb.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;上文中一直讨论的是从物方坐标系到像片坐标系的转换，倘若再加上内方位参数的内矩阵，则可直接导出从物方坐标到像素坐标的公式，如下图示意。内方位参数为仿射变换（Affine 6自由度 保持平行结构的变换）&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56ceb1181fa03.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;将world-&amp;gt;film-&amp;gt;pixel结合起来，对于同一个物体，在某位置某台相机拍摄的照片就可以认为是一个单映H。当然，不同的位置拍摄的像片，各自对应物体的单映是不同的。但由于单映是可逆的，拍摄同一物体的两幅图像，也可以用使用$$H=H&lt;em&gt;{1}H&lt;/em&gt;{2}^{-1}$$&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56ceb83e89a7b.png&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56cebcef9abd7.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;hr&gt;
&lt;h1 id=&quot;4-Homography（单映）矩阵的求取&quot;&gt;&lt;a href=&quot;#4-Homography（单映）矩阵的求取&quot; class=&quot;headerlink&quot; title=&quot; 4. Homography（单映）矩阵的求取&quot;&gt;&lt;/a&gt;&lt;strong&gt; 4. Homography（单映）矩阵的求取&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;参考&lt;a href=&quot;http://www.robots.ox.ac.uk/~vgg/presentations/bmvc97/criminispaper/node3.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;  只要大于4个匹配点，都认为是冗余测量，必须融合数据。文章里提到了三种解求二维面到面的单应矩阵的球法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非线性的解决办法，使用伪逆进行分解。当所解求值为0时会有bug。&lt;/li&gt;
&lt;li&gt;线性最小二乘解法，通常使用SVD分解，V矩阵就对应了最小奇异值。&lt;a href=&quot;http://blog.chinaunix.net/uid-20761674-id-4040274.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个SVD的文章&lt;/a&gt;相当好的解释了SVD分解的意义。八个未知数对应八个特征向量，也对应八个线性方程的解。SVD能直接解求出这八个向量，即V中的特征向量。&lt;/li&gt;
&lt;li&gt;非线性几何解法，使对应点和映射点差值欧几里得距离（或平方和）最小。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Homograhy的计算：计算该矩阵当然不会上式f θ等值直接解算。由于是二维图像之间的关系，一般都已知二维对应点集，直接采用最小二乘的方式使用LM进行计算。在一般情况下的H矩阵可表示为&lt;/p&gt;
&lt;p&gt;$$ \begin{bmatrix} x^{‘} \\ y^{‘} \\ 1 \end{bmatrix} \sim \begin{bmatrix} h_11 &amp;amp; h_12 &amp;amp; h_13 \\ h_21 &amp;amp; h_22 &amp;amp; h_23 \\ h_31 &amp;amp; h_32 &amp;amp; h_33 \end{bmatrix} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}$$&lt;/p&gt;
&lt;p&gt;其中，$h_31 h_32 h_33$是为了配置相似比例，化简为&lt;/p&gt;
&lt;p&gt;$$x^{‘}=\frac{h_11 x + h_12 y + h_13 }{ h_31 x + h_32 y + h_33 }$$&lt;/p&gt;
&lt;p&gt;$$y^{‘}=\frac{h_21 \cdot x + h_22 y + h_23 }{ h_31 x + h_32 y + h_33 }$$&lt;/p&gt;
&lt;p&gt;但可以看到，h所有元素同乘k 等式依旧成立。因而强制设为8自由度有两种方式，&lt;/p&gt;
&lt;p&gt;①$$ h_{33} = 1 $$&lt;/p&gt;
&lt;p&gt;②$ h&lt;em&gt;{11}\^{2} + h&lt;/em&gt;{12}\^{2} = 1 $&lt;br&gt;采用第一种方式较为常见。&lt;br&gt;当采用最小二乘解求H矩阵时，一般先用Ransac筛选最大集，然后利用下方程。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56cf041a7c664.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;以x y x’y’为A b矩阵参数，迭代解求H。由于是线性方程，因而可以直接使用$$h=(A^{T}A)^{-1}(A^{T}b)$$求取每次的残差。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56cf051be79bc.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;&amp;lt;font color=”#ff0000”&amp;gt;Caution！应该注意到的是，该方法对噪声极其敏感，即使没有外点（outliers）,因而，在计算前对数据里筛选就非常重要。为更好的得到结果，Ransac时可以将该组数据质心重置到原点；然后缩放比例使得各点到原点的平均距离是根号二。如下图，H的表达式。T、S分别为平移和缩放的矩阵。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56cf08c613352.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;如何判断这两幅图像确实匹配呢？记该区域的特征点总数为nf，而符合H的特征点（内点）数量为nj，如果两者比例足够大，说明两幅图像确实匹配。但一般拼接时都确认两幅图像有重叠面积才计算H。变换模型H计算时的误差可表述为Huber模型：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56cf0b53675d9.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;同时，由于矩阵具有可逆性，因此图像12之间的H1和图像23之间的H2可以直接推导出图像13之间的H3。但大量的单映队列并不推荐，这样会造成误差成倍扩大。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56cf0eb50a41b.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;strong&gt; 谨记二 &lt;/strong&gt;：homography处理的是纯粹的二维与二维之间的变换。即便特例是3D也是视为在2D的单映和相似变换。在旋转相机和正射拼接可以得到良好的二维拼接效果，在具有深度的三维物体，拼接会造成虚影！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这两个函数都是基于特征点的变换模型求解，既然特征点已找出且筛查得到更正确的点，因此对图像外观的变化具有鲁棒性（尺度、光照、旋转等）。选择哪种函数基于图像间的关系，即立体场的观测使用fundamentalmatrix（视角矫正 三维全景 街景视角）,而相对平面化的则使用findhomography（全景拼接  航摄图像拼接 ）&lt;/p&gt;
&lt;p&gt;解求这个变换模型一般基于线性最小二乘的方式，与平差原理类似，利用冗余的数据（大量同名点）来解算参数。一般的，先通过Ransac筛查数据比较靠谱。&lt;/p&gt;
&lt;h1 id=&quot;谨记三：&quot;&gt;&lt;a href=&quot;#谨记三：&quot; class=&quot;headerlink&quot; title=&quot;** 谨记三：&quot;&gt;&lt;/a&gt;** 谨记三：&lt;/h1&gt;&lt;p&gt;homography 单映处理二维坐标系与二维坐标系关系，特例情况下是三维物体某平面可视为二维平面。更特例的是正射影像（相似变换）和旋转摄影全景拼接（C1-C2=0）（处理对应点集与点集的关系）矩阵可逆，具有结合性。&lt;/p&gt;
&lt;p&gt;fundamental针对的是点和极线的关系（处理点集与极线集的关系），可用来在寻找匹配点的时候快速查找对应点。（以像素为坐标系）&lt;/p&gt;
&lt;p&gt;essential 本质是连结同名点向量的矩阵（以像空系为标准）&lt;/p&gt;
&lt;p&gt;参考。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/u010141025/article/details/16920567&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【opencv】特征点检测方法–GFTT，SIFT，FAST，SURF&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cse.psu.edu/~rtc12/CSE486/&quot; title=&quot;http://www.cse.psu.edu/~rtc12/CSE486/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cse.psu.edu/~rtc12/CSE486/&lt;/a&gt; 宾州州立大学计算机视觉&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://opencv-users.1802565.n2.nabble.com/Difference-between-homography-and-fundamental-matrix-td6359087.html&quot; title=&quot;http://opencv-users.1802565.n2.nabble.com/Difference-between-homography-and-fundamental-matrix-td6359087.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://opencv-users.1802565.n2.nabble.com/Difference-between-homography-and-fundamental-matrix-td6359087.html&lt;/a&gt; homography and fundamental matrix的讨论&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://homepages.inf.ed.ac.uk/rbf/CVonline/&quot; title=&quot;http://homepages.inf.ed.ac.uk/rbf/CVonline/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://homepages.inf.ed.ac.uk/rbf/CVonline/&lt;/a&gt; 爱丁堡大学计算机视觉在线课件&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.robots.ox.ac.uk/~vgg/hzbook/hzbook2/HZepipolar.pdf&quot; title=&quot;https://www.robots.ox.ac.uk/~vgg/hzbook/hzbook2/HZepipolar.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.robots.ox.ac.uk/~vgg/hzbook/hzbook2/HZepipolar.pdf&lt;/a&gt; 牛津大学计算机视觉中的多视几何&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://120.52.72.36/www.umiacs.umd.edu/c3pr90ntcsf0/~ramani/cmsc828d/lecture27.pdf&quot; title=&quot;http://120.52.72.36/www.umiacs.umd.edu/c3pr90ntcsf0/~ramani/cmsc828d/lecture27.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://120.52.72.36/www.umiacs.umd.edu/c3pr90ntcsf0/~ramani/cmsc828d/lecture27.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;马里兰大学高级计算机研究&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/gemstone/articles/2294551.html&quot; title=&quot;http://www.cnblogs.com/gemstone/articles/2294551.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/gemstone/articles/2294551.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://imagine.enpc.fr/~monasse/Stereo/4Fundamental.pdf&quot; title=&quot;http://imagine.enpc.fr/~monasse/Stereo/4Fundamental.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://imagine.enpc.fr/~monasse/Stereo/4Fundamental.pdf&lt;/a&gt; 法国国立桥梁与公路学校Ecole Nationale des Ponts et Chaesses计算机视觉和图像&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;openCV中有两个函数，findhomography和findfundamentalmat，长的很像。。一开始严重的弄混，以为都是求对应点投影矩阵的公式，万万没想到其实是两个完全不同的内涵。😒&lt;br&gt;
    
    </summary>
    
      <category term="什么都学一下" scheme="http://ovjaywang.github.io/categories/%E4%BB%80%E4%B9%88%E9%83%BD%E5%AD%A6%E4%B8%80%E4%B8%8B/"/>
    
      <category term="学习log" scheme="http://ovjaywang.github.io/categories/%E4%BB%80%E4%B9%88%E9%83%BD%E5%AD%A6%E4%B8%80%E4%B8%8B/%E5%AD%A6%E4%B9%A0log/"/>
    
    
      <category term="opencv" scheme="http://ovjaywang.github.io/tags/opencv/"/>
    
      <category term="计算机视觉" scheme="http://ovjaywang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>社交App的2015</title>
    <link href="http://ovjaywang.github.io/2016/01/18/%E7%A4%BE%E4%BA%A4app%E7%9A%842015/"/>
    <id>http://ovjaywang.github.io/2016/01/18/社交app的2015/</id>
    <published>2016-01-18T03:45:06.000Z</published>
    <updated>2016-04-29T09:13:23.592Z</updated>
    
    <content type="html">&lt;p&gt;手机和网络重度使用患者也该是总结自己的时候了。庆幸的是各大app都热推了自己的2015数据流。把去年的数据库做个直白的excel统计。好吧。。我除了听歌看电影买买买也没别的(性)生活了。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b74dab78e7.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;进入微信还算比较早的。和我的两个基友都是300w内。但是潜水了快3年才在快毕业的时候旅行发了一条盆友圈。曾一度抗拒盆友圈这个类似空间的东西。当然大学的社交网络还是集中在“找人人上同学”的人人网。。毕竟各大校园通知新闻、文娱八卦、技术贴以及各种曾在校园见过又不知道是谁的人终于知道叫什么名字了。。还曾一度影响了各类插件的发展、影响了谁来看过我我被多少人看过的各类访问人数的截图。。现在看来。。大家当年都是一个水平的嘛&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b765a8c8ed.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;快一年也没旅游了。说是没时间不如说是没人陪。。只有寒假去东三省和海南度假算是正经的轻松了一回。不过上海的cj也是满满的收获。。红包多是借钱还钱。。。才没有人给我发红包呢。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b76c34f72d.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;惨淡的人际网并不像急于拓展。收货了太多的信息来源反倒不如维护好几个重要的人。。还未曾到需要攀龙附凤的阶段。充实自己吧。用了一段时间的手环终究是没有逃过不出一年就坏掉的命运。。所以微信运动总是几百米的步数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b8cd37fbf6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其实点口碑外卖并不多。。不知道它计算了别的外卖支付没有。。。想想也就吃了下半年则么会这么多。。或许是把优惠支付也算进去了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b8d469df74.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;除了一个月试了试微信的信用卡还款基本都在支付宝还款了。。后面几个月已经扒不到网易邮箱的信用卡账单了。。每次都要手动输金额也是好烦。。生产力还没达到一定程度消费就花了这么多了。。手机充值的方式越来越多样化。总之和外卖 电影一样 谁便宜去谁家。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b8dfc35999.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;大部分能用华北的地方都没主动用。。第一推荐的基本没人会主动换掉。。港真。芝麻信用分还是挺有用的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b92b0b7ced.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;常年有1w余额。。这年利率越来越低了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b9351c9783.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;大多数买买买都是电子产品。。两个手机。两个耳机。。单反。。品质的一年。旅游真的变少了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b99e34fd85.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;比格这么高的音乐软件入碗了入碗了！！毕竟还是个网易最早用户呢&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b9a1dc8bf6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上班听歌狗。。。没歌没效率的最佳代言人。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b9a48e60dc.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;真是李荣浩狗。。陈粒狗。。李志狗。。还是国语歌听的比较顺耳&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b9a7cebaa4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;喂喂喂！！要你管啦！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b9a99a92ea.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;是的！都怪你拉！&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/01/17/569c588aa63d8.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;也是由于从村里搬到了城里。本以为8.8的电影算是捡了大便宜。妹想到4块钱看了个星战。闲来无事，也只能有看电影能消遣了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569c5ae2d384a.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;也是被自己的频率吓到。。毕竟前半个年基本没有机会看到电影院。。。或许是回忆标记的电影略多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/01/17/569c587a5e523.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;电影院基本四星以下。唯独记得的几部看的相当爽的只有【师傅】【暗杀】【心迷宫】其他的五星基本在补电影。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/01/17/569c58890e21e.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;毕竟是互联网社交的先驱。极客的事业之道&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/01/17/569c588ab1ec6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;港真。自尊心在受到歧视的人群更显得珍重。民族歧视、种族歧视、地域歧视，如果解决不好，就不是花钱能够应付的了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/01/17/569c588c1f10b.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;第一次对动画电影这么赞叹，不愧是日本的高分动画。不愧是宫崎骏老师的配乐&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/01/17/569c5897d8f92.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;好吧。。容我矫情一回好了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/01/17/569c588d50b2d.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;也不知道寒假怎么了。应该是约约约才对的阿。三月四月完全没有流量下电影。。也无心恋战。沉迷健身、跑步、羽毛球、课设、、、&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569c5c4cdd158.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;豆瓣电影和豆瓣app相当混淆。。不知道应该取舍哪一个&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569c5c7918c03.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;       &amp;amp;lt;p&amp;amp;gt;果然是2月挖坟了过往的很多电影。。毕竟也是太闲了这样算下来和前一年看的就差不多了&amp;amp;lt;/p&amp;amp;gt; &amp;amp;lt;p&amp;amp;gt;&amp;amp;lt;img src=&amp;quot;http://ooo.0o0.ooo/2016/01/17/569c5cba269c4.png&amp;quot;&amp;amp;gt;&amp;amp;lt;/p&amp;amp;gt; &amp;amp;lt;p&amp;amp;gt;&amp;amp;lt;img src=&amp;quot;http://ooo.0o0.ooo/2016/01/17/569c5cf85db53.png&amp;quot;&amp;amp;gt;&amp;amp;lt;/p&amp;amp;gt; &amp;amp;lt;p&amp;amp;gt;虽然口味较重。但类型没有特别偏颇的。反倒是对美帝的电影相当喜爱。&amp;amp;lt;/p&amp;amp;gt; &amp;amp;lt;p&amp;amp;gt;&amp;amp;lt;img src=&amp;quot;http://ooo.0o0.ooo/2016/01/17/569c5d1f44a7d.png&amp;quot;&amp;amp;gt;&amp;amp;lt;/p&amp;amp;gt;    &amp;amp;lt;p&amp;amp;gt;虽然很爱大咪咪。但演的渣还是不能同情的。。虽然艾玛斯通对你国态度相当恶劣。但演得好还是要乖乖献出5分。&amp;amp;lt;img src=&amp;quot;http://ooo.0o0.ooo/2016/01/17/569c5d7f7dbe0.png&amp;quot;&amp;amp;gt;&amp;amp;lt;/p&amp;amp;gt; &amp;amp;lt;p&amp;amp;gt;第一部是欠的电影票。。第二部是第一次看到了电影院娇嗔的妹子。。第三部是18.8看了个imax。。我是奇葩恩恩我承认好了&amp;amp;lt;/p&amp;amp;gt; &amp;amp;lt;p&amp;amp;gt;&amp;amp;lt;img src=&amp;quot;http://ooo.0o0.ooo/2016/01/17/569c5dc6997cf.png&amp;quot;&amp;amp;gt;&amp;amp;lt;/p&amp;amp;gt; &amp;amp;lt;p&amp;amp;gt;港真。。特工学院这剧情和特效能看？还有那操蛋的英伦腔。
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;手机和网络重度使用患者也该是总结自己的时候了。庆幸的是各大app都热推了自己的2015数据流。把去年的数据库做个直白的excel统计。好吧。。我除了听歌看电影买买买也没别的(性)生活了。&lt;br&gt;
    
    </summary>
    
      <category term="槽" scheme="http://ovjaywang.github.io/categories/%E6%A7%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>[汇总]Pc Android iOS传输文件</title>
    <link href="http://ovjaywang.github.io/2016/01/04/pc-phone-communication/"/>
    <id>http://ovjaywang.github.io/2016/01/04/pc-phone-communication/</id>
    <published>2016-01-03T16:35:49.000Z</published>
    <updated>2016-04-29T09:13:23.590Z</updated>
    
    <content type="html">&lt;p&gt;曾写过一个这个&lt;a href=&quot;http://www.dooby.me/?p=473&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.dooby.me/?p=473&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然而时过境迁很多出彩的多客户端文件传输的app已经出来了。。本篇主要提&lt;font color=&quot;#FF0000&quot;&gt;多客户端的文件无线传输&lt;/font&gt;，忽略笔记类和书签类。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.Airdroid3.1.6 &lt;a href=&quot;http://coolapk.com/apk/com.sand.airdroid&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://coolapk.com/apk/com.sand.airdroid&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/68eb7c93jw1ezmt5t987jj20u01hcn0w.jpg&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/68eb7c93jw1ezmt66mv43j20u01hctby.jpg&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/68eb7c93jw1ezmt76fl5dj20u01hc77z.jpg&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/68eb7c93jw1ezmt7qh365j20u01hctc6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;tips：只能在安卓与电脑、安卓之间传输，需要注册登录账号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/68eb7c93jw1ezms9x6npaj20f403s0th.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;鹅妹子赢：除了强大的win客户端（网页端）无线文件（夹）传输外，还有照片音频视频管理、手机通知&lt;font color=&quot;#FF0000&quot;&gt;桌面提示（低头党福音）&lt;/font&gt;、通讯录短信管理、截屏、&lt;font color=&quot;#FF0000&quot;&gt;apk卸载及下载&lt;/font&gt;，收发短信！电话接打！&lt;font color=&quot;#FF0000&quot;&gt;寻找手机&lt;/font&gt;！！（黑科技啊）。连接过的设备支持&lt;font color=&quot;#FF0000&quot;&gt;直接唤醒连接&lt;/font&gt;（只要都在联网状态下，无论同wifi、异wifi甚至是移动数据网络）。还支持&lt;font color=&quot;#FF0000&quot;&gt;桌面鼠标直接操控手机&lt;/font&gt;的airmirror！！简洁干净，效果拔群，关键&lt;font color=&quot;#FF0000&quot;&gt;美美美&lt;/font&gt;！！！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/68eb7c93gw1ezom8kr3ksj21he0q2q8x.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;web平台远程唤醒&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/68eb7c93gw1ezomaz9flsj21h90qrgw9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;web平台主界面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/68eb7c93gw1ezomc357sjj21h10qt1d1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;bug级别的手机查找&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/68eb7c93gw1ezoniqrfh4j20x90o1jw0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Airmirror直接用鼠标代替手势&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/68eb7c93gw1ezonwxogcxj20ci03yt8x.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;同样是bug级别的桌面通知提示。还可直接回复短信&lt;/p&gt;
&lt;p&gt;网络条件：&lt;/p&gt;
&lt;p&gt;电脑可在win客户端或web网页操作 手机需安装客户端。（win↔Android；Android↔Android）&lt;/p&gt;
&lt;p&gt;近距离传输 可在同wlan网络下，或手机自建热点，或无网络状况通过USB管理手机连接，通过FTP+端口的形式传输；远距离直接通过账号共享传输&lt;/p&gt;
&lt;p&gt;文件格式：Android客户端可发送筛选过的有图片、直接拍照、视频、音频、已接受文件及所有SD卡下内容；Win下可直接拖动文件夹（需premium）、任意文件发送&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#FF0000&quot;&gt;注：&lt;/font&gt;Android间不可互传apk，分享出去是play的链接。只能在win下载apk&lt;/p&gt;
&lt;p&gt;测速：&lt;/p&gt;
&lt;p&gt;1G的视频 web端&amp;nbsp; 在2G的wifi下达到3MB/s 用时 5分13秒。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/68eb7c93jw1ezmszm05i9j20lz047gmo.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;2.快牙3.6（国际版）&lt;a href=&quot;http://coolapk.com/apk/com.dewmobile.kuaiya.play&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://coolapk.com/apk/com.dewmobile.kuaiya.play&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;tips:强大的三平台互传 起家早 然后堕落了 加入一堆没用的游戏和功能&lt;/p&gt;
&lt;p&gt;饿妹子赢：支持wifi 热点 蓝牙各种乱七八糟的方式。能互传apk！能无账号扫码传输！&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;3.Xender&lt;/p&gt;
&lt;p&gt;4.茄子助手&lt;/p&gt;
&lt;p&gt;5.微信&amp;amp;qq手机助手&lt;/p&gt;
&lt;p&gt;6.百度云&lt;/p&gt;
&lt;p&gt;7.闪传&lt;/p&gt;
&lt;p&gt;8.SuperBeam&lt;/p&gt;
&lt;p&gt;9.极助手&lt;/p&gt;
&lt;div class=&quot;PoweredByWebStory&quot; style=&quot;margin-top:15px;margin-bottom:10px&quot;&gt;&lt;a href=&quot;http://sns.juziyue.com/webinvite.php?u=94887&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&amp;nbsp;今天你&lt;a href=&quot;http://sns.juziyue.com/webinvite.php?u=94887&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;菊子曰&lt;/a&gt;了么？&lt;/div&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;曾写过一个这个&lt;a href=&quot;http://www.dooby.me/?p=473&quot;&gt;http://www.dooby.me/?p=473&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然而时过境迁很多出彩的多客户端文件传输的app已经出来了。。本篇主要提&lt;font color=&quot;#FF0000&quot;&gt;多客户端的文件无线传输&lt;/font&gt;，忽略笔记类和书签类。&lt;br&gt;
    
    </summary>
    
      <category term="软件测评" scheme="http://ovjaywang.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%84/"/>
    
      <category term="软文" scheme="http://ovjaywang.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%84/%E8%BD%AF%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Android为毛耗电[2]</title>
    <link href="http://ovjaywang.github.io/2016/01/01/Android%E4%B8%BA%E6%AF%9B%E8%80%97%E7%94%B5%5B2%5D/"/>
    <id>http://ovjaywang.github.io/2016/01/01/Android为毛耗电[2]/</id>
    <published>2016-01-01T15:32:08.000Z</published>
    <updated>2016-04-29T09:13:23.589Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;&lt;font size=&quot;4&quot; face=&quot;华文中宋&quot;&gt;本文只讨论安卓手机软节电，不负责推荐底包、rom、调频调压方案，刷机root&lt;font color=&quot;#ff0000&quot;&gt;后果自负&lt;/font&gt;。&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;font size=&quot;4&quot; face=&quot;华文中宋&quot;&gt;本小节只讨论干货。在root及xposed框架下。同时兼顾不能肉身翻墙又想用google服务的小狗们。本人的使用情况是正常功能照开，google需要gmail和google photo及部分gcm，黑屏开启手势和解锁，正常收微信、闹钟、短信电话外熄屏一切不开，后台常开应用有snap锁屏、grenntify绿色守护、调音的audio mix、天气插件、BBS、输入法、Nova Launcher。测试的环境为Android L 5.1.1&lt;/font&gt;

&lt;font size=&quot;4&quot; face=&quot;华文中宋&quot;&gt;&amp;nbsp;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;em&gt; &lt;/em&gt; *&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#ff0000&quot;&gt;App干货推荐&lt;/font&gt;&lt;/font&gt;

&lt;p&gt;&amp;nbsp;&lt;a href=&quot;http://coolapk.com/apk/com.oasisfeng.greenify&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://coolapk.com/apk/com.oasisfeng.greenify&lt;/a&gt; 绿色守护（评论好多捐赠包）国内优秀开发者–唤醒对其 深度休眠hibernateservice &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://coolapk.com/apk/com.asksven.betterbatterystats&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://coolapk.com/apk/com.asksven.betterbatterystats&lt;/a&gt;BetterBatteryStats（捐赠包只多了小插件和知识库） 国外应用（使用稳定后可删，留着也不费电）–查看耗电最多的程序 资源 频率占比 &lt;a href=&quot;http://coolapk.com/apk/com.uzumapps.wakelockdetector&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://coolapk.com/apk/com.uzumapps.wakelockdetector&lt;/a&gt; wakelock detector（使用后可删，被注册为系统程序，留着不太费电）–查看被CPU 屏幕 时钟唤醒的程序以便将其控制 可以便利的&lt;font color=&quot;#ff0000&quot;&gt;结合绿色守护使用&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://coolapk.com/apk/ccc71.at&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://coolapk.com/apk/ccc71.at&lt;/a&gt; 安卓调谐器:3C Toolbox（Android Tuner）–系统调节&lt;font color=&quot;#ff0000&quot;&gt;神器&lt;/font&gt; 控制自启 控制软件权限 自大组件控制 cpu调节 自动内存调节&lt;/p&gt;
&lt;p&gt;一张图解释大部分唤醒、杀进程软件的思路&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/68eb7c93gw1ezs65djw3nj20tx0pn0xp.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;————————喂下面几个是一类 看清楚需求———————————&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://coolapk.com/apk/com.linangran.nowakelock&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://coolapk.com/apk/com.linangran.nowakelock&lt;/a&gt; 禁止唤醒1.2.1 （国内开发者）–只能禁5个 暂未发现捐献包 主程序调用捐助包需要与play验证。但也不贵才十几块。 但是禁止效果良好 百度 阿里 系的随便禁一两个就发现效果超级棒 就是挺贵 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://coolapk.com/apk/me.piebridge.forcestopgb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://coolapk.com/apk/me.piebridge.forcestopgb&lt;/a&gt; 阻止运行 国内开发者，免费!–阻止后台、前台、服务及可见的各种组件 不限数目 限制谷歌服务效果良好 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://coolapk.com/apk/com.ryansteckler.nlpunbounce&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://coolapk.com/apk/com.ryansteckler.nlpunbounce&lt;/a&gt; 唤醒控制amplify3.3.4–可以查看唤醒次数&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr&gt;
&lt;font color=&quot;#ff0000&quot;&gt;电量消耗结构总结&lt;/font&gt;

&lt;p&gt;对于电量，总有一些是必然会消耗的，一些是可以减少的，而一些是可以避免的。那么，对于不同状态下那些成分占的比例会占比略高呢？&lt;/p&gt;
&lt;p&gt;1.正常使用状态下（Screen on）：无容置疑的是屏幕的发亮，因而合适的调低亮度能更大的省电，尤其是主动发光的amoled使用深色主题会更省电。当然，大部分使用状态，需要更多的网络连接，4G&amp;gt;3G&amp;gt;2G&amp;gt;wifi是显而易见的。同时使用不同类型的App也会让CPU频率相应的上升，尤其是大型3D网游和功放影音体验。&lt;/p&gt;
&lt;p&gt;正常开机使用，耗电排行一般为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;屏幕发亮  &lt;/li&gt;&lt;li&gt;高CPU占用的App ，包括某些情况下刷帖、浏览网页等长时间交互行为  &lt;/li&gt;&lt;li&gt;手机通信（联网、移动通话、视频通话）  &lt;/li&gt;&lt;li&gt;Android系统  &lt;/li&gt;&lt;li&gt;手机待机 ，即Android OS 之类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.正常待机状态下（Screen off）包括唤醒和睡眠、深睡眠。当然，大部分人都希望手机进入Idle正常无唤醒的状态，达到hibernate。但国产App可不会这么干。对于待机来说两大耗电来源就是alarm计时器唤醒各类监听进行后台操作、偷跑流量、不必要的消息推送；wakelock把持唤醒锁让手机无法进入深睡眠从而维持后台服务。&lt;/p&gt;
&lt;p&gt;正常待机状况下，不飞行，不关闭数据网络，关闭GPS、wifi、蓝牙等，耗电排行是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;手机通信 Cell Standy之类。这一块比较大，依赖数据网络的制式  &lt;/li&gt;&lt;li&gt;Android OS（即BBS的Kernel wakelock或partial wakelock标记为Android的）  &lt;/li&gt;&lt;li&gt;手机待机 （PowerManagerService 及Device Idle之类的）处理休眠状态下设备监听及唤醒锁的管理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;开启wld和bbs的实时监控，把该装的常用软件装上&lt;font color=&quot;#ff0000&quot;&gt;先用着那么一段时间。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;/p&gt;
&lt;p&gt;①利用这段时间 把权限都给干了 装软件给你显示了一list的权限然并卵 不同意没法装 装了也没几个需要的&amp;nbsp; 在【应用程序权限】的设置框中把权限悉心的扫个遍 曾经启用过的权限会有提示何时使用过 例如我把美团外卖的权限全禁了 然而还是可以正常使用&lt;/p&gt;
&lt;p&gt;目标是：给app只留必要的权限 像读取短信直接get验证码那些权限就不必了，重点关注权限里的【&lt;font color=&quot;#ff0000&quot;&gt;保持唤醒&lt;/font&gt;】。这个权限意味着能在熄屏时候对手机进行唤醒操作，在亮屏时能够保证数据一致性。没有必要进行推送和同步的应用就应该关闭。&lt;/p&gt;
&lt;p&gt;②利用小汽车autostat或者3c toolbox自带的自启动控制器 控制不需要自行启动的项目 除了launcher greentify 3c tool box类似物 等系统框架 其余全都不需要 不需要不需要&lt;/p&gt;
&lt;p&gt;目标是：启动速度棒 未启动的应用不会推送任何消息 （微信 微博 GMail等可以排除）&lt;/p&gt;
&lt;p&gt;③给app一点微弱的信任，试着在app的设置中，关掉消息推送、wifi下自动更新、wifi下同步等设置，稍微有点技术含量的程序猿都会在设置取消时cut掉后台进程。&lt;/p&gt;
&lt;p&gt;④对于各种传感器，依据需求关闭能很好的节约电量（这一块和rom的优化很大关系）例如黑屏手势、人脸解锁、黑屏解锁、口袋检测等。&lt;/p&gt;
&lt;p&gt;⑤利用系统的电量统计和后台开启程序大致了解本机运行的大消耗后台。例如本机待机时系统消耗的比例想当高。同时保持着很高的唤醒状态。。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;#ff0000&quot;&gt;系统的电量统计&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/68eb7c93gw1ezrv30mvwcj20u01hc435.jpg&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/68eb7c93gw1ezrv0fux6ej20u01hc0x7.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;点开正在运行的后台，可以看本机Android系统和Android操作系统电量消耗高的原因是高通CPU的定位服务。经过调校后的曲线，可以看到中度使用后，待机超过了一个天。同时待机时休眠比例也超过了8成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/10/5693136395d1a.png&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/10/569313c0b6950.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2.使用过后 开启betterbatterystats和wakelock detector&lt;/p&gt;
&lt;p&gt;D1 2016/1/6&lt;/p&gt;
&lt;p&gt;①&lt;font color=&quot;#ff0000&quot;&gt;&lt;strong&gt;betterbatterystats BBS&lt;/strong&gt;&lt;/font&gt;查看耗电大户 一般来说googleservice由于不能随时翻 会造成gmail keep backup contacts 都会发送心跳包不停的连接 此外 除了显而易见的三大流氓滥用唤醒锁 相互唤醒 外 还有奇形怪状的耗电大户 如location定位 微信 &lt;/p&gt;
&lt;p&gt;官方帮助指南：&lt;a href=&quot;http://better.asksven.org/bbs-how-to/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://better.asksven.org/bbs-how-to/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;应用beta版及正式版更新日志 &lt;a href=&quot;http://forum.xda-developers.com/showthread.php?t=1179809&quot; title=&quot;http://forum.xda-developers.com/showthread.php?t=1179809&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://forum.xda-developers.com/showthread.php?t=1179809&lt;/a&gt;&amp;nbsp; 包含apk下载。捐助包多了知识库和小控件。&lt;/p&gt;
&lt;p&gt;它承诺不在后台记录电量，只在开机、断开充电器、插上充电器、亮屏、熄屏。custom是自定义的操作记录，current是当前时间截止的电量消耗的样本。它提供了后台电量实时监控，这会消耗一定的电量；同时提供了进程监控，并对唤醒次数超过阈值的进行提示。&lt;font color=&quot;#ff0000&quot;&gt;右侧的圈圈一律代表该应用、该服务、该定时器在所选时间段的使用时间比例&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;Entries：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/68eb7c93gw1ezp07m935cj20u012saci.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;font color=&quot;#ff0000&quot;&gt;other&lt;/font&gt;——睡眠、唤醒、亮屏等其他重要时间节点的电量消耗数据【深睡眠、熄屏唤醒、亮屏、通话时间、wifi开启时长、wifi连上时长、蓝牙开启时长】&lt;br&gt;&lt;br&gt;&lt;em&gt;   一般选择unplugged-current 即断电后到现在 一般熄屏情况下 要么deep sleep要么awake，所以两者相加应该是100%。  &lt;li&gt;（Awake）Screen off显示了熄屏时被唤醒所占比例 可以很直观的感受手机离开操作后后台运作的程度 最优的情况当然是0%，手机处于最节能的状态（之前的版本将awake&amp;amp;screen off分开计时 需要两个数据一起对比）  &lt;/li&gt;&lt;li&gt;此外，还有wifi 启动、wifi运行与唤醒的关系，很明显，在晚上断开wifi会给手机更好的进入休眠&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#ff0000&quot;&gt;kernel wakelocks&lt;/font&gt;——使手机唤醒的内核操作【大量的短暂唤醒会严重影响唤醒时间导致手机消耗更多的时间返回睡眠】

&lt;/li&gt;&lt;/em&gt;   重点关注项目-PowerManagerService wakelock和multipdp、svnet-dormancy wakelock。前者是激活大部分app的唤醒锁服务，如果它占第一位，则取partial wakelocks关注唤醒时间较多的项目；后者是网络使用量，若存在后台偷跑流量的软件，可以很明显的发现异常，到network数据栏中看一下。  &lt;li&gt;kernel wakelock中的alarm是所有定时器的总和 基本不耗电 但如有异常 可到alarms或amplify中查看详细的计时器项目。  &lt;/li&gt;&lt;li&gt;&lt;em&gt;sync&lt;/em&gt; &lt;em&gt;backup&lt;/em&gt; &lt;em&gt;job&lt;/em&gt;很明显是系统的操作 同步 备份 消息推送 如果不需要就禁了吧&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#ff0000&quot;&gt;partial wakelocks&lt;/font&gt;——是大部分app把持的唤醒锁。（PowerManagerService高的可以关注这项）&lt;br&gt;&lt;br&gt;&lt;em&gt;   根据使用频率来限制大耗电partial wakelock 如ig tw fb wb wx等。可以在后文自行设置后台计时器时间。  &lt;li&gt;卸载/冻结/不可用 这些做法有些极端 但实在忍无何忍下还是放弃这个app吧。钛备份下的冻结就比较好用 对google系的后文提到。  &lt;/li&gt;&lt;li&gt;主动手动开关GPS。使用时才打开。  &lt;/li&gt;&lt;li&gt;根据需要使用后退键退出还是home键退出  &lt;/li&gt;&lt;li&gt;wifi是个奇葩 晚上记得关（If you don’t need Wifi turn it off: in some cases Wifi is known to cause wakeups and an overhead in e.g. location services）  &lt;/li&gt;&lt;li&gt;一次不要改太多，一次一次改 能对手机每个app和每个设置有直观的体验和感受&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#ff0000&quot;&gt;alarms&lt;/font&gt;——由于应用及服务的定时器唤醒手机【apps设定的触发器在某个时间节点唤醒手机，某些alarms只在唤醒时执行、另一些则直接唤醒手机。通常一个alarm绑定一个intent】

&lt;/li&gt;&lt;/em&gt;   长时间和过高次数的alarm都是不正常的。一定要及时纠出。例如微信这狗。  &lt;/li&gt;&lt;li&gt;更多的alarm应该在手机亮屏时启动 除了闹钟、微信等必要的消息之外 如知乎提醒、百度外卖提醒等应用，按照使用习惯，更应该是熄屏时完全关闭计时器。&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#ff0000&quot;&gt;network&lt;/font&gt;——app的网络使用率【区分3G和wifi的网络连接数据】&lt;br&gt;&lt;br&gt;&lt;em&gt;   相当多的工具都能查看网络传输的状态。系统自带的也不错。  &lt;li&gt;信号较弱的wifi或窝蜂数据会频繁的连接并唤醒手机&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#ff0000&quot;&gt;CPU states&lt;/font&gt;——不同CPU频率所占用的时间【包括深度睡眠时的CPU频率占用时间】&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#ff0000&quot;&gt;Processes&lt;/font&gt;——用户及系统进程消耗的CPU时间【进程CPU消耗，分为用户及系统，以不同颜色标识】&lt;br&gt;&lt;br&gt;进阶功能：&lt;br&gt;&lt;br&gt;【&lt;font color=&quot;#ff0000&quot;&gt;Watchdog&lt;/font&gt;】——熄屏分析功能，可自定义亮屏、解锁等。对唤醒超过阈值的app和service进行提示，可在熄屏后一定时间对watchdog关闭。&lt;br&gt;&lt;br&gt;【&lt;font color=&quot;#ff0000&quot;&gt;Active Monitoring&lt;/font&gt;】——后台运行的一定时间间隔的数据采集，可能会造成额外耗电。&lt;br&gt;&lt;br&gt;观察一下本机的耗电比例，首先看到other中，Awake(Screen Off)的比例相当高，在其他人的截图是有deep sleep的！！！我安的软件已经炸裂了。尽管开启了wifi会消耗更多的电量，但大量的唤醒让手机不能正常进入休眠。&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/68eb7c93gw1ezrv6kd1wgj20u01hcaep.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt;再观察partial wakelock ，除了gmail可能不顺利的同步导致消耗略多外，其余app都还算正常的耗电（注意关注连接时间，最多的也才3m35s，这在8h14m11s里来说是相当小的比例，同时消耗的电量也只有0.7%，还可以接受。当然是提前锁过了一部分app的后台）&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/68eb7c93gw1ezrv97d35sj20u01hc7ci.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt;注意力关注到kernel wakelock，可以看到，核心的耗电量还是比较大的（由于之前的耗电太过大已经关闭了锁屏手势和黑屏解锁）。可以明显的看到，wlan联网在熄屏时间一直连接，qpnp_fg_memaccess qpnp_fg_update_temp qpnp_fg_update_sram是内核的操作。和rom有关。&lt;img src=&quot;http://ww3.sinaimg.cn/large/68eb7c93gw1ezrvef5tykj20u01hctff.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt;最后发现。。其实是rom的锅。我的other居然没有出现deep sleep。这是相当可怕的事情。经过调优和整理唤醒后，得到如下相当爽快的数据。接近70%的深睡眠还可以让人接受。毕竟还开启了微信。微博。邮件的消息推送。&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/006fVPCvjw1ezvcpamb0bj30u01hcgrd.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/006fVPCvjw1ezvconkjs5j30u01hctfb.jpg&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/006fVPCvjw1ezvcqv63zoj30u01hcah1.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt;②&lt;font color=&quot;#ff0000&quot;&gt;&lt;strong&gt;wakelock detector WLD&lt;/strong&gt;&lt;/font&gt;查看流氓唤醒大户 这里要提到微信。千万不要手欠在应用内使用它的升级。最好在play或者cool市场升级。官方提供的流氓唤醒一个晚上唤醒好几千次。从未进入过休眠状态。一进入唤醒状态又有很多应用跟着启动。 微信的消息是利用同步，而CPU唤醒锁则是被滥用了的。&lt;br&gt;&lt;br&gt;Test1 2016.01.06&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/68eb7c93gw1ezp096st0oj20u01hcwlt.jpg&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/68eb7c93gw1ezp0akfqdzj20u01hcgrl.jpg&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/68eb7c93gw1ezp09t72gcj20u01hcwja.jpg&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/68eb7c93gw1ezp0a61g8yj20u01hcgt8.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt;上图分别是WLD四个视图-CPU唤醒锁时间、Kernel唤醒锁时间、屏幕唤醒锁触发次数、Alarm触发器次数.&lt;br&gt;&lt;br&gt;CPU锁实际上就是用户app的持有wakelock的时间。可以看到由于需要同步相册里的图片，本次测试中google photo占用了极大部分的唤醒锁时间，其余的应用则比较正常；内核持有wakelock一般与rom的品质有关，由于po主使用的是第三方精简rom，出现了一些奇特的bug，例如第一项qcom_rx_wakelock高通的cpu在5.1的bug，在熄屏状态下仍在进行不停的wifi连接，持有唤醒锁对应用进行超负荷的运算，这也是比较不容易控制也难以改善的方面；屏幕唤醒则和用户使用的点亮次数有关，可以看到，每次启动SU超级root、微信、QQ、BBS都进行了短暂的唤醒，而视频软件如果在播放中熄屏，亮屏后也会唤醒屏幕锁（持久保有）；最后一项则是需要重点关注的，定时器启动唤醒锁，2个多小时内，google服务、微信、微博、日历、输入法都进行了大量的唤醒，导致80%的时间都难以进入deep sleep。&lt;br&gt;&lt;br&gt;Test2 2016.01.08&lt;br&gt;&lt;br&gt;CPU唤醒锁：本次测试google相册已经不进行同步，更多的是Gmail的同步操作。由于输入了7个邮件，不可避免的会进行更多频次的操作。除了gmail能利用谷歌框架同步外，其他邮件都应该设置比较合理的同步时间。而微信（后文提及）设置了封锁CPU锁后同步的频次也有所减少。&lt;br&gt;&lt;br&gt;kernel wakelock：qcom_rx_wakelock已经减少了很多，这是关闭黑屏手势的减少唤醒次数的效果。两次测试中，PowerManagerService.WakeLocks、qcom_rx_wakelock、PowerManagerService.Broadcasts、NETLINK四个核心服务占据的时间远远超过其他的服务。这也是需要优化的部分。&lt;br&gt;&lt;br&gt;屏幕唤醒锁触发：&lt;br&gt;&lt;br&gt;Alarm计时器触发：可以看到QQ、微信在夜晚的唤醒次数有些多，其实在qq、微信中都可以设置免打扰时间段，主动的消除在夜间待机时的计时器唤醒推送。&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/68eb7c93gw1ezrvmr0wr2j20u01hcqaa.jpg&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/68eb7c93gw1ezrvnilpewj20u01hc7ai.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/68eb7c93gw1ezrvjeovxej20u01hcahy.jpg&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/68eb7c93gw1ezrvlj75wdj20u01hcn5a.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt;&amp;nbsp;&lt;br&gt;&lt;br&gt;4.绿色守护、3C ToolBox、Amplify的使用。&lt;br&gt;&lt;br&gt;①.&lt;font color=&quot;#ff0000&quot;&gt;&lt;em&gt;*绿色守护&lt;/em&gt;&lt;/font&gt;&lt;/li&gt;&lt;/em&gt;

&lt;font color=&quot;#ff0000&quot;&gt;思路&lt;/font&gt;：熄屏清掉所有被勾选的app的服务和缓存进程，同时阻止所有可唤醒包含服务的监听receiver&amp;amp;释放所有包含服务的相互唤醒wakelock，达到相对休眠状态。主要运作在熄屏后不希望后台运作的程序（&lt;font color=&quot;#ff0000&quot;&gt;无法在前台操作切断应用间唤醒&lt;/font&gt;）。捐助版的亮点是可以在休眠状态下使用GCM服务。&lt;br&gt;&lt;br&gt;绿色守护在xda的讨论贴 开发者oisisfeng也在。&lt;br&gt;&lt;br&gt;&lt;a href=&quot;http://forum.xda-developers.com/showthread.php?t=2155737&quot; title=&quot;http://forum.xda-developers.com/showthread.php?t=2155737&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://forum.xda-developers.com/showthread.php?t=2155737&lt;/a&gt;&lt;br&gt;&lt;br&gt;绿守作者在知乎的问答&lt;br&gt;&lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/question/38311793/answer/75897889&quot; title=&quot;https://www.zhihu.com/question/38311793/answer/75897889&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.zhihu.com/question/38311793/answer/75897889&lt;/a&gt;&lt;br&gt;&lt;br&gt;由于测试机在5.1.1,还未升级到Android M，因此没有享受到doze mode和app standby带来的福利。&lt;br&gt;&lt;br&gt;一张图看到就算不是 百度阿里疼腾讯系 从某个市场出来的app也会相互唤醒。这锅到底谁来背。以后反编译源码看一看。即刻-豆瓣-虎皮体育-同花顺-航旅纵横-什么值得买是什么关系。更不用说百度及包含百度字样的app-爱奇艺-去哪儿-uber-乐视-91-多米-音悦台-穷游途牛-汽车之家&amp;nbsp; 腾讯及包含qq字样-京东-大众-美团-饿了么-58-猎豹-搜狗-同城 阿里及UC-微博-优酷土豆-陌陌-滴滴快的-小米魅族&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/68eb7c93gw1ezs6frg1q4j20u01hc461.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt;使用方法：主界面显示正在运行的服务及已经绿色化的应用。点击上方【+】号对所有潜在威胁进行评估，勾选的应用会在熄屏数分钟后清空缓存、杀死服务、抑制app唤醒及alarm的唤醒。root及xposed模式下效果更佳。支持gcm的应用会有小图标，能在绿色化的情况下还可收发消息。&lt;br&gt;&lt;br&gt;②.&lt;font color=&quot;#ff0000&quot;&gt;&lt;strong&gt;3C tool box&lt;/strong&gt;&lt;/font&gt;

&lt;font color=&quot;#ff0000&quot;&gt;思路&lt;/font&gt;：封杀选定的activity receiver service。结晶化应用（无论前台后台，需要更多的测试，容易出现应用fc 可以实现前台界面退出后直接清缓存 &lt;font color=&quot;#ff0000&quot;&gt;可直接在应用使用中禁止广告、介绍、推荐app的activity和service&lt;/font&gt;）（本篇不涉及3c的调频调压 内存管理设置）&lt;br&gt;&lt;br&gt;例如：杀错了谷歌的邮件提醒，即便能实时接收邮件，但系统不做出提醒通知。&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/68eb7c93gw1ezrulsjoalj20u01hcgt5.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt;又例如：杀错了QQi的消息消息提示核心，虽然在后台能看到QQ的进程，但新消息通知会出现不同步（极有可能是阻止了开机自启杀掉的，但这个receiver需要的权限相当多，网络改变、时间改变等乱七八糟的）&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/68eb7c93gw1ezrusb4h51j20u01hctf7.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt;再比如杀掉了随手记的通知权限，居然能把自己的同步服务给搞挂了。。这代码写的。此外几个应用，饿了么，大众点评，都有不同程度的易fc但后台又唤醒个不停的问题。&lt;br&gt;&lt;br&gt;使用方法：对四大组件中那三个进行轮番排查，限制自启动，限制唤醒路径，冻结后台。（主要操作在应用管理里）&lt;br&gt;&lt;br&gt;③&lt;strong&gt;&lt;font color=&quot;#ff0000&quot;&gt;唤醒控制Amplify&lt;/font&gt;&lt;/strong&gt;的使用&lt;br&gt;&lt;br&gt;思路：对Alarm计时器的时间进行限制重设、对Service进行屏蔽、限制同步，可使用进阶的正则表达式过滤。&lt;br&gt;&lt;br&gt;使用方法：对在wld找到的唤醒次数多的详细分析，对alarm中唤醒频次高的限制更长的时间，对显见的服务停用，先做完这两者再对wakelock进行限制。&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/10/569322dfc0422.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt;④&lt;strong&gt;&lt;font color=&quot;#ff0000&quot;&gt;禁止唤醒&lt;/font&gt;&lt;/strong&gt;的使用(非捐助版只能对5个app进行限制，入正也就十几块)&lt;br&gt;&lt;br&gt;思路：在前台就主动把各类唤醒锁进行封闭、定时器对齐、对同步进行限制&lt;br&gt;&lt;br&gt;作者曾提到了&lt;font color=&quot;#ff0000&quot;&gt;唤醒锁的危害&lt;/font&gt;&lt;font color=&quot;#000000&quot;&gt;及禁止唤醒对这些危害的防范&lt;/font&gt;

&lt;p&gt;&lt;strong&gt;CPU唤醒锁&lt;/strong&gt;: 这是在息屏后阻止你的设备进入休眠状态的唤醒锁, 禁用它通常不会有任何问题.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所有其它唤醒锁&lt;/strong&gt;: 除了CPU唤醒锁之外, 还有一些唤醒锁可以阻止设备休眠, 甚至阻止设备息屏. 开启这个选项以禁用这些唤醒锁.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步&lt;/strong&gt;: 同步也可以唤醒设备, 如果你不需要应用的同步功能, 使用这个选项来禁用掉它.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对齐定时器:&lt;/strong&gt; (&amp;gt;= Android 4.4) AlarmManager可以使用定时器来周期性的唤醒设备, 阻止CPU进入长期休眠状态. 启用这个选项来强制对齐定时器, 让它们尽量在同一时间触发以节省电量. 请注意: 对于设计不良的应用, 启用此选项有可能会引发推送消息延迟.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linangran.com/?p=611&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.linangran.com/?p=611&lt;/a&gt; 作者使用指南&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/10/569323251d9ce.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;⑤阻止运行的使用&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/liudongmiao/ForceStopGB&quot; title=&quot;https://github.com/liudongmiao/ForceStopGB&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/liudongmiao/ForceStopGB&lt;/a&gt; 开源项目地址 免费&lt;/p&gt;
&lt;p&gt;相当推荐的一款软件，无论前后台，通过劫持系统api，直接禁止非需求service的启动。精简版的3c tool box，保证应用只在需要时启动。添加到阻止列表的应用只在以下情况开启：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启动器直接或第三方provider，如手动点button、分享、支付  &lt;/li&gt;&lt;li&gt;桌面小部件定时更新、但只维持30秒（这个好顶赞）  &lt;/li&gt;&lt;li&gt;同步开启时的定时同步，也只能维持30秒  &lt;/li&gt;&lt;li&gt;除谷歌服务外的系统服务、支付宝的支付服务  &lt;/li&gt;&lt;li&gt;其他可能的用户行为引起的启动&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同时，谷歌服务在阻止列表时，可以支持gcm和谷歌家族应用的使用。但当任何一个谷歌家族应用没有退出时，都不会退出谷歌服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/10/569322a0e590e.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;5.针对微信的方案&lt;/p&gt;
&lt;p&gt;微信最近从良而加入gcm的推送方案，能在有谷歌框架的手机在hibernate休眠状况下直接推送消息！既不用随时拿着唤醒锁又不唤醒其他乱七八糟的应用！但原先保留的wakelock模式依旧存在，握着各种随机数的锁禁都不知道禁哪些。但大神出现了。 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/31136645&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.zhihu.com/question/31136645&lt;/a&gt; 知乎高票的正则表达式杀wakerlock方案&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://bbs.gfan.com/android-7963258-1-1.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://bbs.gfan.com/android-7963258-1-1.html&lt;/a&gt; gfan精华帖&lt;/p&gt;
&lt;p&gt;上面是一种方案，但微信更改了wakelock的命名方式就会得不偿失错杀唤醒锁了。最近发现单独使用【 禁止唤醒】中的CPU唤醒锁，也能阻止微信胡乱的唤醒，同时不影响推送；但相同的情况下使用绿色守护对微信绿色化却不能及时收到消息。&lt;/p&gt;
&lt;p&gt;6.针对gms的方案 考虑到gms 的复杂性 提一下它涉及到google账户的同步&lt;em&gt;sync&lt;/em&gt; 备份 keep photo gmail(分为对被墙的不被墙的) 三个文档&amp;nbsp; play软件升级等等 google service包含了N个心跳包的alarm 各种硬件CPU唤醒锁&lt;/p&gt;
&lt;p&gt;①完全禁掉是一个办法（当然这需要框架 service play一起禁 不然各种报错）这种方式最省电 但是又想使用google收国内账户 或者时不时FQ看看FB TW IG使用其中一些&lt;/p&gt;
&lt;p&gt;②不停更换host文件。这个方式能保证随时上墙又不会因为vpn挂着长期费电。测试几天发现耗电稳定，gmail是不是抽风但效果拔群。（推荐神站load.cn）&lt;/p&gt;
&lt;p&gt;③长时间挂载稳定vpn。该方式同样能随时保证上墙接收同步和推送。同时配合now能享受到肉身翻墙的欢喜效果。但vpn的开发良莠不齐，耗电状况不一。&lt;/p&gt;
&lt;p&gt;④不需要google家族的直接装无gms版的精简rom或国内大部分融都会删掉——————这个方法纯天然摒除了谷歌的抽风状况，但，滚粗。&lt;/p&gt;
&lt;p&gt;⑤久不久上墙。gms耗电的问题就是连接不上google而大量地进行重连接。所以希望使用google服务又不想随时耗电使用vpn的一个便捷方案就是每天保证登录一次，并在amplify对google框架进行限制时间，每隔一天敲醒alarm一次，但不能阻止cpu唤醒锁对gms想要获取推送的影响。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;【2013.04.14】绿守作者 微信收费事件背后被广泛忽略的技术细节&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.oasisfeng.com/2013/04/14/dirty-secret-behind-weixin-charge-gate/&quot; title=&quot;http://blog.oasisfeng.com/2013/04/14/dirty-secret-behind-weixin-charge-gate/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.oasisfeng.com/2013/04/14/dirty-secret-behind-weixin-charge-gate/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【2013.06.19】PC Online 的省电优化方案介绍&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://pcedu.pconline.com.cn/334/3345895_all.html&quot; title=&quot;http://pcedu.pconline.com.cn/334/3345895_all.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://pcedu.pconline.com.cn/334/3345895_all.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【2014.02.16】唤醒锁: 检测 Android* 应用中的 No-Sleep（无法进入睡眠）问题&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://software.intel.com/zh-cn/android/articles/wakelocks-detect-no-sleep-issues-in-android-applications?language=es&quot; title=&quot;https://software.intel.com/zh-cn/android/articles/wakelocks-detect-no-sleep-issues-in-android-applications?language=es&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://software.intel.com/zh-cn/android/articles/wakelocks-detect-no-sleep-issues-in-android-applications?language=es&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【2014.06.05】wakelock alarm wifi 详细数据测评 唤醒锁: 检测 Android* 应用中的 No-Sleep（无法进入睡眠）问题&lt;a href=&quot;http://www.oneplusbbs.com/forum.php?mod=viewthread&amp;amp;tid=366390&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.oneplusbbs.com/forum.php?mod=viewthread&amp;amp;tid=366390&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【2014.07.22】Android Standby 对于绿色守护唤醒对其 进入深睡眠的一些思考&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://lockekk.github.io/jekyll-bootstrap/2014/07/22/Android-Standby/&quot; title=&quot;http://lockekk.github.io/jekyll-bootstrap/2014/07/22/Android-Standby/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://lockekk.github.io/jekyll-bootstrap/2014/07/22/Android-Standby/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;android论坛关于ba保持屏幕唤醒和cpu唤醒&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://developer.android.com/training/scheduling/wakelock.html&quot; title=&quot;http://developer.android.com/training/scheduling/wakelock.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://developer.android.com/training/scheduling/wakelock.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此外 几个app的酷市场下评论都很精彩。&lt;/p&gt;
&lt;p&gt;例如Amplify的评论 &lt;a href=&quot;http://coolapk.com/feed/1201169&quot; title=&quot;http://coolapk.com/feed/1201169&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://coolapk.com/feed/1201169&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;例如Google Play Service 的评论 &lt;a href=&quot;http://coolapk.com/feed/1196656&quot; title=&quot;http://coolapk.com/feed/1196656&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://coolapk.com/feed/1196656&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;font size=&quot;4&quot; face=&quot;华文中宋&quot;&gt;本文只讨论安卓手机软节电，不负责推荐底包、rom、调频调压方案，刷机root&lt;font color=&quot;#ff0000&quot;&gt;后果自负&lt;/font&gt;。&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;font size=&quot;4&quot; face=&quot;华文中宋&quot;&gt;本小节只讨论干货。在root及xposed框架下。同时兼顾不能肉身翻墙又想用google服务的小狗们。本人的使用情况是正常功能照开，google需要gmail和google photo及部分gcm，黑屏开启手势和解锁，正常收微信、闹钟、短信电话外熄屏一切不开，后台常开应用有snap锁屏、grenntify绿色守护、调音的audio mix、天气插件、BBS、输入法、Nova Launcher。测试的环境为Android L 5.1.1&lt;/font&gt;

&lt;font size=&quot;4&quot; face=&quot;华文中宋&quot;&gt;&amp;nbsp;&lt;br&gt;
    
    </summary>
    
      <category term="App强推" scheme="http://ovjaywang.github.io/categories/App%E5%BC%BA%E6%8E%A8/"/>
    
      <category term="软文" scheme="http://ovjaywang.github.io/categories/App%E5%BC%BA%E6%8E%A8/%E8%BD%AF%E6%96%87/"/>
    
    
      <category term="Android" scheme="http://ovjaywang.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android为毛耗电[1]</title>
    <link href="http://ovjaywang.github.io/2015/12/28/Android%E4%B8%BA%E6%AF%9B%E8%80%97%E7%94%B5%5B1%5D/"/>
    <id>http://ovjaywang.github.io/2015/12/28/Android为毛耗电[1]/</id>
    <published>2015-12-28T15:34:25.000Z</published>
    <updated>2016-04-29T09:13:23.588Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;#000000&quot;&gt;&lt;/font&gt;**&lt;/strong&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;本文只讨论安卓手机软节电，不负责推荐底包、rom、调频调压方案，&lt;font color=&quot;#ff0000&quot;&gt;刷机root后果自负。&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;**&lt;/p&gt;
&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;&lt;strong&gt;纯硬货，只想节电看后文。&lt;/strong&gt;&lt;/font&gt;

&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;使用安德猴主要还是谷歌的情怀。最近无可救药的恋上了无线高质量同步的Google相册和Keep。此外Google Contact和Gmail也时不时要收一下。&lt;/font&gt;

&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;问题是。。墙内不能随时翻。国内流氓自启和相互唤醒严重影响待机时间。如何破？首先搞清楚什么在耗电。再来解决怎么防流氓的同时不影响收发消息体验。&lt;/font&gt;

&lt;font color=&quot;#333333&quot;&gt;&lt;font size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;&lt;font color=&quot;#000000&quot;&gt;这里提到的几个概念是安猪手机由于真后台，而造成的各种能耗电耗流量元凶——四大组件&lt;/font&gt;&lt;strong&gt;&lt;font color=&quot;#ff0000&quot;&gt;Activity、Service、BroadCastReceiver、ContentProvider&lt;/font&gt;。&lt;/strong&gt;&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;#333333&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;耗电–一定是这四个中的一个在以某种方式运行&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;font color=&quot;#000000&quot; size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;&lt;font color=&quot;#ff0000&quot;&gt;&lt;strong&gt;Activity&lt;/strong&gt;&lt;/font&gt;简言之就是前台窗体可视界面它上面可以显示一些控件也可以监听并处理用户的事件做出响应。你跳转到一个程序的界面、里面可能嵌套了很多个Activity。也有的一个Activity自成一个界面，例如第一次启动的引导界面。当然，程序猿代码风格迥异，一个&lt;font size=&quot;4&quot;&gt;Activity有的直接盖在一个上面，这样按下返回键销毁当前的能直接返回上一个；有的流程和任务则直接生成新Activity把当前的干掉。一些广告，一些无聊的需求，如淘宝摇一摇、美图下游戏，你完全不想要，则可以通过阻止Activity启动的方式，干掉。这样的做法可以降低内存消耗。但如果代码流程，若写入了不开启这个Activity就没法运行，很可能造成FC。因此测试Activity阻止就需要很谨慎。网路也有很多大神提供了Activity的阻止列表。但App更新极快，同时包名和Activity的命名方式更加让人难以捉摸，就相当难以防范。&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;

&lt;font color=&quot;#000000&quot;&gt;&lt;font size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;&lt;font color=&quot;#ff0000&quot;&gt;&lt;strong&gt;Activity&lt;/strong&gt;&lt;/font&gt;之间通过&lt;font color=&quot;#ff0000&quot;&gt;Intent&lt;/font&gt;进行通信，它描述的事某一个事件（单机、浏览、编辑）。也就是说这个Activity的一些参数在Activity跳转时，通过把参数塞入Intent这样一个对象，在另一个Activity读取。在Intent的描述结构中，有两个最重要的部分：动作和动作对应的数据。而IntentFilter则对应一个Activity能做哪些Intent。IntentFilter通常写入Android的AndroidManifest文件中定义好。&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;

&lt;font color=&quot;#000000&quot;&gt;&lt;font size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;&lt;font color=&quot;#ff0000&quot;&gt;&lt;strong&gt;BroadCastReceiver&lt;/strong&gt;&lt;/font&gt;（广播接收器）它是监听响应各种手机变化并作出响应反应的组件。例如打进电话某个App调出号码查询，例如WiFi网络改变某App可以进行同步。这些监听并不经常是我们需要的，同时如果App写的极差，接收的广播级多，也会造成资源的浪费也相当耗电。它并不会产生一个界面，但是它能唤起一个Activity或者Service对事件进行相应。最常见的就是电话来了闪灯响铃，最讨厌的就是有Wifi了发个通知广告。甚至，当一个App装过还启动过，由于设置了开机启动的响应或网络状况的变化响应，都会产生通知。然而与Activity一样，阻止某一种广播接收同样会可能造成应用使用不正常，但FC情况相当少，测试的时候需要相当小心，但这里的组件命名方式都较为规范，因此测试起来也会比较顺利。&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;

&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;监听广播同样可以视为一个事件，使用Intent对其参数进行传递。这些事件，就是通常意义上的权限，可以查看联系人、可以监听电话等。许多监控App都能查看并修改应用程序能够监听的内容。注册广播接收器可以写入一个App的AndroidManifest.xml中进行静态注册，若完成时间比较长必须通过线程，放进Service后台中运行，否则容易造成程序卡顿；也可以程序动态注册，当Activity关闭后，监听广播也关闭，这样的做法比较省电，但是关闭程序就无法接受一些通知和广告。（需要完全退出或者多任务杀掉）因此大多数App都采用静态注册，App不启动，也能通过订阅的广播触发，例如开机启动触发、时间变化触发等。&lt;/font&gt;

&lt;font color=&quot;#000000&quot;&gt;&lt;font size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;&lt;font color=&quot;#ff0000&quot;&gt;&lt;strong&gt;Service&lt;/strong&gt;&lt;/font&gt;（服务）也是无界面的组件，它通过后台长时间的运行来进行运行一些监测程序，例如后台听歌单曲循环等，后台轮询查询最新消息的微博。配合BroadCastReceiver使用效果极佳耗电也极棒。一个App很可能有相当多的Service在后台挂着，同时一个流氓集团的Service也会相互唤醒保证一个被杀掉的时候又自启动。但乱杀也会造成严重的后果，一些闹钟，一些天气，一些消息软件误杀后没有了后台Service做消息推送，就会错过重要的事情。&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;

&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;一个Service不能自己运行。首次启动需要create再start，第二次之后就只用start需要别的启动或触发。但Service一旦启动，就与调用者无关了。需要停止service需要调用stop方法同时销毁destroy。可以使用bindservice让service随着调用者关闭而终止。&lt;/font&gt;

&lt;font color=&quot;#000000&quot;&gt;&lt;font size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;&lt;font color=&quot;#ff0000&quot;&gt;&lt;strong&gt;ContentProvider&lt;/strong&gt;&lt;/font&gt;(内容提供者)一个应用程序的指定数据集提供给其他应用程序。这些数据可以存储在文件系统中、在一个SQLite数据库、或以任何其他合理的方式。其他应用可以通过ContentResolver类(见ContentProviderAccessApp例子)从该内容提供者中获取或存入数据.(相当于在应用外包了一层壳),最常见的就是支付婊在别的应用中的调用，它提供了一个统一的支付接口，写在一个内部路径URL里。&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;

&lt;font color=&quot;#ff0000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;四大组件启动，&lt;/font&gt;

&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;除了ContentProvider是通过别的应用程序调用ContentResolver 发出内容请求后激活外，其他三个都是通过Intent异步消息激活。&lt;br&gt;Activity的激活通过传递一个Intent 对象至&lt;font color=&quot;#ff0000&quot;&gt;Context.startActivity()或Activity.startActivityForResult()&lt;/font&gt;以载入（或指定新工作给）一个activity。 前面的函数直接启动的Activity，可以查看Intent中传入的参数。若期待新启动的Activity返回一个值（例如填写个人信息提交返回是否成功）就调用后面那个函数，并调用onActivityResult() 查询返回结果.&lt;br&gt;Service的激活可以通过传递一个Intent 对象至&lt;font color=&quot;#ff0000&quot;&gt;Context.startService()或Context.bindService()&lt;/font&gt;前者Android 调用服务的onStart()方法并将Intent 对象传递给它，后者Android 调用服务的onBind()方法将这个Intent 对象传递给它&lt;br&gt;发送广播可以通过传递一个Intent 对象至给&lt;font color=&quot;#ff0000&quot;&gt;Context.sendBroadcast() 、Context.sendOrderedBroadcast()或Context.sendStickyBroadcast()。&lt;/font&gt;Android 会调用所有对此广播有兴趣的广播接收器的onReceive()方法，将intent 传递给它们&lt;/font&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#ff0000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;四大组件销毁时，&lt;/font&gt;

&lt;font color=&quot;#000000&quot;&gt;&lt;font size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;&lt;font color=&quot;#ff0000&quot;&gt;&lt;strong&gt;ContentProvider&lt;/strong&gt;&lt;/font&gt;通过别的应用程序调用，消息处理完毕即销毁（如调用图片viewer看图，调用支付接口付款）。&lt;font color=&quot;#ff0000&quot;&gt;&lt;strong&gt;BroadCastReceiver&lt;/strong&gt;&lt;/font&gt;则注册在系统中监听，这两者都无需主动人为关闭，可以直接在权限中限制。其中BroadCastReceiver的生命周期只有十秒，否则就会报ANR(Application No Response)程序无响应的消息。&lt;br&gt;&lt;strong&gt;&lt;font color=&quot;#ff0000&quot;&gt;Activity&lt;/font&gt;&lt;/strong&gt;则通过finish()函数退出。一般情况下，按下返回退出键，或在多任务窗口杀掉都能直接关闭显式的Activity。有时直接按下Home键则会在后台缓存（Process），当切换过多个应用后，切回来时还能完整的保留原先打开时候的数据和窗口。当然，这样的过程会占用内存空间（RAM），同时也消耗一定的电量（比较少）。当后台运行过多缓存时，部分低内存手机会出现明显的卡顿。Android5.0之后的系统做的不错，能够按照优先级杀掉缓存应用。&lt;br&gt;&lt;strong&gt;&lt;font color=&quot;#ff0000&quot;&gt;Service&lt;/font&gt;&lt;/strong&gt;是个比较头疼的东西。尽管App可以调用&lt;font color=&quot;#ff0000&quot;&gt;Context.stopService()&lt;/font&gt;方法关闭服务，或使用&lt;font color=&quot;#ff0000&quot;&gt;bindService()&lt;/font&gt;绑定调用的组件关闭，但，流氓才不会这么做。&lt;br&gt;通常，手机应用中都看到正在运行的x个进程和y个服务。进程由多个线程组成，其中，主线程主要负责全局的参数传递，一些核心启动器及主界面的显示。而一些时间较长的函数，如获取多个图片，获取大量的数据，可以写在一个子线程，对主界面交互可以进行异步刷新，否则会造成主界面的卡顿。而当程序退居后台后，子线程依然处理数据，但没有了Activity进行联系，因此可以通过Service进行管理。由于Service并不负责应用层面的复杂操作，只对数据进行处理传递，同时可以写进单独的进程中，因而更为便利。&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;

&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;这里总结一下Service能被启动&amp;amp;被守护的各种方式。&lt;/font&gt;

&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;1.打开应用后，直接显而易见的调用它想要完成的Service，此时按照一般的逻辑，理应是退出App关闭Activity后就会stopservice.&lt;/font&gt;

&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;2.注册一个广播，可以按时钟、按网络变化、屏幕变化等，每次触发这些广播，就会检查一次Service的状况。遇到杀掉就重启。此时应当关注app的权限及其注册的广播。&lt;/font&gt;

&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;3.重写Service里的函数，在被杀时自动重启；配置到单独的进程中；配置安卓persistent=true；设置前台foreground=true.这些情况，在root情况下很容易被进程管理的杀掉&lt;/font&gt;

&lt;font size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;&lt;font color=&quot;#000000&quot;&gt;4.双Service或多Service守护，在AndroidManifest.xml里面定义Service时加入android:process=”:service1”&lt;/font&gt;&lt;br&gt;&lt;/font&gt;&lt;/font&gt;

&lt;pre class=&quot;brush: xml; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;&amp;lt;service android:enabled=&quot;true&quot; 
android:name=&quot;com.service.demo.Service1&quot; 
android:process=&quot;:service1&quot;&amp;gt;
&amp;lt;service&amp;gt;
&amp;lt;service android:enabled=&quot;true&quot; 
android:name=&quot;com.service.demo.Service2&quot; 
android:process=&quot;:service2&quot;&amp;gt;
&amp;lt;service&amp;gt;  
&lt;/pre&gt;

&lt;p&gt;&amp;lt;&lt;/p&gt;
&lt;p&gt;p align=”left”&amp;gt;&lt;span&gt;&lt;span&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;关键的Point是触发了service的onTrimMemory()函数。又分别重新启动。&lt;/font&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;font size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;&lt;font color=&quot;#000000&quot;&gt;&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;&lt;/span&gt;&lt;/span&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;font size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;&lt;font color=&quot;#000000&quot;&gt;5.Wakelock。Android机制下有一个唤醒锁，可以唤醒休眠中的手机。&lt;/font&gt;&lt;font color=&quot;#000000&quot;&gt;WakeLock阻止应用处理器（Application &lt;wbr&gt;Processor）挂起&lt;/font&gt;&lt;font color=&quot;#000000&quot;&gt;，确保关键代码的运行，通过中断唤起应用处理器（Application &lt;wbr&gt;Processor），可以阻止屏幕变暗。一旦有有效的wakelock，系统就不能进入深度睡眠（Deep Sleep）。一般在熄屏传输文件、下歌中使用。被滥用后，后果不堪设想。&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;AlarmManage有一个AlarmManagerService,该服务程序主要维护app注册下来的各类Alarm,并且一直监听 Alarm设备，一旦有Alarm触发，或者是Alarm事件发生，AlarmManagerService就会遍历Alarm列表，找到相应的注册 Alarm并发出广播。Alarm &lt;wbr&gt;Manager会维持一个cpu的wake &lt;wbr&gt;lock。这样能保证电话休眠时，也能处理alarm的广播。一旦alarm &lt;wbr&gt;receiver的onReceive() &lt;wbr&gt;方法执行完，wake &lt;wbr&gt;lock会迅速被释放。如果在receiver中开启一个service，有可能service还没启动，wake &lt;wbr&gt;lock已经被释放了。所以此时要实现单独的wake &lt;wbr&gt;lock策略。&lt;/font&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;这也是一般不root不能根治的唤醒service的手段。App通过反复注册系统应用，调用级别高的Wakelock使得手机很难进入低频率的待机状态。&lt;/font&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;6.注册成为系统app同时包名混乱的编写。隐藏需要调用的service。一般没root的做不到。&lt;/font&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;所以，杀进程很容易，杀会自启的service也不难，难的是杀各种唤醒。&lt;/font&gt;&lt;/span&gt;&lt;/p&gt;
&lt;font size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;&lt;/font&gt;

&lt;font size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;div align=&quot;left&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;em&gt; &lt;/em&gt; &lt;em&gt;&lt;br&gt;&lt;br&gt;&lt;/em&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;/font&gt;&lt;br&gt;&lt;span&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;这里提到两个重要概念：&lt;/font&gt;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span&gt;&lt;font color=&quot;#000000&quot;&gt;&lt;font size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;&lt;font color=&quot;#ff0000&quot;&gt;&lt;strong&gt;Wakelock&lt;/strong&gt;&lt;/font&gt;。唤醒锁；&lt;font color=&quot;#ff0000&quot;&gt;&lt;strong&gt;Alarm&lt;/strong&gt;&lt;/font&gt;。定时器&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span&gt;&lt;font size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;&lt;font color=&quot;#000000&quot;&gt;&lt;em&gt;*Wakelock&lt;/em&gt;&lt;/font&gt;&lt;font color=&quot;#000000&quot;&gt;定义了一个接口，能让App有权限，在停止交互、黑屏状况下&lt;/font&gt;&lt;font color=&quot;#ff0000&quot;&gt;阻止手机休眠&lt;/font&gt;&lt;font color=&quot;#000000&quot;&gt;，运行关键而必要的一些代码，通常是账户同步、消息推送。&lt;span&gt;Android手机有两个处理器，一个叫Application Processor（AP），一个叫Baseband Processor（BP）。AP是ARM架构的处理器，用于运行Linux+Android系统；BP用于运行实时操作系统（RTOS），通讯协议栈运行于BP的RTOS之上。非通话时间，BP的能耗基本上在5mA左右，而AP只要处于非休眠状态，能耗至少在50mA以上，执行图形运算时会更高 。此外耗电大户wifi在100mA左右，LCD灯也在100mA左右。而进入休眠的手机大部分代码会停止运行。但，并不是很容易进入深度休眠的状态。&lt;/span&gt;&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;&lt;span&gt;wakelock针对的是&lt;font color=&quot;#ff0000&quot;&gt;某个Activity，而不是整个app&lt;/font&gt;。因此，获取和释放wakelock在单个Activity中进行。&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;&lt;span&gt;对于唤醒锁，官方文档中的解释是：&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;a href=&quot;http://developer.android.com/reference/android/os/PowerManager.html#goToSleep(long&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;华文中宋&quot;&gt;PowerManager&lt;/font&gt;&lt;/a&gt;)&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;华文中宋&quot;&gt;:This class gives you control of the power state of the device.&lt;/font&gt;

&lt;p&gt;&lt;a href=&quot;http://developer.android.com/reference/android/os/PowerManager.WakeLock.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;华文中宋&quot;&gt;PowerManager.WakeLock&lt;/font&gt;&lt;/a&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;华文中宋&quot;&gt;: lets you say that you need to have the device on.&lt;/font&gt;&lt;/p&gt;
&lt;font color=&quot;#ff0000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;只要系统中存在任一有效的wake_lock，系统就不能进入深度休眠，但可以进行设备的浅度休眠操作。&lt;/font&gt;

&lt;font size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;&lt;font color=&quot;#000000&quot;&gt;Android定义了几种低功耗状态，&lt;/font&gt;：&lt;strong&gt;&lt;font color=&quot;#ff0000&quot;&gt;earlysuspend、suspend、hibernation.&lt;/font&gt;&lt;/strong&gt;&lt;/font&gt;&lt;/font&gt;

&lt;font size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;1) &lt;font color=&quot;#ff0000&quot;&gt;&lt;strong&gt;earlysuspend&lt;/strong&gt;&lt;/font&gt;&lt;font color=&quot;#000000&quot;&gt;（浅度休眠），&lt;/font&gt;&lt;font color=&quot;#000000&quot;&gt;也有称standby&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;&lt;font size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;&lt;font color=&quot;#000000&quot;&gt;: 是一种低功耗的状态,某些设备可以选择进入某种功耗较低的状态,比如 LCD可以降低亮度或灭掉;它不会受到wakelock阻止。例如接收黑屏手势。&lt;br&gt;&lt;/font&gt;2) &lt;font color=&quot;#ff0000&quot;&gt;&lt;strong&gt;suspend&lt;/strong&gt;&lt;/font&gt;&lt;font color=&quot;#000000&quot;&gt;（休眠），也有称sleep（bad nomenclature）: 是指除电源管理以外的其他外围模块以及cpu均不工作,只有内存保持自刷新的状态; 一般休眠到RAM&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;

&lt;font size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;3) &lt;font color=&quot;#ff0000&quot;&gt;&lt;strong&gt;hibernation&lt;/strong&gt;&lt;/font&gt;&lt;font color=&quot;#000000&quot;&gt;（冬眠）是指所有内存镜像都被写入磁盘（disk）中,然后系统关机,恢复后系统将能恢复到“关机”之前的状态。是最彻底的低功耗模式，它把所有内存镜像都写入磁盘中，然后系统关机，是Linux内核系统级的休眠。&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;

&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;&lt;br&gt;&lt;br&gt;PowerManager.WakeLock有加锁与解锁两种状态，而加锁的形式有两种:&lt;br&gt;&lt;br&gt;①永久锁住，这种锁除非显式的放开，否则是不会解锁的，所以用起来需要非常小心！&lt;br&gt;&lt;br&gt;②超时锁，到时间后就会解锁，而创建WakeLock后，有两种加锁机制: ①不计数锁机制，②计数锁机制(默认)可通过setReferenceCounted(boolean value)来指定,区别在于: 前者无论acquire( )多少次，一次release( )就可以解开锁。 而后者则需要(–count == 0)的时候，同样当(count == 0)才会去申请锁 所以，WakeLock的计数机制并不是正真意义上对每次请求进行申请/释放一个锁; 只是对同一把锁被申请/释放的次数来进行统计，然后再去操作！&lt;/font&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;&lt;font color=&quot;#000000&quot;&gt;&lt;font size=&quot;4&quot;&gt;该操作可通过setReferenceCounted(boolean value)设置。&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;

&lt;font color=&quot;#000000&quot; face=&quot;微软雅黑 Light&quot;&gt;当然，需要用到权限&lt;pre&gt;&amp;lt;uses-permission android:name=”android.permission.WAKE_LOCK”/&amp;gt;&lt;/pre&gt;&lt;pre&gt;&amp;lt;uses-permission android:name=”android.permission.DEVICE_POWER”/&amp;gt;&lt;/pre&gt;&lt;/font&gt;

&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;锁有两种类型：&lt;/font&gt;

&lt;font size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;&lt;font color=&quot;#000000&quot;&gt;WAKE_LOCK_SUSPEND：这种锁会防止系统进入睡眠(suspend)。&lt;br&gt;WAKE_LOCK_IDLE：这种锁不会影响系统的休眠，用于阻止系统在持有锁的过程中进入低功耗状态。即直到wake_lock被释放，系统才会从idle状态进入低功耗状态，此低功耗状态将使中断延迟或禁用一组中断&lt;/font&gt; &lt;/font&gt;&lt;/font&gt;

&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;有3个地方让&lt;font color=&quot;#ff0000&quot;&gt;系统直接开始挂起&lt;/font&gt;suspend()， 分别是:&lt;/font&gt;

&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; • 在wake_unlock()中， 如果发现解锁以后没有任何其他的wake lock了，就开始休眠&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; • 在定时器都到时间以后，定时器的回调函数会查看是否有其他的wake lock，如果没有，就在这里让系统进入睡眠。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; • 在wake_lock() 中，对一个wake lock加锁以后，会再次检查一下有没有锁， 这里的检查是没有必要的， 更好的方法是使加锁的这个操作原子化，而不是繁冗的检查，而且这样的检查也有可能漏掉。&lt;/font&gt;

&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;如下是一些常见的调用wakelock的操作&lt;br&gt;&lt;br&gt;&lt;/font&gt;

&lt;table width=&quot;80%&quot; border=&quot;0&quot;&gt;&lt;br&gt;&lt;tbody&gt;&lt;br&gt;&lt;tr&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;应用&lt;/font&gt;&lt;br&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;操作&lt;/font&gt;&lt;br&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;唤醒锁的服务&lt;/font&gt;&lt;br&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot; align=&quot;center&quot;&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;运行状态&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;br&gt;&lt;tr&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;任意&lt;/font&gt;&lt;br&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;按下UI中的button或listview&lt;/font&gt;&lt;br&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;PowerManagerService&lt;/font&gt;&lt;br&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;启用并在5秒后释放锁定&lt;/font&gt;&lt;br&gt;&lt;/td&gt;&lt;/tr&gt;&lt;br&gt;&lt;tr&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;地图/导航&lt;/font&gt;&lt;br&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;启用地图或进入导航&lt;/font&gt;&lt;br&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;gps-lock&lt;/font&gt;&lt;br&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;锁定并使用GPS直到退出应用或手动设置取消GPS&lt;/font&gt;&lt;br&gt;&lt;/td&gt;&lt;/tr&gt;&lt;br&gt;&lt;tr&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;视频软件&lt;/font&gt;&lt;br&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;观看视频流&lt;/font&gt;&lt;br&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;PowerManagerService&lt;/font&gt;&lt;br&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;视频播放过程中一直启用唤醒锁&lt;/font&gt;&lt;br&gt;&lt;/td&gt;&lt;/tr&gt;&lt;br&gt;&lt;tr&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;音乐软件&lt;/font&gt;&lt;br&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;听歌&lt;/font&gt;&lt;br&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;PowerManagerService&lt;/font&gt;&lt;br&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;音乐播放过程中一直启用唤醒锁&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;Video和 Music 应用能够很好地展示不同级别的唤醒锁。 用户播放视频时，Video应用将会启用唤醒锁。 在播放视频的整个过程中，显示器会保持开启状态（忽略系统的显示设置）。 但是，如果用户在播放过程中按下了电源按钮，设备将会挂起，这会导致显示器关闭以及音频/视频停止播放。 Music 应用在播放音频时使用不同的唤醒锁。 显示设置无法更改，因此设备的屏幕将会根据用户的显示设置来关闭。 显示器关闭后，唤醒锁会让 CPU 保持活动状态以便音频能够继续播放 — 即使用户按下了电源按钮。&lt;/font&gt;

&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;上图可见，&lt;font color=&quot;#ff0000&quot;&gt;PowerManagerService&lt;/font&gt;是一项使用率非常高的wakelock调用的操作，它是Android上层电源管理服务，属于&lt;font color=&quot;#ff0000&quot;&gt;内核唤醒锁,适用于所有局部唤醒锁（partial wakelock 后文提到）的容器&lt;/font&gt;。主要负责系统待机、屏幕背光、按键背光、键盘背光以及用户事件的处理。这些可在后文的wakelock detector软件中看到。通过锁的申请和释放以及默认待机时间来控制系统的待机状态，通过系统的灭屏时间及用户操作的事件状态来控制背光暗亮。此外该服务还包括了光线、距离传感器上层查询与控制、LCD灯控制。&lt;/font&gt;

&lt;font color=&quot;#000000&quot; face=&quot;微软雅黑 Light&quot;&gt;其他的内核唤醒锁有：&lt;/font&gt;

&lt;font color=&quot;#000000&quot;&gt;Wlan_rx： 当通过 Wi-Fi* 发送或接收数据时由内核控制。&lt;/font&gt;

&lt;font color=&quot;#000000&quot;&gt;Sync： 在同步流程运行时启用。&lt;/font&gt;

&lt;font color=&quot;#000000&quot;&gt;Alarm_rtc： 控制告警（当应用或流程执行定期检查时使用）。&lt;/font&gt;

&lt;font color=&quot;#000000&quot;&gt;Main： 保持内核处于唤醒状态。 系统进入挂起模式时，这是最后一个被释放的唤醒锁。&lt;/font&gt;

&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;自最初版本的Android OS 的API中就设置了Android.OS.PowerManager.WakeLock类 &lt;/font&gt;&lt;a href=&quot;https://developer.xamarin.com/api/type/Android.OS.PowerManager+WakeLock/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;https://developer.xamarin.com/api/type/Android.OS.PowerManager+WakeLock/&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;一下为Java代码应用层的操作。&lt;/font&gt;&amp;nbsp;&lt;br&gt;&lt;br&gt;&lt;pre class=&quot;brush: java; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);//创建pm对象&lt;br&gt;PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.SCREEN_DIM_WAKE_LOCK, “Tag”);&lt;br&gt;//第一个参数为flag,即后文提到的六个标记；最后一个参数为实例名，可以换成其他的&lt;br&gt;wl.acquire(); //唤醒点亮屏幕 获取wakelock&lt;br&gt;wl.release(); //恢复屏幕到黑暗 释放wakelock&lt;/pre&gt;&lt;br&gt;&lt;br&gt;&amp;nbsp;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;2.1 API Level7开始增加了一个判断屏幕是否处于点亮状态可以使用public boolean isScreenOn ()这个方法，代码为&lt;/font&gt;

&lt;pre class=&quot;brush: java; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
boolean isScreenOn = pm.isScreenOn();
&lt;/pre&gt;

&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;对它进行实例化。&lt;/font&gt;

&lt;font size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;&lt;font color=&quot;#000000&quot;&gt;Wakelock源码简介&lt;/font&gt;&amp;nbsp; &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.07net01.com/2015/07/870479.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;font size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;http://www.07net01.com/2015/07/870479.html&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;PowerManager和Wakelock申请 &lt;a href=&quot;http://blog.csdn.net/wh_19910525/article/details/8287202&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/wh_19910525/article/details/8287202&lt;/a&gt;&lt;/font&gt;&lt;br&gt;&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;Android PowerManager API 介绍了4种用于更改设备电源状态的&lt;font color=&quot;#ff0000&quot;&gt;唤醒锁标记&lt;/font&gt;：&lt;br&gt;&lt;br&gt;&lt;/font&gt;&lt;/span&gt;&lt;br&gt;&lt;table width=&quot;80%&quot; border=&quot;0&quot;&gt;&lt;br&gt;&lt;tbody&gt;&lt;br&gt;&lt;tr&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;标记值&lt;/font&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;CPU/场景&lt;/font&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;屏幕&lt;/font&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;键盘&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;br&gt;&lt;tr&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;font color=&quot;#ff0000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;PARTIAL_WAKE_LOCK&lt;/font&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;开启-长时间运行的后台service&lt;/font&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;关闭&lt;/font&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;关闭&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;br&gt;&lt;tr&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;SCREEN_DIM_WAKE_LOCK&lt;/font&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;开启-除非必须保持CPU运行至运算完成，否则尽量使用FLAG_KEEP_SCREEN_ON&lt;/font&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;低亮度&lt;/font&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;关闭&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;br&gt;&lt;tr&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;SCREEN_BRIGHT_WAKE_LOCK&lt;/font&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;同上&lt;/font&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;高亮度&lt;/font&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;关闭&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;br&gt;&lt;tr&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;FULL_WAKE_LOCK&lt;/font&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;同上&lt;/font&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;高亮度&lt;/font&gt;&lt;/td&gt;&lt;br&gt;&lt;td width=&quot;20%&quot;&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;调亮&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;br&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;需要注意的是 API17开始，FULL_WAKE_LOCK将被弃用，取而代之的是FLAG_KEEP_SCREEN_ON 因此有的检测软件也将屏幕亮屏所单独提出来，表明调用该锁时目的是保证屏幕不会超时熄灭。&lt;/font&gt;

&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;除了四个标记值外，还提供了两个Flag配合使用。&lt;/font&gt;

&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;ACQUIRE_CAUSES_WAKEUP：默认情况下唤醒锁并不是马上开启CPU、屏幕或者调整键盘的亮度（对于屏幕处于低亮度或高亮度、键盘处于高亮，唤醒锁只是在被开启后，延续这一状态）但如果加上这一标记，就可让屏幕或键盘亮度未开启的状态下，马上开启它们。典型的例子就是受到一个重要的notification时（短信、邮件等），需要马上点亮屏幕。&lt;/font&gt;

&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;ON_AFTER_RELEASE：当wake lock被释放的时候，当前调用wake lock的activity的计数器会被重置，所以屏幕会继续亮一段时间。&lt;/font&gt;

&lt;font size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;&lt;font color=&quot;#000000&quot;&gt;因此，Android中通常是这么写。&lt;/font&gt;&lt;br&gt;&lt;/font&gt;&lt;/font&gt;&lt;br&gt;&lt;div align=&quot;center&quot;&gt;&lt;pre class=&quot;brush: java; gutter: true; first-line: 1; highlight: []; html-script: false&quot;&gt;PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);&lt;br&gt;&lt;br&gt; WakeLock sCpuWakeLock = pm.newWakeLock(&lt;br&gt;                PowerManager.FULL_WAKE_LOCK |&lt;br&gt;                PowerManager.ACQUIRE_CAUSES_WAKEUP,”okTag”);&lt;br&gt; if (sCpuWakeLock!= null) {&lt;br&gt; sCpuWakeLock.release();&lt;br&gt;          sCpuWakeLock = null;&lt;br&gt;&lt;br&gt;}&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;&lt;/font&gt;&amp;nbsp;&lt;br&gt;&lt;br&gt;&lt;strong&gt;&lt;font color=&quot;#ff0000&quot;&gt;注意&lt;/font&gt;&lt;/strong&gt;：如果申请了&lt;font color=&quot;#ff0000&quot;&gt;partial wakelock&lt;/font&gt;,那么即使按Power键,系统也不会进Sleep,如Music播放时。所有的锁必须成对的使用, 如果申请了而没有及时释放，会造成系统故障。如申请了partial wakelock,而没有及时释放, 那系统就永远进不了Sleep模式.&lt;br&gt;&lt;br&gt;因此，partial wakelock作为6中标识中，需最为谨慎使用的一个。BBS也专门指出了partial wakelock造成的电量损耗及待机时长。其余的则可标记为屏幕锁，辅助标记CPU锁。&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#000000&quot; face=&quot;微软雅黑 Light&quot;&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/68eb7c93gw1eztpciku00j20de0bjjsd.jpg&quot; alt=&quot;&quot;&gt;&lt;/font&gt;

&lt;font size=&quot;4&quot;&gt;&lt;font color=&quot;#000000&quot; face=&quot;微软雅黑 Light&quot;&gt;&lt;strong&gt;上图表明了App内部、Android框架及内核硬件在唤醒锁交互中的流程。&lt;/strong&gt;&lt;/font&gt;&lt;/font&gt;

&lt;font size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;&lt;font color=&quot;#ff0000&quot;&gt;&lt;strong&gt;AlarmManager&lt;/strong&gt;&lt;/font&gt;&lt;font color=&quot;#000000&quot;&gt;，有一个AlarmManagerService,该服务程序主要维护app注册下来的各类Alarm,并且一直监听Alarm设备，一旦有Alarm触发，或者是Alarm事件发生，AlarmManagerService就会遍历Alarm列表，找到相应的注册Alarm并发出广播，是Android中常用的一种&lt;font color=&quot;#ff0000&quot;&gt;系统级别的提示服务&lt;/font&gt;，在特定的时刻为我们广播一个指定的Intent。通常我们使用 PendingIntent，可以理解为Intent的封装包，在Intent上在加个指定的动作。在使用Intent的时候，我们还需要在执行startActivity、startService或sendBroadcast才能使Intent有用。而PendingIntent的话就是将这个动作包含在内了。&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;

&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;闹钟响起，实际上是系统发出了为这个&lt;font color=&quot;#ff0000&quot;&gt;闹钟注册的广播&lt;/font&gt;，会自动开启目标应用。这种做法可以在某一时刻当做唤醒应用。注册的闹钟在设备睡眠的时候仍然会保留，可以选择性地设置是否唤醒设备，但是当设备关机和重启后，闹钟将会被清除。在alarm的receiver的onReceive()方法被执行的时候，Alarm Manager持有一个CPU唤醒锁，这样就保证了设备在处理完广播之前不会sleep。&lt;/font&gt;

&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;font color=&quot;#000000&quot;&gt;&lt;font size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;有4种Alarm类型： &lt;wbr&gt;&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;&lt;/span&gt;&lt;/p&gt;
&lt;font color=&quot;#000000&quot;&gt;&lt;font size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;1)&lt;/font&gt;&lt;font size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;&lt;font color=&quot;#ff0000&quot;&gt;RTC_WAKEUP &lt;wbr&gt;&lt;br&gt;&lt;/font&gt;在指定的时刻（设置Alarm的时候），唤醒设备来触发Intent。（闹钟）&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;&lt;font size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt; &lt;/font&gt;

&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;font color=&quot;#000000&quot;&gt;&lt;font size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;2)&lt;font color=&quot;#ff0000&quot;&gt;RTC&lt;/font&gt; &lt;wbr&gt;&lt;br&gt;在一个显式的时间触发Intent，但不唤醒设备。&lt;wbr&gt;&lt;wbr&gt;&lt;wbr&gt;&lt;br&gt;3)&lt;/font&gt;&lt;font size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;&lt;font color=&quot;#ff0000&quot;&gt;ELAPSED_REALTIME &lt;wbr&gt;&lt;br&gt;&lt;/font&gt;从设备启动后，如果流逝的时间达到总时间，那么触发Intent，但不唤醒设备。流逝的时间包括设备睡眠的任何时间。注意一点的是，时间流逝的计算点是自从它最后一次启动算起。 &lt;wbr&gt;&amp;nbsp;&lt;wbr&gt;&amp;nbsp;&lt;wbr&gt;&lt;br&gt;4)&lt;font color=&quot;#ff0000&quot;&gt;ELAPSED_REALTIME_WAKEUP&lt;/font&gt; &lt;wbr&gt;&lt;br&gt;从设备启动后，达到流逝的总时间后，如果需要将唤醒设备并触发Intent。&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;这样，唤醒对齐的方案就显得相当便捷，让唤醒次数大大降低。把允许唤醒的应用，按照某一合理的时刻进行排序和对齐，不会凌乱的唤醒手机而出现过度的cpu变频造成的耗电。&lt;/font&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;font color=&quot;#000000&quot;&gt;&lt;font size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;&lt;font color=&quot;#ff0000&quot;&gt;软节电&lt;/font&gt;方案：&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;1、对不需要联网、不需要通知的 限制权限&amp;amp;App自调 取消通知、联网等权限 杀注册广播&lt;/font&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;2、限制通知和自启动、互相启动、相互守护的service 禁启动&lt;/font&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;3、（千万少做）安全软件狂杀进程process和service&lt;/font&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;4、限制唤醒时长和对齐唤醒&lt;/font&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;5、对可识别的Activity禁止&lt;/font&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;6、对不需要通知、自升级、关闭软件啥也不想让他做的 结晶 禁止、半禁止一切后台&lt;/font&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;7、争取多冬眠service&lt;/font&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;8、在合理的时间重启并FQ&lt;/font&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;So 开搞&lt;/font&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;font color=&quot;#000000&quot; face=&quot;微软雅黑 Light&quot;&gt;&lt;/font&gt;&lt;/span&gt;参考&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.runoob.com/w3cnote/android-tutorial-powermanager.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.runoob.com/w3cnote/android-tutorial-powermanager.html&lt;/a&gt;&amp;nbsp; PowerManager(电源服务)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.kancloud.cn/kancloud/android-tutorial/87277&quot; title=&quot;http://www.kancloud.cn/kancloud/android-tutorial/87277&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.kancloud.cn/kancloud/android-tutorial/87277&lt;/a&gt; 这俩好像一样、&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://forum.xda-developers.com/galaxy-s2/general/guide-complete-guide-maximum-battery-t1909996&quot; title=&quot;http://forum.xda-developers.com/galaxy-s2/general/guide-complete-guide-maximum-battery-t1909996&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://forum.xda-developers.com/galaxy-s2/general/guide-complete-guide-maximum-battery-t1909996&lt;/a&gt; 真的是能关的全给关了的大全&lt;/p&gt;
&lt;font size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;&lt;/font&gt;

&lt;font size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;&lt;/font&gt;

&lt;font size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;&lt;/font&gt;

&lt;p&gt;&lt;a href=&quot;http://lockekk.github.io/jekyll-bootstrap/2014/07/22/Android-Standby/&quot; title=&quot;http://lockekk.github.io/jekyll-bootstrap/2014/07/22/Android-Standby/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://lockekk.github.io/jekyll-bootstrap/2014/07/22/Android-Standby/&lt;/a&gt; Android Standby 解析查杀软件的弊病&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;font color=&quot;#000000&quot;&gt;&lt;/font&gt;**&lt;/strong&gt;&lt;font color=&quot;#000000&quot; size=&quot;4&quot;&gt;&lt;font face=&quot;微软雅黑 Light&quot;&gt;本文只讨论安卓手机软节电，不负责推荐底包、rom、调频调压方案，&lt;font color=&quot;#ff0000&quot;&gt;刷机root后果自负。&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;**&lt;/p&gt;
&lt;font color=&quot;#000000&quot; size=&quot;4&quot; face=&quot;微软雅黑 Light&quot;&gt;&lt;strong&gt;纯硬货，只想节电看后文。&lt;/strong&gt;&lt;/font&gt;
    
    </summary>
    
      <category term="App强推" scheme="http://ovjaywang.github.io/categories/App%E5%BC%BA%E6%8E%A8/"/>
    
      <category term="软文" scheme="http://ovjaywang.github.io/categories/App%E5%BC%BA%E6%8E%A8/%E8%BD%AF%E6%96%87/"/>
    
    
      <category term="Android" scheme="http://ovjaywang.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>后方交会检校(8)--光束法区域平差 Bundle Block Adjustment</title>
    <link href="http://ovjaywang.github.io/2015/11/18/%E5%90%8E%E6%96%B9%E4%BA%A4%E4%BC%9A%E6%A3%80%E6%A0%A1(8)/"/>
    <id>http://ovjaywang.github.io/2015/11/18/后方交会检校(8)/</id>
    <published>2015-11-18T15:17:39.000Z</published>
    <updated>2016-04-11T14:09:45.581Z</updated>
    
    <content type="html">&lt;font size=&quot;3&quot;&gt;航空摄影最终的目标都是，将某一波段的图像（传感器接收的某一宽度波长的电磁波），在一定范围（地理空间范畴）内融合在一起。原因有：&lt;/font&gt;&lt;br&gt;&lt;br&gt;&lt;font size=&quot;3&quot;&gt;①拍摄的每幅图像幅宽有限（高的分辨率不够低了拍的面积不够多）&lt;/font&gt;

&lt;font size=&quot;3&quot;&gt;②需要研究的区域相对一张或几张照片来说，太太太大了，没有或难以测量地面的标识，就只能靠拼接（然而飞机需要飞行，飞行需要时间，时间就带来光照、镜头本身、飞行姿态等各种变化）&lt;/font&gt;

&lt;font size=&quot;3&quot;&gt;③除了高端的飞机带有精度极高的POS（position &amp;amp; orientation system）能够实时记录飞行的姿态，即飞机的朝向、飞机的地理位置等明确告诉我该用哪个位置的点拼起来的，其他只能依赖，连续两张图片的相关性来拼（这里讲的就是，同名点即tie point）&lt;/font&gt;

&lt;p&gt;——航摄大致思路？完成这一工作，最主要的工作是法一：利用地面其他物体的三维坐标（灰机、相机的某一时刻姿态也可以）点确定相邻两幅图像的地理位置（三维的，依赖地理空间的）——&amp;gt;解算相对位置；法二，利用同名点（两幅图像都拍到的点，二维的，不依赖地理空间的），找到某个投影变换（即一个投影矩阵），直接解求两幅相邻图像的相对位置。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;font size=&quot;3&quot;&gt;航摄中常用的三种用于加密控制点的方法有&lt;span style=&quot;color: #ff0000&quot;&gt;航带法、独立模型法、光束法&lt;/span&gt;。其中航带法精度较低，不能用于高精度的测量。独立模型法较前者精度略高，光束法则是精度最高同时计算量最大的模型，适用于高精度航摄。&lt;/font&gt;

&lt;font size=&quot;3&quot;&gt;——用来做啥?不同时刻的航摄图片，对绝对位置或相对坐标进行确认，为拼接准备。&lt;/font&gt;

&lt;font size=&quot;3&quot;&gt;&lt;font color=&quot;#ff0000&quot;&gt;自检较光束&lt;/font&gt;则是最广泛应用的做法，尽管&lt;font size=&quot;3&quot;&gt;粗差（奇葩的大误差）对于精度的影响极大&lt;/font&gt;。其基本思想是选用一个由若干个参数组成的系统误差模型，将这些附加参数作为未知数与区域网的其他参数一起解求，从而达到在平差过程中自动消除系统误差的目的。其缺点是①&lt;span style=&quot;color: #ff0000&quot;&gt;附加参数人为选择&lt;/span&gt;，选择不当会导致迭代结果不收敛恶化计算结果。②附加参数与区域网参数一起解求，会使&lt;span style=&quot;color: #ff0000&quot;&gt;计算量明显上升&lt;/span&gt;。&lt;/font&gt;

&lt;font size=&quot;3&quot;&gt;&lt;/font&gt;&amp;nbsp;&lt;br&gt;&lt;br&gt;&lt;font size=&quot;3&quot;&gt;光束法平差以单个像片作为平差单元（意思就是一个观测值是一个像片，主要包含像片的内外方位元素，它们作为一个整体，就如测量一个高程的值 一个坐标的值一样&amp;nbsp; 在整个区域进行一边计算一边排错 进行平差处理 解算出每张相片的外方位元素 然后按照前方交会计算加密点（不同像片的拍下的重复点 tie point）坐标。&lt;/font&gt;

&lt;div class=&quot;PoweredByWebStory&quot; style=&quot;margin-bottom: 10px; margin-top: 15px&quot;&gt;&lt;font size=&quot;3&quot;&gt;&amp;nbsp;&lt;/font&gt;&lt;/div&gt;

&lt;font size=&quot;3&quot;&gt;&lt;/font&gt;</content>
    
    <summary type="html">
    
      &lt;font size=&quot;3&quot;&gt;航空摄影最终的目标都是，将某一波段的图像（传感器接收的某一宽度波长的电磁波），在一定范围（地理空间范畴）内融合在一起。原因有：&lt;/font&gt;&lt;br&gt;&lt;br&gt;&lt;font size=&quot;3&quot;&gt;①拍摄的每幅图像幅宽有限（高的分辨率不够低了拍的面积不够多）&lt;/
    
    </summary>
    
      <category term="什么都学一下" scheme="http://ovjaywang.github.io/categories/%E4%BB%80%E4%B9%88%E9%83%BD%E5%AD%A6%E4%B8%80%E4%B8%8B/"/>
    
      <category term="学习log" scheme="http://ovjaywang.github.io/categories/%E4%BB%80%E4%B9%88%E9%83%BD%E5%AD%A6%E4%B8%80%E4%B8%8B/%E5%AD%A6%E4%B9%A0log/"/>
    
    
      <category term="检校" scheme="http://ovjaywang.github.io/tags/%E6%A3%80%E6%A0%A1/"/>
    
  </entry>
  
</feed>
